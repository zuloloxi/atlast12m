; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\A15\facultate\forth\atlast-1.2\atlmain.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG5200	DB	'ATLAST 1.2m (2019-04-07) This program is in the public d'
	DB	'omain.', 0aH, 00H
$SG5220	DB	'Usage:  ATLAST [options] [inputfile]', 0aH, 00H
	ORG $+2
$SG5222	DB	'        Options:', 0aH, 00H
	ORG $+2
$SG5224	DB	'           -D     Treat file as definitions', 0aH, 00H
	ORG $+3
$SG5226	DB	'           -Hn    Heap length n', 0aH, 00H
	ORG $+3
$SG5228	DB	'           -Ifile Include named definition file', 0aH, 00H
	ORG $+3
$SG5230	DB	'           -Rn    Return stack length n', 0aH, 00H
	ORG $+3
$SG5232	DB	'           -Sn    Stack length n', 0aH, 00H
	ORG $+2
$SG5234	DB	'           -T     Set TRACE mode', 0aH, 00H
	ORG $+2
$SG5236	DB	'           -U     Print this message', 0aH, 00H
	ORG $+2
$SG5241	DB	'Duplicate file name.', 0aH, 00H
	ORG $+2
$SG5246	DB	'.atl', 00H
	ORG $+3
$SG5247	DB	'r', 00H
	ORG $+2
$SG5251	DB	'Unable to open file %s', 0aH, 00H
$SG5262	DB	'.atl', 00H
	ORG $+3
$SG5263	DB	'rb', 00H
	ORG $+1
$SG5267	DB	'Unable to open include file %s', 0aH, 00H
$SG5271	DB	0aH, 'Error %d in include file %s', 0aH, 00H
	ORG $+2
$SG5280	DB	'(  ', 00H
$SG5281	DB	':> ', 00H
$SG5282	DB	'-> ', 00H
$SG5289	DB	0aH, 00H
_DATA	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_main
EXTRN	_atl_eval:PROC
EXTRN	_fgets:PROC
EXTRN	_atl__hb:DWORD
EXTRN	_atl_comment:DWORD
EXTRN	_signal:PROC
EXTRN	_printf:PROC
EXTRN	_fclose:PROC
EXTRN	_atl_load:PROC
EXTRN	_fopen:PROC
EXTRN	_strcat:PROC
EXTRN	_strchr:PROC
EXTRN	_strcpy:PROC
EXTRN	_atl_trace:DWORD
EXTRN	_atl_stklen:DWORD
EXTRN	_atl_rstklen:DWORD
EXTRN	_atl_heaplen:DWORD
EXTRN	_atol:PROC
EXTRN	_toupper:PROC
EXTRN	_islower:PROC
EXTRN	_fprintf:PROC
EXTRN	___iob_func:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Odtp
; File c:\a15\facultate\forth\atlast-1.2\atlmain.c
_TEXT	SEGMENT
tv230 = -548						; size = 4
tv232 = -544						; size = 4
tv85 = -540						; size = 4
_t$5276 = -536						; size = 132
_fn$5256 = -400						; size = 132
_stat$5255 = -264					; size = 4
_fp$5257 = -260						; size = 4
_fn$5238 = -256						; size = 132
__$ArrayPad$ = -116					; size = 4
_opt$5205 = -109					; size = 1
_cp$5204 = -108						; size = 4
_defmode$ = -104					; size = 4
_in$ = -100						; size = 4
_include$ = -96						; size = 80
_i$ = -12						; size = 4
_fname$ = -8						; size = 4
_ifp$ = -4						; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC

; 47   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 02 00
	00		 sub	 esp, 548		; 00000224H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 8c	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 48   :     int i;
; 49   :     int fname = FALSE, defmode = FALSE;

  00013	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _fname$[ebp], 0
  0001a	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _defmode$[ebp], 0

; 50   :     FILE *ifp;
; 51   :     char *include[20];
; 52   :     int in = 0;

  00021	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR _in$[ebp], 0

; 53   : #define PR(x) (void) fprintf(stderr, x)
; 54   : 
; 55   :     PR("ATLAST 1.2m (2019-04-07) This program is in the public domain.\n");

  00028	68 00 00 00 00	 push	 OFFSET $SG5200
  0002d	e8 00 00 00 00	 call	 ___iob_func
  00032	83 c0 40	 add	 eax, 64			; 00000040H
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _fprintf
  0003b	83 c4 08	 add	 esp, 8

; 56   :     ifp = stdin;

  0003e	e8 00 00 00 00	 call	 ___iob_func
  00043	89 45 fc	 mov	 DWORD PTR _ifp$[ebp], eax

; 57   :     for (i = 1; i < argc; i++) {

  00046	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  0004d	eb 09		 jmp	 SHORT $LN30@main
$LN29@main:
  0004f	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00052	83 c0 01	 add	 eax, 1
  00055	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN30@main:
  00058	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0005b	3b 4d 08	 cmp	 ecx, DWORD PTR _argc$[ebp]
  0005e	0f 8d 8c 02 00
	00		 jge	 $LN28@main

; 58   : 	char *cp, opt;
; 59   : 
; 60   : 	cp = argv[i];

  00064	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00067	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  0006a	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  0006d	89 4d 94	 mov	 DWORD PTR _cp$5204[ebp], ecx

; 61   :         if (*cp == '-') {

  00070	8b 55 94	 mov	 edx, DWORD PTR _cp$5204[ebp]
  00073	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00076	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00079	0f 85 bf 01 00
	00		 jne	 $LN27@main

; 62   : 	    opt = *(++cp);

  0007f	8b 4d 94	 mov	 ecx, DWORD PTR _cp$5204[ebp]
  00082	83 c1 01	 add	 ecx, 1
  00085	89 4d 94	 mov	 DWORD PTR _cp$5204[ebp], ecx
  00088	8b 55 94	 mov	 edx, DWORD PTR _cp$5204[ebp]
  0008b	8a 02		 mov	 al, BYTE PTR [edx]
  0008d	88 45 93	 mov	 BYTE PTR _opt$5205[ebp], al

; 63   : 	    if (islower(opt))

  00090	0f be 4d 93	 movsx	 ecx, BYTE PTR _opt$5205[ebp]
  00094	51		 push	 ecx
  00095	e8 00 00 00 00	 call	 _islower
  0009a	83 c4 04	 add	 esp, 4
  0009d	85 c0		 test	 eax, eax
  0009f	74 10		 je	 SHORT $LN26@main

; 64   : 		opt = toupper(opt);

  000a1	0f be 55 93	 movsx	 edx, BYTE PTR _opt$5205[ebp]
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 _toupper
  000ab	83 c4 04	 add	 esp, 4
  000ae	88 45 93	 mov	 BYTE PTR _opt$5205[ebp], al
$LN26@main:

; 65   : 	    switch (opt) {

  000b1	0f be 45 93	 movsx	 eax, BYTE PTR _opt$5205[ebp]
  000b5	89 85 e4 fd ff
	ff		 mov	 DWORD PTR tv85[ebp], eax
  000bb	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR tv85[ebp]
  000c1	83 e9 3f	 sub	 ecx, 63			; 0000003fH
  000c4	89 8d e4 fd ff
	ff		 mov	 DWORD PTR tv85[ebp], ecx
  000ca	83 bd e4 fd ff
	ff 16		 cmp	 DWORD PTR tv85[ebp], 22	; 00000016H
  000d1	0f 87 62 01 00
	00		 ja	 $LN24@main
  000d7	8b 95 e4 fd ff
	ff		 mov	 edx, DWORD PTR tv85[ebp]
  000dd	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN38@main[edx]
  000e4	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN39@main[eax*4]
$LN23@main:

; 66   : 
; 67   :                 case 'D':
; 68   : 		    defmode = TRUE;

  000eb	c7 45 98 01 00
	00 00		 mov	 DWORD PTR _defmode$[ebp], 1

; 69   : 		    break;

  000f2	e9 42 01 00 00	 jmp	 $LN24@main
$LN22@main:

; 70   : 
; 71   :                 case 'H':
; 72   : 		    atl_heaplen = atol(cp + 1);

  000f7	8b 4d 94	 mov	 ecx, DWORD PTR _cp$5204[ebp]
  000fa	83 c1 01	 add	 ecx, 1
  000fd	51		 push	 ecx
  000fe	e8 00 00 00 00	 call	 _atol
  00103	83 c4 04	 add	 esp, 4
  00106	a3 00 00 00 00	 mov	 DWORD PTR _atl_heaplen, eax

; 73   : 		    break;

  0010b	e9 29 01 00 00	 jmp	 $LN24@main
$LN21@main:

; 74   : 
; 75   :                 case 'I':
; 76   : 		    include[in++] = cp + 1;

  00110	8b 55 94	 mov	 edx, DWORD PTR _cp$5204[ebp]
  00113	83 c2 01	 add	 edx, 1
  00116	8b 45 9c	 mov	 eax, DWORD PTR _in$[ebp]
  00119	89 54 85 a0	 mov	 DWORD PTR _include$[ebp+eax*4], edx
  0011d	8b 4d 9c	 mov	 ecx, DWORD PTR _in$[ebp]
  00120	83 c1 01	 add	 ecx, 1
  00123	89 4d 9c	 mov	 DWORD PTR _in$[ebp], ecx

; 77   : 		    break;

  00126	e9 0e 01 00 00	 jmp	 $LN24@main
$LN20@main:

; 78   : 
; 79   :                 case 'R':
; 80   : 		    atl_rstklen = atol(cp + 1);

  0012b	8b 55 94	 mov	 edx, DWORD PTR _cp$5204[ebp]
  0012e	83 c2 01	 add	 edx, 1
  00131	52		 push	 edx
  00132	e8 00 00 00 00	 call	 _atol
  00137	83 c4 04	 add	 esp, 4
  0013a	a3 00 00 00 00	 mov	 DWORD PTR _atl_rstklen, eax

; 81   : 		    break;

  0013f	e9 f5 00 00 00	 jmp	 $LN24@main
$LN19@main:

; 82   : 
; 83   :                 case 'S':
; 84   : 		    atl_stklen = atol(cp + 1);

  00144	8b 45 94	 mov	 eax, DWORD PTR _cp$5204[ebp]
  00147	83 c0 01	 add	 eax, 1
  0014a	50		 push	 eax
  0014b	e8 00 00 00 00	 call	 _atol
  00150	83 c4 04	 add	 esp, 4
  00153	a3 00 00 00 00	 mov	 DWORD PTR _atl_stklen, eax

; 85   : 		    break;

  00158	e9 dc 00 00 00	 jmp	 $LN24@main
$LN18@main:

; 86   : 
; 87   :                 case 'T':
; 88   : 		    atl_trace = TRUE;

  0015d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _atl_trace, 1

; 89   : 		    break;

  00167	e9 cd 00 00 00	 jmp	 $LN24@main
$LN17@main:

; 90   : 
; 91   :                 case '?':
; 92   :                 case 'U':
; 93   :                     PR("Usage:  ATLAST [options] [inputfile]\n");

  0016c	68 00 00 00 00	 push	 OFFSET $SG5220
  00171	e8 00 00 00 00	 call	 ___iob_func
  00176	83 c0 40	 add	 eax, 64			; 00000040H
  00179	50		 push	 eax
  0017a	e8 00 00 00 00	 call	 _fprintf
  0017f	83 c4 08	 add	 esp, 8

; 94   :                     PR("        Options:\n");

  00182	68 00 00 00 00	 push	 OFFSET $SG5222
  00187	e8 00 00 00 00	 call	 ___iob_func
  0018c	83 c0 40	 add	 eax, 64			; 00000040H
  0018f	50		 push	 eax
  00190	e8 00 00 00 00	 call	 _fprintf
  00195	83 c4 08	 add	 esp, 8

; 95   :                     PR("           -D     Treat file as definitions\n");

  00198	68 00 00 00 00	 push	 OFFSET $SG5224
  0019d	e8 00 00 00 00	 call	 ___iob_func
  001a2	83 c0 40	 add	 eax, 64			; 00000040H
  001a5	50		 push	 eax
  001a6	e8 00 00 00 00	 call	 _fprintf
  001ab	83 c4 08	 add	 esp, 8

; 96   :                     PR("           -Hn    Heap length n\n");

  001ae	68 00 00 00 00	 push	 OFFSET $SG5226
  001b3	e8 00 00 00 00	 call	 ___iob_func
  001b8	83 c0 40	 add	 eax, 64			; 00000040H
  001bb	50		 push	 eax
  001bc	e8 00 00 00 00	 call	 _fprintf
  001c1	83 c4 08	 add	 esp, 8

; 97   :                     PR("           -Ifile Include named definition file\n");

  001c4	68 00 00 00 00	 push	 OFFSET $SG5228
  001c9	e8 00 00 00 00	 call	 ___iob_func
  001ce	83 c0 40	 add	 eax, 64			; 00000040H
  001d1	50		 push	 eax
  001d2	e8 00 00 00 00	 call	 _fprintf
  001d7	83 c4 08	 add	 esp, 8

; 98   :                     PR("           -Rn    Return stack length n\n");

  001da	68 00 00 00 00	 push	 OFFSET $SG5230
  001df	e8 00 00 00 00	 call	 ___iob_func
  001e4	83 c0 40	 add	 eax, 64			; 00000040H
  001e7	50		 push	 eax
  001e8	e8 00 00 00 00	 call	 _fprintf
  001ed	83 c4 08	 add	 esp, 8

; 99   :                     PR("           -Sn    Stack length n\n");

  001f0	68 00 00 00 00	 push	 OFFSET $SG5232
  001f5	e8 00 00 00 00	 call	 ___iob_func
  001fa	83 c0 40	 add	 eax, 64			; 00000040H
  001fd	50		 push	 eax
  001fe	e8 00 00 00 00	 call	 _fprintf
  00203	83 c4 08	 add	 esp, 8

; 100  :                     PR("           -T     Set TRACE mode\n");

  00206	68 00 00 00 00	 push	 OFFSET $SG5234
  0020b	e8 00 00 00 00	 call	 ___iob_func
  00210	83 c0 40	 add	 eax, 64			; 00000040H
  00213	50		 push	 eax
  00214	e8 00 00 00 00	 call	 _fprintf
  00219	83 c4 08	 add	 esp, 8

; 101  :                     PR("           -U     Print this message\n");

  0021c	68 00 00 00 00	 push	 OFFSET $SG5236
  00221	e8 00 00 00 00	 call	 ___iob_func
  00226	83 c0 40	 add	 eax, 64			; 00000040H
  00229	50		 push	 eax
  0022a	e8 00 00 00 00	 call	 _fprintf
  0022f	83 c4 08	 add	 esp, 8

; 102  : 		    return 0;

  00232	33 c0		 xor	 eax, eax
  00234	e9 97 02 00 00	 jmp	 $LN31@main
$LN24@main:

; 103  : 	    }
; 104  : 	} else {

  00239	e9 ad 00 00 00	 jmp	 $LN16@main
$LN27@main:

; 105  : 	    char fn[132];
; 106  : 
; 107  : 	    if (fname) {

  0023e	83 7d f8 00	 cmp	 DWORD PTR _fname$[ebp], 0
  00242	74 20		 je	 SHORT $LN15@main

; 108  :                 PR("Duplicate file name.\n");

  00244	68 00 00 00 00	 push	 OFFSET $SG5241
  00249	e8 00 00 00 00	 call	 ___iob_func
  0024e	83 c0 40	 add	 eax, 64			; 00000040H
  00251	50		 push	 eax
  00252	e8 00 00 00 00	 call	 _fprintf
  00257	83 c4 08	 add	 esp, 8

; 109  : 		return 1;

  0025a	b8 01 00 00 00	 mov	 eax, 1
  0025f	e9 6c 02 00 00	 jmp	 $LN31@main
$LN15@main:

; 110  : 	    }
; 111  : 	    fname = TRUE;

  00264	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _fname$[ebp], 1

; 112  : 	    V strcpy(fn, cp);

  0026b	8b 4d 94	 mov	 ecx, DWORD PTR _cp$5204[ebp]
  0026e	51		 push	 ecx
  0026f	8d 95 00 ff ff
	ff		 lea	 edx, DWORD PTR _fn$5238[ebp]
  00275	52		 push	 edx
  00276	e8 00 00 00 00	 call	 _strcpy
  0027b	83 c4 08	 add	 esp, 8

; 113  :             if (strchr(fn, '.') == NULL)

  0027e	6a 2e		 push	 46			; 0000002eH
  00280	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _fn$5238[ebp]
  00286	50		 push	 eax
  00287	e8 00 00 00 00	 call	 _strchr
  0028c	83 c4 08	 add	 esp, 8
  0028f	85 c0		 test	 eax, eax
  00291	75 14		 jne	 SHORT $LN14@main

; 114  :                 V strcat(fn, ".atl");

  00293	68 00 00 00 00	 push	 OFFSET $SG5246
  00298	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _fn$5238[ebp]
  0029e	51		 push	 ecx
  0029f	e8 00 00 00 00	 call	 _strcat
  002a4	83 c4 08	 add	 esp, 8
$LN14@main:

; 115  :             ifp = fopen(fn, "r");

  002a7	68 00 00 00 00	 push	 OFFSET $SG5247
  002ac	8d 95 00 ff ff
	ff		 lea	 edx, DWORD PTR _fn$5238[ebp]
  002b2	52		 push	 edx
  002b3	e8 00 00 00 00	 call	 _fopen
  002b8	83 c4 08	 add	 esp, 8
  002bb	89 45 fc	 mov	 DWORD PTR _ifp$[ebp], eax

; 116  : 	    if (ifp == NULL) {

  002be	83 7d fc 00	 cmp	 DWORD PTR _ifp$[ebp], 0
  002c2	75 27		 jne	 SHORT $LN16@main

; 117  :                 V fprintf(stderr, "Unable to open file %s\n", fn);

  002c4	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _fn$5238[ebp]
  002ca	50		 push	 eax
  002cb	68 00 00 00 00	 push	 OFFSET $SG5251
  002d0	e8 00 00 00 00	 call	 ___iob_func
  002d5	83 c0 40	 add	 eax, 64			; 00000040H
  002d8	50		 push	 eax
  002d9	e8 00 00 00 00	 call	 _fprintf
  002de	83 c4 0c	 add	 esp, 12			; 0000000cH

; 118  : 		return 1;

  002e1	b8 01 00 00 00	 mov	 eax, 1
  002e6	e9 e5 01 00 00	 jmp	 $LN31@main
$LN16@main:

; 119  : 	    }
; 120  : 	}
; 121  :      }

  002eb	e9 5f fd ff ff	 jmp	 $LN29@main
$LN28@main:

; 122  : 
; 123  :     /* If any include files were named, load each in turn before
; 124  :        we execute the program. */
; 125  : 
; 126  :     for (i = 0; i < in; i++) {

  002f0	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  002f7	eb 09		 jmp	 SHORT $LN12@main
$LN11@main:
  002f9	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  002fc	83 c1 01	 add	 ecx, 1
  002ff	89 4d f4	 mov	 DWORD PTR _i$[ebp], ecx
$LN12@main:
  00302	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00305	3b 55 9c	 cmp	 edx, DWORD PTR _in$[ebp]
  00308	0f 8d d9 00 00
	00		 jge	 $LN10@main

; 127  : 	int stat;
; 128  : 	char fn[132];
; 129  : 	FILE *fp;
; 130  : 
; 131  : 	V strcpy(fn, include[i]);

  0030e	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00311	8b 4c 85 a0	 mov	 ecx, DWORD PTR _include$[ebp+eax*4]
  00315	51		 push	 ecx
  00316	8d 95 70 fe ff
	ff		 lea	 edx, DWORD PTR _fn$5256[ebp]
  0031c	52		 push	 edx
  0031d	e8 00 00 00 00	 call	 _strcpy
  00322	83 c4 08	 add	 esp, 8

; 132  :         if (strchr(fn, '.') == NULL)

  00325	6a 2e		 push	 46			; 0000002eH
  00327	8d 85 70 fe ff
	ff		 lea	 eax, DWORD PTR _fn$5256[ebp]
  0032d	50		 push	 eax
  0032e	e8 00 00 00 00	 call	 _strchr
  00333	83 c4 08	 add	 esp, 8
  00336	85 c0		 test	 eax, eax
  00338	75 14		 jne	 SHORT $LN9@main

; 133  :             V strcat(fn, ".atl");

  0033a	68 00 00 00 00	 push	 OFFSET $SG5262
  0033f	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR _fn$5256[ebp]
  00345	51		 push	 ecx
  00346	e8 00 00 00 00	 call	 _strcat
  0034b	83 c4 08	 add	 esp, 8
$LN9@main:

; 134  : 	fp = fopen(fn,
; 135  : #ifdef FBmode
; 136  :                         "rb"
; 137  : #else
; 138  :                         "r"
; 139  : #endif
; 140  : 		  );

  0034e	68 00 00 00 00	 push	 OFFSET $SG5263
  00353	8d 95 70 fe ff
	ff		 lea	 edx, DWORD PTR _fn$5256[ebp]
  00359	52		 push	 edx
  0035a	e8 00 00 00 00	 call	 _fopen
  0035f	83 c4 08	 add	 esp, 8
  00362	89 85 fc fe ff
	ff		 mov	 DWORD PTR _fp$5257[ebp], eax

; 141  : 	if (fp == NULL) {

  00368	83 bd fc fe ff
	ff 00		 cmp	 DWORD PTR _fp$5257[ebp], 0
  0036f	75 28		 jne	 SHORT $LN8@main

; 142  :             V fprintf(stderr, "Unable to open include file %s\n",
; 143  : 		include[i]);

  00371	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00374	8b 4c 85 a0	 mov	 ecx, DWORD PTR _include$[ebp+eax*4]
  00378	51		 push	 ecx
  00379	68 00 00 00 00	 push	 OFFSET $SG5267
  0037e	e8 00 00 00 00	 call	 ___iob_func
  00383	83 c0 40	 add	 eax, 64			; 00000040H
  00386	50		 push	 eax
  00387	e8 00 00 00 00	 call	 _fprintf
  0038c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 144  : 	    return 1;

  0038f	b8 01 00 00 00	 mov	 eax, 1
  00394	e9 37 01 00 00	 jmp	 $LN31@main
$LN8@main:

; 145  : 	}
; 146  : 	stat = atl_load(fp);

  00399	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR _fp$5257[ebp]
  0039f	52		 push	 edx
  003a0	e8 00 00 00 00	 call	 _atl_load
  003a5	83 c4 04	 add	 esp, 4
  003a8	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _stat$5255[ebp], eax

; 147  : 	V fclose(fp);

  003ae	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _fp$5257[ebp]
  003b4	50		 push	 eax
  003b5	e8 00 00 00 00	 call	 _fclose
  003ba	83 c4 04	 add	 esp, 4

; 148  : 	if (stat != ATL_SNORM) {

  003bd	83 bd f8 fe ff
	ff 00		 cmp	 DWORD PTR _stat$5255[ebp], 0
  003c4	74 1c		 je	 SHORT $LN7@main

; 149  :             V printf("\nError %d in include file %s\n", stat, include[i]);

  003c6	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  003c9	8b 54 8d a0	 mov	 edx, DWORD PTR _include$[ebp+ecx*4]
  003cd	52		 push	 edx
  003ce	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _stat$5255[ebp]
  003d4	50		 push	 eax
  003d5	68 00 00 00 00	 push	 OFFSET $SG5271
  003da	e8 00 00 00 00	 call	 _printf
  003df	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@main:

; 150  : 	}
; 151  :     }

  003e2	e9 12 ff ff ff	 jmp	 $LN11@main
$LN10@main:

; 152  : 
; 153  :     /* Now that all the preliminaries are out of the way, fall into
; 154  :        the main ATLAST execution loop. */
; 155  : 
; 156  : #ifndef HIGHC
; 157  :     V signal(SIGINT, ctrlc);

  003e7	68 00 00 00 00	 push	 OFFSET _ctrlc
  003ec	6a 02		 push	 2
  003ee	e8 00 00 00 00	 call	 _signal
  003f3	83 c4 08	 add	 esp, 8
$LN6@main:

; 158  : #endif /* HIGHC */
; 159  :     while (TRUE) {

  003f6	b9 01 00 00 00	 mov	 ecx, 1
  003fb	85 c9		 test	 ecx, ecx
  003fd	0f 84 b8 00 00
	00		 je	 $LN5@main

; 160  : 	char t[132];
; 161  : 
; 162  : 	if (!fname)

  00403	83 7d f8 00	 cmp	 DWORD PTR _fname$[ebp], 0
  00407	75 5a		 jne	 SHORT $LN4@main

; 163  :             V printf(atl_comment ? "(  " :  /* Show pending comment */
; 164  : 		/* Show compiling state */
; 165  :                 (((heap != NULL) && state) ? ":> " : "-> "));

  00409	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _atl_comment, 0
  00410	74 0c		 je	 SHORT $LN35@main
  00412	c7 85 e0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv232[ebp], OFFSET $SG5280
  0041c	eb 36		 jmp	 SHORT $LN36@main
$LN35@main:
  0041e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _atl__hb, 0
  00425	74 17		 je	 SHORT $LN33@main
  00427	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hb
  0042d	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00430	74 0c		 je	 SHORT $LN33@main
  00432	c7 85 dc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv230[ebp], OFFSET $SG5281
  0043c	eb 0a		 jmp	 SHORT $LN34@main
$LN33@main:
  0043e	c7 85 dc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv230[ebp], OFFSET $SG5282
$LN34@main:
  00448	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR tv230[ebp]
  0044e	89 85 e0 fd ff
	ff		 mov	 DWORD PTR tv232[ebp], eax
$LN36@main:
  00454	8b 8d e0 fd ff
	ff		 mov	 ecx, DWORD PTR tv232[ebp]
  0045a	51		 push	 ecx
  0045b	e8 00 00 00 00	 call	 _printf
  00460	83 c4 04	 add	 esp, 4
$LN4@main:

; 166  : 	if (fgets(t, 132, ifp) == NULL) {

  00463	8b 55 fc	 mov	 edx, DWORD PTR _ifp$[ebp]
  00466	52		 push	 edx
  00467	68 84 00 00 00	 push	 132			; 00000084H
  0046c	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR _t$5276[ebp]
  00472	50		 push	 eax
  00473	e8 00 00 00 00	 call	 _fgets
  00478	83 c4 0c	 add	 esp, 12			; 0000000cH
  0047b	85 c0		 test	 eax, eax
  0047d	75 28		 jne	 SHORT $LN3@main

; 167  : 	    if (fname && defmode) {

  0047f	83 7d f8 00	 cmp	 DWORD PTR _fname$[ebp], 0
  00483	74 20		 je	 SHORT $LN2@main
  00485	83 7d 98 00	 cmp	 DWORD PTR _defmode$[ebp], 0
  00489	74 1a		 je	 SHORT $LN2@main

; 168  : 		fname = defmode = FALSE;

  0048b	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _defmode$[ebp], 0
  00492	8b 4d 98	 mov	 ecx, DWORD PTR _defmode$[ebp]
  00495	89 4d f8	 mov	 DWORD PTR _fname$[ebp], ecx

; 169  : 		ifp = stdin;

  00498	e8 00 00 00 00	 call	 ___iob_func
  0049d	89 45 fc	 mov	 DWORD PTR _ifp$[ebp], eax

; 170  : 		continue;

  004a0	e9 51 ff ff ff	 jmp	 $LN6@main
$LN2@main:

; 171  : 	    }
; 172  : 	    break;

  004a5	eb 14		 jmp	 SHORT $LN5@main
$LN3@main:

; 173  : 	}
; 174  : 	V atl_eval(t);

  004a7	8d 95 e8 fd ff
	ff		 lea	 edx, DWORD PTR _t$5276[ebp]
  004ad	52		 push	 edx
  004ae	e8 00 00 00 00	 call	 _atl_eval
  004b3	83 c4 04	 add	 esp, 4

; 175  :     }

  004b6	e9 3b ff ff ff	 jmp	 $LN6@main
$LN5@main:

; 176  :     if (!fname)

  004bb	83 7d f8 00	 cmp	 DWORD PTR _fname$[ebp], 0
  004bf	75 0d		 jne	 SHORT $LN1@main

; 177  :         V printf("\n");

  004c1	68 00 00 00 00	 push	 OFFSET $SG5289
  004c6	e8 00 00 00 00	 call	 _printf
  004cb	83 c4 04	 add	 esp, 4
$LN1@main:

; 178  :     return 0;

  004ce	33 c0		 xor	 eax, eax
$LN31@main:

; 179  : }

  004d0	8b 4d 8c	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004d3	33 cd		 xor	 ecx, ebp
  004d5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004da	8b e5		 mov	 esp, ebp
  004dc	5d		 pop	 ebp
  004dd	c3		 ret	 0
  004de	8b ff		 npad	 2
$LN39@main:
  004e0	00 00 00 00	 DD	 $LN17@main
  004e4	00 00 00 00	 DD	 $LN23@main
  004e8	00 00 00 00	 DD	 $LN22@main
  004ec	00 00 00 00	 DD	 $LN21@main
  004f0	00 00 00 00	 DD	 $LN20@main
  004f4	00 00 00 00	 DD	 $LN19@main
  004f8	00 00 00 00	 DD	 $LN18@main
  004fc	00 00 00 00	 DD	 $LN24@main
$LN38@main:
  00500	00		 DB	 0
  00501	07		 DB	 7
  00502	07		 DB	 7
  00503	07		 DB	 7
  00504	07		 DB	 7
  00505	01		 DB	 1
  00506	07		 DB	 7
  00507	07		 DB	 7
  00508	07		 DB	 7
  00509	02		 DB	 2
  0050a	03		 DB	 3
  0050b	07		 DB	 7
  0050c	07		 DB	 7
  0050d	07		 DB	 7
  0050e	07		 DB	 7
  0050f	07		 DB	 7
  00510	07		 DB	 7
  00511	07		 DB	 7
  00512	07		 DB	 7
  00513	04		 DB	 4
  00514	05		 DB	 5
  00515	06		 DB	 6
  00516	00		 DB	 0
_main	ENDP
_TEXT	ENDS
EXTRN	_atl_break:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_sig$ = 8						; size = 4
_ctrlc	PROC

; 36   : {

  00520	55		 push	 ebp
  00521	8b ec		 mov	 ebp, esp

; 37   :     if (sig == SIGINT)

  00523	83 7d 08 02	 cmp	 DWORD PTR _sig$[ebp], 2
  00527	75 05		 jne	 SHORT $LN2@ctrlc

; 38   : 	atl_break();

  00529	e8 00 00 00 00	 call	 _atl_break
$LN2@ctrlc:

; 39   : }

  0052e	5d		 pop	 ebp
  0052f	c3		 ret	 0
_ctrlc	ENDP
_TEXT	ENDS
END
