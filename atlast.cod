; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\A15\facultate\forth\atlast-1.2\atlast.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_atl__Pcr
PUBLIC	_atl_memstat
PUBLIC	_opterr
PUBLIC	_optind
PUBLIC	_optopt
PUBLIC	_atl_stklen
PUBLIC	_atl_rstklen
PUBLIC	_atl_heaplen
PUBLIC	_atl_ltempstr
PUBLIC	_atl_ntempstr
PUBLIC	_atl_trace
PUBLIC	_atl_walkback
PUBLIC	_atl_comment
PUBLIC	_atl_redef
PUBLIC	_atl_errline
PUBLIC	_atl__sk
PUBLIC	_atl__rk
PUBLIC	_atl__hb
PUBLIC	_atl__dh
PUBLIC	_atl__dp
PUBLIC	_atl__ts
PUBLIC	_atl__tn
PUBLIC	_atl__ip
PUBLIC	_atl__cw
PUBLIC	_atl__wd
_BSS	SEGMENT
$SG82854 DB	01H DUP (?)
	ALIGN	4

$SG82853 DB	01H DUP (?)
	ALIGN	4

$SG82850 DB	01H DUP (?)
	ALIGN	4

$SG82849 DB	01H DUP (?)
	ALIGN	4

$SG82847 DB	01H DUP (?)
	ALIGN	4

$SG82845 DB	01H DUP (?)
	ALIGN	4

$SG82843 DB	01H DUP (?)
	ALIGN	4

$SG82841 DB	01H DUP (?)
	ALIGN	4

$SG81829 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_atl__sx:DWORD
COMM	_atl__sb:DWORD
COMM	___mingw_optreset:DWORD
COMM	_atl__hp:DWORD
COMM	_atl__ht:DWORD
COMM	_optarg:DWORD
COMM	_atl__hx:DWORD
COMM	_atl__hs:DWORD
COMM	_atl__rt:DWORD
COMM	_atl__rp:DWORD
COMM	_atl__rb:DWORD
COMM	_atl__st:DWORD
COMM	_atl__rx:DWORD
COMM	_atl__sp:DWORD
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	4

$SG82015 DB	01H DUP (?)
	ALIGN	4

$SG82022 DB	01H DUP (?)
	ALIGN	4

$SG82031 DB	01H DUP (?)
	ALIGN	4

$SG82041 DB	01H DUP (?)
	ALIGN	4

$SG82060 DB	01H DUP (?)
	ALIGN	4

$SG82065 DB	01H DUP (?)
	ALIGN	4

$SG82074 DB	01H DUP (?)
	ALIGN	4

$SG82079 DB	01H DUP (?)
	ALIGN	4

_atl_trace DD	01H DUP (?)
_atl_comment DD	01H DUP (?)
_atl_errline DD	01H DUP (?)
_atl__sk DD	01H DUP (?)
_atl__rk DD	01H DUP (?)
_atl__hb DD	01H DUP (?)
_atl__dh DD	01H DUP (?)
_atl__dp DD	01H DUP (?)
_atl__ts DD	01H DUP (?)
_atl__tn DD	01H DUP (?)
_wback	DD	01H DUP (?)
_instream DD	01H DUP (?)
_atl__ip DD	01H DUP (?)
_atl__cw DD	01H DUP (?)
_evalstat DD	01H DUP (?)
_defpend DD	01H DUP (?)
_forgetpend DD	01H DUP (?)
_tickpend DD	01H DUP (?)
_ctickpend DD	01H DUP (?)
_cbrackpend DD	01H DUP (?)
_atl__wd DD	01H DUP (?)
_stringlit DD	01H DUP (?)
_broken	DD	01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
_recargchar DB	'option requires an argument -- %c', 00H
	ORG $+2
_recargstring DB 'option requires an argument -- %s', 00H
	ORG $+2
_ambig	DB	'ambiguous option -- %.*s', 00H
	ORG $+3
_noarg	DB	'option doesn''t take an argument -- %.*s', 00H
_illoptchar DB	'unknown option -- %c', 00H
	ORG $+3
_illoptstring DB 'unknown option -- %s', 00H
CONST	ENDS
_DATA	SEGMENT
_opterr	DD	01H
_optind	DD	01H
_optopt	DD	03fH
_place	DD	FLAT:$SG81829
_nonopt_start DD 0ffffffffH
_nonopt_end DD	0ffffffffH
$SG81845 DB	'%s: ', 00H
	ORG $+3
$SG81850 DB	0aH, 00H
	ORG $+2
?posixly_correct@?1??getopt_internal@@9@9 DD 0ffffffffH	; `getopt_internal'::`2'::posixly_correct
$SG82002 DB	'POSIXLY_CORRECT', 00H
_atl_stklen DD	064H
_atl_rstklen DD	064H
_atl_heaplen DD	03e8H
_atl_ltempstr DD 0100H
_atl_ntempstr DD 04H
_atl_walkback DD 0ffffffffH
_atl_redef DD	0ffffffffH
$SG82842 DB	'r', 00H
	ORG $+2
$SG82844 DB	'r+', 00H
	ORG $+1
$SG82846 DB	'rb', 00H
	ORG $+1
$SG82848 DB	'r+b', 00H
$SG82851 DB	'w', 00H
	ORG $+2
$SG82852 DB	'w+', 00H
	ORG $+1
$SG82855 DB	'wb', 00H
	ORG $+1
$SG82856 DB	'w+b', 00H
_base	DD	0aH
_fopenmodes DD	FLAT:$SG82841
	DD	FLAT:$SG82842
	DD	FLAT:$SG82843
	DD	FLAT:$SG82844
	DD	FLAT:$SG82845
	DD	FLAT:$SG82846
	DD	FLAT:$SG82847
	DD	FLAT:$SG82848
	DD	FLAT:$SG82849
	DD	FLAT:$SG82850
	DD	FLAT:$SG82851
	DD	FLAT:$SG82852
	DD	FLAT:$SG82853
	DD	FLAT:$SG82854
	DD	FLAT:$SG82855
	DD	FLAT:$SG82856
$SG82899 DB	0aH, 0aH, 'Out of memory!  %u bytes requested.', 0aH, 00H
	ORG $+1
$SG82961 DB	0aH, 'Runaway string: %s', 0aH, 00H
	ORG $+3
$SG82964 DB	'\', 00H
	ORG $+2
$SG82969 DB	'(', 00H
	ORG $+2
$SG82984 DB	'%lf%c', 00H
	ORG $+2
?fmt@?1??atl_memstat@@9@9 DB '   %-12s %6ld    %6ld    %6ld       %3ld', 0aH
	DB	00H						; `atl_memstat'::`2'::fmt
	ORG $+2
$SG83019 DB	0aH, '             Memory Usage Summary', 0aH, 0aH, 00H
	ORG $+3
$SG83021 DB	'                 Current   Maximum    Items     Percent', 0aH
	DB	00H
	ORG $+3
$SG83023 DB	'  Memory Area     usage     used    allocated   in use ', 0aH
	DB	00H
	ORG $+3
$SG83027 DB	'Stack', 00H
	ORG $+2
$SG83031 DB	'Return stack', 00H
	ORG $+3
$SG83035 DB	'Heap', 00H
	ORG $+3
$SG83286 DB	'Subscript out of range', 00H
	ORG $+1
$SG83304 DB	'Bad array element size', 00H
	ORG $+1
$SG83306 DB	'Bad array subscript count', 00H
	ORG $+2
$SG83312 DB	'Bad array dimension', 00H
$SG83332 DB	'"%s" ', 00H
	ORG $+2
$SG83519 DB	'%g ', 00H
$SG83675 DB	'%.16f ', 00H
	ORG $+1
$SG83790 DB	'%lX', 00H
$SG83791 DB	'%ld ', 00H
	ORG $+3
$SG83801 DB	'%lX', 00H
$SG83802 DB	'%ld ', 00H
	ORG $+3
$SG83806 DB	0aH, 00H
	ORG $+2
$SG83811 DB	'Stack: ', 00H
$SG83814 DB	'Empty.', 00H
	ORG $+1
$SG83820 DB	'%lX', 00H
$SG83821 DB	'%ld ', 00H
	ORG $+3
$SG83835 DB	'%s', 00H
	ORG $+1
$SG83846 DB	'%s', 00H
	ORG $+1
$SG83856 DB	0aH, '%s', 00H
$SG83859 DB	0aH, 00H
	ORG $+2
$SG83884 DB	0aH, 'Not a file', 0aH, 00H
	ORG $+3
$SG83905 DB	0aH, 'Not a file', 0aH, 00H
	ORG $+3
$SG83911 DB	0aH, 'File not open', 0aH, 00H
$SG83940 DB	0aH, 'Not a file', 0aH, 00H
	ORG $+3
$SG83946 DB	0aH, 'File not open', 0aH, 00H
$SG83967 DB	0aH, 'Not a file', 0aH, 00H
	ORG $+3
$SG83973 DB	0aH, 'File not open', 0aH, 00H
$SG83995 DB	0aH, 'Not a file', 0aH, 00H
	ORG $+3
$SG84001 DB	0aH, 'File not open', 0aH, 00H
$SG84020 DB	0aH, 'Not a file', 0aH, 00H
	ORG $+3
$SG84026 DB	0aH, 'File not open', 0aH, 00H
$SG84041 DB	0aH, 'Not a file', 0aH, 00H
	ORG $+3
$SG84047 DB	0aH, 'File not open', 0aH, 00H
$SG84060 DB	0aH, 'Not a file', 0aH, 00H
	ORG $+3
$SG84066 DB	0aH, 'File not open', 0aH, 00H
$SG84080 DB	0aH, 'Not a file', 0aH, 00H
	ORG $+3
$SG84086 DB	0aH, 'File not open', 0aH, 00H
$SG84100 DB	0aH, 'Not a file', 0aH, 00H
	ORG $+3
$SG84106 DB	0aH, 'File not open', 0aH, 00H
$SG84124 DB	0aH, 'Not a file', 0aH, 00H
	ORG $+3
$SG84130 DB	0aH, 'File not open', 0aH, 00H
$SG84291 DB	'%ld ', 00H
	ORG $+3
$SG84562 DB	'%s', 00H
	ORG $+1
$SG84620 DB	' ''%s'' undefined ', 00H
	ORG $+3
$SG84623 DB	0aH, 'Word not specified when expected.', 0aH, 00H
$SG84629 DB	0aH, 'Word requested by ` not on same input line.', 0aH, 00H
	ORG $+2
$SG84677 DB	0aH, '>LINK Foulup--wnext is not at zero!', 0aH, 00H
	ORG $+2
$SG84696 DB	0aH, 'LINK> Foulup--wnext is not at zero!', 0aH, 00H
	ORG $+2
$SG84768 DB	0aH, '%s', 00H
$SG84770 DB	0aH, 00H
	ORG $+2
$SG84780 DB	0aH, '%s', 00H
$SG84782 DB	0aH, 00H
	ORG $+2
$SG84834 DB	'0+', 00H
	ORG $+1
$SG84835 DB	'0-', 00H
	ORG $+1
$SG84836 DB	'0*', 00H
	ORG $+1
$SG84837 DB	'0/', 00H
	ORG $+1
$SG84838 DB	'0MOD', 00H
	ORG $+3
$SG84839 DB	'0/MOD', 00H
	ORG $+2
$SG84840 DB	'0MIN', 00H
	ORG $+3
$SG84841 DB	'0MAX', 00H
	ORG $+3
$SG84842 DB	'0NEGATE', 00H
$SG84843 DB	'0ABS', 00H
	ORG $+3
$SG84844 DB	'0=', 00H
	ORG $+1
$SG84845 DB	'0<>', 00H
$SG84846 DB	'0>', 00H
	ORG $+1
$SG84847 DB	'0<', 00H
	ORG $+1
$SG84848 DB	'0>=', 00H
$SG84849 DB	'0<=', 00H
$SG84850 DB	'0AND', 00H
	ORG $+3
$SG84851 DB	'0OR', 00H
$SG84852 DB	'0XOR', 00H
	ORG $+3
$SG84853 DB	'0NOT', 00H
	ORG $+3
$SG84854 DB	'0SHIFT', 00H
	ORG $+1
$SG84855 DB	'0DEPTH', 00H
	ORG $+1
$SG84856 DB	'0CLEAR', 00H
	ORG $+1
$SG84857 DB	'0DUP', 00H
	ORG $+3
$SG84858 DB	'0DROP', 00H
	ORG $+2
$SG84859 DB	'0SWAP', 00H
	ORG $+2
$SG84860 DB	'0OVER', 00H
	ORG $+2
$SG84861 DB	'0PICK', 00H
	ORG $+2
$SG84862 DB	'0ROT', 00H
	ORG $+3
$SG84863 DB	'0-ROT', 00H
	ORG $+2
$SG84864 DB	'0ROLL', 00H
	ORG $+2
$SG84865 DB	'0>R', 00H
$SG84866 DB	'0R>', 00H
$SG84867 DB	'0R@', 00H
$SG84868 DB	'01+', 00H
$SG84869 DB	'02+', 00H
$SG84870 DB	'01-', 00H
$SG84871 DB	'02-', 00H
$SG84872 DB	'02*', 00H
$SG84873 DB	'02/', 00H
$SG84874 DB	'00=', 00H
$SG84875 DB	'00<>', 00H
	ORG $+3
$SG84876 DB	'00>', 00H
$SG84877 DB	'00<', 00H
$SG84878 DB	'02DUP', 00H
	ORG $+2
$SG84879 DB	'02DROP', 00H
	ORG $+1
$SG84880 DB	'02SWAP', 00H
	ORG $+1
$SG84881 DB	'02OVER', 00H
	ORG $+1
$SG84882 DB	'02ROT', 00H
	ORG $+2
$SG84883 DB	'02VARIABLE', 00H
	ORG $+1
$SG84884 DB	'02CONSTANT', 00H
	ORG $+1
$SG84885 DB	'02!', 00H
$SG84886 DB	'02@', 00H
$SG84887 DB	'0VARIABLE', 00H
	ORG $+2
$SG84888 DB	'0CONSTANT', 00H
	ORG $+2
$SG84889 DB	'0!', 00H
	ORG $+1
$SG84890 DB	'0@', 00H
	ORG $+1
$SG84891 DB	'0+!', 00H
$SG84892 DB	'0ALLOT', 00H
	ORG $+1
$SG84893 DB	'0,', 00H
	ORG $+1
$SG84894 DB	'0C!', 00H
$SG84895 DB	'0C@', 00H
$SG84896 DB	'0C,', 00H
$SG84897 DB	'0C=', 00H
$SG84898 DB	'0HERE', 00H
	ORG $+2
$SG84899 DB	'0ARRAY', 00H
	ORG $+1
$SG84900 DB	'0(STRLIT)', 00H
	ORG $+2
$SG84901 DB	'0STRING', 00H
$SG84902 DB	'0STRCPY', 00H
$SG84903 DB	'0S!', 00H
$SG84904 DB	'0STRCAT', 00H
$SG84905 DB	'0S+', 00H
$SG84906 DB	'0STRLEN', 00H
$SG84907 DB	'0STRCMP', 00H
$SG84908 DB	'0STRCHAR', 00H
	ORG $+3
$SG84909 DB	'0SUBSTR', 00H
$SG84910 DB	'0COMPARE', 00H
	ORG $+3
$SG84911 DB	'0STRFORM', 00H
	ORG $+3
$SG84912 DB	'0FSTRFORM', 00H
	ORG $+2
$SG84913 DB	'0STRINT', 00H
$SG84914 DB	'0STRREAL', 00H
	ORG $+3
$SG84915 DB	'0(FLIT)', 00H
$SG84916 DB	'0F+', 00H
$SG84917 DB	'0F-', 00H
$SG84918 DB	'0F*', 00H
$SG84919 DB	'0F/', 00H
$SG84920 DB	'0FMIN', 00H
	ORG $+2
$SG84921 DB	'0FMAX', 00H
	ORG $+2
$SG84922 DB	'0FNEGATE', 00H
	ORG $+3
$SG84923 DB	'0FABS', 00H
	ORG $+2
$SG84924 DB	'0F=', 00H
$SG84925 DB	'0F<>', 00H
	ORG $+3
$SG84926 DB	'0F>', 00H
$SG84927 DB	'0F<', 00H
$SG84928 DB	'0F>=', 00H
	ORG $+3
$SG84929 DB	'0F<=', 00H
	ORG $+3
$SG84930 DB	'0F.', 00H
$SG84931 DB	'0FLOAT', 00H
	ORG $+1
$SG84932 DB	'0FIX', 00H
	ORG $+3
$SG84933 DB	'0ACOS', 00H
	ORG $+2
$SG84934 DB	'0ASIN', 00H
	ORG $+2
$SG84935 DB	'0ATAN', 00H
	ORG $+2
$SG84936 DB	'0ATAN2', 00H
	ORG $+1
$SG84937 DB	'0COS', 00H
	ORG $+3
$SG84938 DB	'0EXP', 00H
	ORG $+3
$SG84939 DB	'0LOG', 00H
	ORG $+3
$SG84940 DB	'0POW', 00H
	ORG $+3
$SG84941 DB	'0SIN', 00H
	ORG $+3
$SG84942 DB	'0SQRT', 00H
	ORG $+2
$SG84943 DB	'0TAN', 00H
	ORG $+3
$SG84944 DB	'0(NEST)', 00H
$SG84945 DB	'0EXIT', 00H
	ORG $+2
$SG84946 DB	'0(LIT)', 00H
	ORG $+1
$SG84947 DB	'0BRANCH', 00H
$SG84948 DB	'0?BRANCH', 00H
	ORG $+3
$SG84949 DB	'1IF', 00H
$SG84950 DB	'1ELSE', 00H
	ORG $+2
$SG84951 DB	'1THEN', 00H
	ORG $+2
$SG84952 DB	'0?DUP', 00H
	ORG $+2
$SG84953 DB	'1BEGIN', 00H
	ORG $+1
$SG84954 DB	'1UNTIL', 00H
	ORG $+1
$SG84955 DB	'1AGAIN', 00H
	ORG $+1
$SG84956 DB	'1WHILE', 00H
	ORG $+1
$SG84957 DB	'1REPEAT', 00H
$SG84958 DB	'1DO', 00H
$SG84959 DB	'1?DO', 00H
	ORG $+3
$SG84960 DB	'1LOOP', 00H
	ORG $+2
$SG84961 DB	'1+LOOP', 00H
	ORG $+1
$SG84962 DB	'0(XDO)', 00H
	ORG $+1
$SG84963 DB	'0(X?DO)', 00H
$SG84964 DB	'0(XLOOP)', 00H
	ORG $+3
$SG84965 DB	'0(+XLOOP)', 00H
	ORG $+2
$SG84966 DB	'0LEAVE', 00H
	ORG $+1
$SG84967 DB	'0I', 00H
	ORG $+1
$SG84968 DB	'0J', 00H
	ORG $+1
$SG84969 DB	'0QUIT', 00H
	ORG $+2
$SG84970 DB	'0ABORT', 00H
	ORG $+1
$SG84971 DB	'1ABORT"', 00H
$SG84972 DB	'0SYSTEM', 00H
$SG84973 DB	'0TRACE', 00H
	ORG $+1
$SG84974 DB	'0WALKBACK', 00H
	ORG $+2
$SG84975 DB	'0WORDSUSED', 00H
	ORG $+1
$SG84976 DB	'0WORDSUNUSED', 00H
	ORG $+3
$SG84977 DB	'0MEMSTAT', 00H
	ORG $+3
$SG84978 DB	'0:', 00H
	ORG $+1
$SG84979 DB	'1;', 00H
	ORG $+1
$SG84980 DB	'0IMMEDIATE', 00H
	ORG $+1
$SG84981 DB	'1[', 00H
	ORG $+1
$SG84982 DB	'0]', 00H
	ORG $+1
$SG84983 DB	'0CREATE', 00H
$SG84984 DB	'0FORGET', 00H
$SG84985 DB	'0DOES>', 00H
	ORG $+1
$SG84986 DB	'0''', 00H
	ORG $+1
$SG84987 DB	'1['']', 00H
	ORG $+3
$SG84988 DB	'0EXECUTE', 00H
	ORG $+3
$SG84989 DB	'0>BODY', 00H
	ORG $+1
$SG84990 DB	'0STATE', 00H
	ORG $+1
$SG84991 DB	'0FIND', 00H
	ORG $+2
$SG84992 DB	'0>NAME', 00H
	ORG $+1
$SG84993 DB	'0>LINK', 00H
	ORG $+1
$SG84994 DB	'0BODY>', 00H
	ORG $+1
$SG84995 DB	'0NAME>', 00H
	ORG $+1
$SG84996 DB	'0LINK>', 00H
	ORG $+1
$SG84997 DB	'0N>LINK', 00H
$SG84998 DB	'0L>NAME', 00H
$SG84999 DB	'0NAME>S!', 00H
	ORG $+3
$SG85000 DB	'0S>NAME!', 00H
	ORG $+3
$SG85001 DB	'1[COMPILE]', 00H
	ORG $+1
$SG85002 DB	'1LITERAL', 00H
	ORG $+3
$SG85003 DB	'0COMPILE', 00H
	ORG $+3
$SG85004 DB	'0<MARK', 00H
	ORG $+1
$SG85005 DB	'0<RESOLVE', 00H
	ORG $+2
$SG85006 DB	'0>MARK', 00H
	ORG $+1
$SG85007 DB	'0>RESOLVE', 00H
	ORG $+2
$SG85008 DB	'0.', 00H
	ORG $+1
$SG85009 DB	'0?', 00H
	ORG $+1
$SG85010 DB	'0CR', 00H
$SG85011 DB	'0.S', 00H
$SG85012 DB	'1."', 00H
$SG85013 DB	'1.(', 00H
$SG85014 DB	'0TYPE', 00H
	ORG $+2
$SG85015 DB	'0WORDS', 00H
	ORG $+1
$SG85016 DB	'0FILE', 00H
	ORG $+2
$SG85017 DB	'0FOPEN', 00H
	ORG $+1
$SG85018 DB	'0FCLOSE', 00H
$SG85019 DB	'0FDELETE', 00H
	ORG $+3
$SG85020 DB	'0FGETS', 00H
	ORG $+1
$SG85021 DB	'0FPUTS', 00H
	ORG $+1
$SG85022 DB	'0FREAD', 00H
	ORG $+1
$SG85023 DB	'0FWRITE', 00H
$SG85024 DB	'0FGETC', 00H
	ORG $+1
$SG85025 DB	'0FPUTC', 00H
	ORG $+1
$SG85026 DB	'0FTELL', 00H
	ORG $+1
$SG85027 DB	'0FSEEK', 00H
	ORG $+1
$SG85028 DB	'0FLOAD', 00H
	ORG $+1
$SG85029 DB	'0EVALUATE', 00H
	ORG $+2
$SG85055 DB	'Walkback:', 0aH, 00H
	ORG $+1
_primt	DD	FLAT:$SG84834
	DD	FLAT:_P_plus
	DD	FLAT:$SG84835
	DD	FLAT:_P_minus
	DD	FLAT:$SG84836
	DD	FLAT:_P_times
	DD	FLAT:$SG84837
	DD	FLAT:_P_div
	DD	FLAT:$SG84838
	DD	FLAT:_P_mod
	DD	FLAT:$SG84839
	DD	FLAT:_P_divmod
	DD	FLAT:$SG84840
	DD	FLAT:_P_min
	DD	FLAT:$SG84841
	DD	FLAT:_P_max
	DD	FLAT:$SG84842
	DD	FLAT:_P_neg
	DD	FLAT:$SG84843
	DD	FLAT:_P_abs
	DD	FLAT:$SG84844
	DD	FLAT:_P_equal
	DD	FLAT:$SG84845
	DD	FLAT:_P_unequal
	DD	FLAT:$SG84846
	DD	FLAT:_P_gtr
	DD	FLAT:$SG84847
	DD	FLAT:_P_lss
	DD	FLAT:$SG84848
	DD	FLAT:_P_geq
	DD	FLAT:$SG84849
	DD	FLAT:_P_leq
	DD	FLAT:$SG84850
	DD	FLAT:_P_and
	DD	FLAT:$SG84851
	DD	FLAT:_P_or
	DD	FLAT:$SG84852
	DD	FLAT:_P_xor
	DD	FLAT:$SG84853
	DD	FLAT:_P_not
	DD	FLAT:$SG84854
	DD	FLAT:_P_shift
	DD	FLAT:$SG84855
	DD	FLAT:_P_depth
	DD	FLAT:$SG84856
	DD	FLAT:_P_clear
	DD	FLAT:$SG84857
	DD	FLAT:_P_dup
	DD	FLAT:$SG84858
	DD	FLAT:_P_drop
	DD	FLAT:$SG84859
	DD	FLAT:_P_swap
	DD	FLAT:$SG84860
	DD	FLAT:_P_over
	DD	FLAT:$SG84861
	DD	FLAT:_P_pick
	DD	FLAT:$SG84862
	DD	FLAT:_P_rot
	DD	FLAT:$SG84863
	DD	FLAT:_P_minusrot
	DD	FLAT:$SG84864
	DD	FLAT:_P_roll
	DD	FLAT:$SG84865
	DD	FLAT:_P_tor
	DD	FLAT:$SG84866
	DD	FLAT:_P_rfrom
	DD	FLAT:$SG84867
	DD	FLAT:_P_rfetch
	DD	FLAT:$SG84868
	DD	FLAT:_P_1plus
	DD	FLAT:$SG84869
	DD	FLAT:_P_2plus
	DD	FLAT:$SG84870
	DD	FLAT:_P_1minus
	DD	FLAT:$SG84871
	DD	FLAT:_P_2minus
	DD	FLAT:$SG84872
	DD	FLAT:_P_2times
	DD	FLAT:$SG84873
	DD	FLAT:_P_2div
	DD	FLAT:$SG84874
	DD	FLAT:_P_0equal
	DD	FLAT:$SG84875
	DD	FLAT:_P_0notequal
	DD	FLAT:$SG84876
	DD	FLAT:_P_0gtr
	DD	FLAT:$SG84877
	DD	FLAT:_P_0lss
	DD	FLAT:$SG84878
	DD	FLAT:_P_2dup
	DD	FLAT:$SG84879
	DD	FLAT:_P_2drop
	DD	FLAT:$SG84880
	DD	FLAT:_P_2swap
	DD	FLAT:$SG84881
	DD	FLAT:_P_2over
	DD	FLAT:$SG84882
	DD	FLAT:_P_2rot
	DD	FLAT:$SG84883
	DD	FLAT:_P_2variable
	DD	FLAT:$SG84884
	DD	FLAT:_P_2constant
	DD	FLAT:$SG84885
	DD	FLAT:_P_2bang
	DD	FLAT:$SG84886
	DD	FLAT:_P_2at
	DD	FLAT:$SG84887
	DD	FLAT:_P_variable
	DD	FLAT:$SG84888
	DD	FLAT:_P_constant
	DD	FLAT:$SG84889
	DD	FLAT:_P_bang
	DD	FLAT:$SG84890
	DD	FLAT:_P_at
	DD	FLAT:$SG84891
	DD	FLAT:_P_plusbang
	DD	FLAT:$SG84892
	DD	FLAT:_P_allot
	DD	FLAT:$SG84893
	DD	FLAT:_P_comma
	DD	FLAT:$SG84894
	DD	FLAT:_P_cbang
	DD	FLAT:$SG84895
	DD	FLAT:_P_cat
	DD	FLAT:$SG84896
	DD	FLAT:_P_ccomma
	DD	FLAT:$SG84897
	DD	FLAT:_P_cequal
	DD	FLAT:$SG84898
	DD	FLAT:_P_here
	DD	FLAT:$SG84899
	DD	FLAT:_P_array
	DD	FLAT:$SG84900
	DD	FLAT:_P_strlit
	DD	FLAT:$SG84901
	DD	FLAT:_P_string
	DD	FLAT:$SG84902
	DD	FLAT:_P_strcpy
	DD	FLAT:$SG84903
	DD	FLAT:_P_strcpy
	DD	FLAT:$SG84904
	DD	FLAT:_P_strcat
	DD	FLAT:$SG84905
	DD	FLAT:_P_strcat
	DD	FLAT:$SG84906
	DD	FLAT:_P_strlen
	DD	FLAT:$SG84907
	DD	FLAT:_P_strcmp
	DD	FLAT:$SG84908
	DD	FLAT:_P_strchar
	DD	FLAT:$SG84909
	DD	FLAT:_P_substr
	DD	FLAT:$SG84910
	DD	FLAT:_P_strcmp
	DD	FLAT:$SG84911
	DD	FLAT:_P_strform
	DD	FLAT:$SG84912
	DD	FLAT:_P_fstrform
	DD	FLAT:$SG84913
	DD	FLAT:_P_strint
	DD	FLAT:$SG84914
	DD	FLAT:_P_strreal
	DD	FLAT:$SG84915
	DD	FLAT:_P_flit
	DD	FLAT:$SG84916
	DD	FLAT:_P_fplus
	DD	FLAT:$SG84917
	DD	FLAT:_P_fminus
	DD	FLAT:$SG84918
	DD	FLAT:_P_ftimes
	DD	FLAT:$SG84919
	DD	FLAT:_P_fdiv
	DD	FLAT:$SG84920
	DD	FLAT:_P_fmin
	DD	FLAT:$SG84921
	DD	FLAT:_P_fmax
	DD	FLAT:$SG84922
	DD	FLAT:_P_fneg
	DD	FLAT:$SG84923
	DD	FLAT:_P_fabs
	DD	FLAT:$SG84924
	DD	FLAT:_P_fequal
	DD	FLAT:$SG84925
	DD	FLAT:_P_funequal
	DD	FLAT:$SG84926
	DD	FLAT:_P_fgtr
	DD	FLAT:$SG84927
	DD	FLAT:_P_flss
	DD	FLAT:$SG84928
	DD	FLAT:_P_fgeq
	DD	FLAT:$SG84929
	DD	FLAT:_P_fleq
	DD	FLAT:$SG84930
	DD	FLAT:_P_fdot
	DD	FLAT:$SG84931
	DD	FLAT:_P_float
	DD	FLAT:$SG84932
	DD	FLAT:_P_fix
	DD	FLAT:$SG84933
	DD	FLAT:_P_acos
	DD	FLAT:$SG84934
	DD	FLAT:_P_asin
	DD	FLAT:$SG84935
	DD	FLAT:_P_atan
	DD	FLAT:$SG84936
	DD	FLAT:_P_atan2
	DD	FLAT:$SG84937
	DD	FLAT:_P_cos
	DD	FLAT:$SG84938
	DD	FLAT:_P_exp
	DD	FLAT:$SG84939
	DD	FLAT:_P_log
	DD	FLAT:$SG84940
	DD	FLAT:_P_pow
	DD	FLAT:$SG84941
	DD	FLAT:_P_sin
	DD	FLAT:$SG84942
	DD	FLAT:_P_sqrt
	DD	FLAT:$SG84943
	DD	FLAT:_P_tan
	DD	FLAT:$SG84944
	DD	FLAT:_P_nest
	DD	FLAT:$SG84945
	DD	FLAT:_P_exit
	DD	FLAT:$SG84946
	DD	FLAT:_P_dolit
	DD	FLAT:$SG84947
	DD	FLAT:_P_branch
	DD	FLAT:$SG84948
	DD	FLAT:_P_qbranch
	DD	FLAT:$SG84949
	DD	FLAT:_P_if
	DD	FLAT:$SG84950
	DD	FLAT:_P_else
	DD	FLAT:$SG84951
	DD	FLAT:_P_then
	DD	FLAT:$SG84952
	DD	FLAT:_P_qdup
	DD	FLAT:$SG84953
	DD	FLAT:_P_begin
	DD	FLAT:$SG84954
	DD	FLAT:_P_until
	DD	FLAT:$SG84955
	DD	FLAT:_P_again
	DD	FLAT:$SG84956
	DD	FLAT:_P_while
	DD	FLAT:$SG84957
	DD	FLAT:_P_repeat
	DD	FLAT:$SG84958
	DD	FLAT:_P_do
	DD	FLAT:$SG84959
	DD	FLAT:_P_qdo
	DD	FLAT:$SG84960
	DD	FLAT:_P_loop
	DD	FLAT:$SG84961
	DD	FLAT:_P_ploop
	DD	FLAT:$SG84962
	DD	FLAT:_P_xdo
	DD	FLAT:$SG84963
	DD	FLAT:_P_xqdo
	DD	FLAT:$SG84964
	DD	FLAT:_P_xloop
	DD	FLAT:$SG84965
	DD	FLAT:_P_xploop
	DD	FLAT:$SG84966
	DD	FLAT:_P_leave
	DD	FLAT:$SG84967
	DD	FLAT:_P_i
	DD	FLAT:$SG84968
	DD	FLAT:_P_j
	DD	FLAT:$SG84969
	DD	FLAT:_P_quit
	DD	FLAT:$SG84970
	DD	FLAT:_P_abort
	DD	FLAT:$SG84971
	DD	FLAT:_P_abortq
	DD	FLAT:$SG84972
	DD	FLAT:_P_system
	DD	FLAT:$SG84973
	DD	FLAT:_P_trace
	DD	FLAT:$SG84974
	DD	FLAT:_P_walkback
	DD	FLAT:$SG84975
	DD	FLAT:_P_wordsused
	DD	FLAT:$SG84976
	DD	FLAT:_P_wordsunused
	DD	FLAT:$SG84977
	DD	FLAT:_atl_memstat
	DD	FLAT:$SG84978
	DD	FLAT:_P_colon
	DD	FLAT:$SG84979
	DD	FLAT:_P_semicolon
	DD	FLAT:$SG84980
	DD	FLAT:_P_immediate
	DD	FLAT:$SG84981
	DD	FLAT:_P_lbrack
	DD	FLAT:$SG84982
	DD	FLAT:_P_rbrack
	DD	FLAT:$SG84983
	DD	FLAT:_atl__Pcr
	DD	FLAT:$SG84984
	DD	FLAT:_P_forget
	DD	FLAT:$SG84985
	DD	FLAT:_P_does
	DD	FLAT:$SG84986
	DD	FLAT:_P_tick
	DD	FLAT:$SG84987
	DD	FLAT:_P_bracktick
	DD	FLAT:$SG84988
	DD	FLAT:_P_execute
	DD	FLAT:$SG84989
	DD	FLAT:_P_body
	DD	FLAT:$SG84990
	DD	FLAT:_P_state
	DD	FLAT:$SG84991
	DD	FLAT:_P_find
	DD	FLAT:$SG84992
	DD	FLAT:_P_toname
	DD	FLAT:$SG84993
	DD	FLAT:_P_tolink
	DD	FLAT:$SG84994
	DD	FLAT:_P_frombody
	DD	FLAT:$SG84995
	DD	FLAT:_P_fromname
	DD	FLAT:$SG84996
	DD	FLAT:_P_fromlink
	DD	FLAT:$SG84997
	DD	FLAT:_P_nametolink
	DD	FLAT:$SG84998
	DD	FLAT:_P_linktoname
	DD	FLAT:$SG84999
	DD	FLAT:_P_fetchname
	DD	FLAT:$SG85000
	DD	FLAT:_P_storename
	DD	FLAT:$SG85001
	DD	FLAT:_P_brackcompile
	DD	FLAT:$SG85002
	DD	FLAT:_P_literal
	DD	FLAT:$SG85003
	DD	FLAT:_P_compile
	DD	FLAT:$SG85004
	DD	FLAT:_P_backmark
	DD	FLAT:$SG85005
	DD	FLAT:_P_backresolve
	DD	FLAT:$SG85006
	DD	FLAT:_P_fwdmark
	DD	FLAT:$SG85007
	DD	FLAT:_P_fwdresolve
	DD	FLAT:$SG85008
	DD	FLAT:_P_dot
	DD	FLAT:$SG85009
	DD	FLAT:_P_question
	DD	FLAT:$SG85010
	DD	FLAT:_P_cr
	DD	FLAT:$SG85011
	DD	FLAT:_P_dots
	DD	FLAT:$SG85012
	DD	FLAT:_P_dotquote
	DD	FLAT:$SG85013
	DD	FLAT:_P_dotparen
	DD	FLAT:$SG85014
	DD	FLAT:_P_type
	DD	FLAT:$SG85015
	DD	FLAT:_P_words
	DD	FLAT:$SG85016
	DD	FLAT:_P_file
	DD	FLAT:$SG85017
	DD	FLAT:_P_fopen
	DD	FLAT:$SG85018
	DD	FLAT:_P_fclose
	DD	FLAT:$SG85019
	DD	FLAT:_P_fdelete
	DD	FLAT:$SG85020
	DD	FLAT:_P_fgetline
	DD	FLAT:$SG85021
	DD	FLAT:_P_fputline
	DD	FLAT:$SG85022
	DD	FLAT:_P_fread
	DD	FLAT:$SG85023
	DD	FLAT:_P_fwrite
	DD	FLAT:$SG85024
	DD	FLAT:_P_fgetc
	DD	FLAT:$SG85025
	DD	FLAT:_P_fputc
	DD	FLAT:$SG85026
	DD	FLAT:_P_ftell
	DD	FLAT:$SG85027
	DD	FLAT:_P_fseek
	DD	FLAT:$SG85028
	DD	FLAT:_P_fload
	DD	FLAT:$SG85029
	DD	FLAT:_P_evaluate
	DD	00H
	DD	00H
$SG85059 DB	'   %s', 0aH, 00H
	ORG $+1
$SG85065 DB	'   %s', 0aH, 00H
	ORG $+1
$SG85070 DB	0aH, '%s.', 0aH, 00H
	ORG $+2
$SG85075 DB	'Stack overflow', 00H
	ORG $+1
$SG85077 DB	'Stack underflow', 00H
$SG85079 DB	'Return stack overflow', 00H
	ORG $+2
$SG85081 DB	'Return stack underflow', 00H
	ORG $+1
$SG85083 DB	'Heap overflow', 00H
	ORG $+2
$SG85085 DB	'Bad pointer', 00H
$SG85087 DB	'Compiler word outside definition', 00H
	ORG $+3
$SG85089 DB	'Divide by zero', 00H
	ORG $+1
$SG85095 DB	0aH, 'Trace: %s ', 00H
$SG85101 DB	'Break signal', 00H
	ORG $+3
$SG85104 DB	0aH, 'Trace: %s ', 00H
$SG85110 DB	'EXIT', 00H
	ORG $+3
$SG85113 DB	'(LIT)', 00H
	ORG $+2
$SG85116 DB	'(FLIT)', 00H
	ORG $+1
$SG85119 DB	'(STRLIT)', 00H
	ORG $+3
$SG85122 DB	'.(', 00H
	ORG $+1
$SG85125 DB	'?BRANCH', 00H
$SG85128 DB	'BRANCH', 00H
	ORG $+1
$SG85131 DB	'(XDO)', 00H
	ORG $+2
$SG85134 DB	'(X?DO)', 00H
	ORG $+1
$SG85137 DB	'(XLOOP)', 00H
$SG85140 DB	'(+XLOOP)', 00H
	ORG $+3
$SG85143 DB	'ABORT"', 00H
	ORG $+1
$SG85183 DB	'STDIN', 00H
	ORG $+2
$SG85185 DB	'STDOUT', 00H
	ORG $+1
$SG85187 DB	'STDERR', 00H
	ORG $+1
?stdfiles@?8??atl_init@@9@9 DD FLAT:$SG85183		; `atl_init'::`9'::stdfiles
	DD	00H
	DD	FLAT:$SG85185
	DD	00H
	DD	FLAT:$SG85187
	DD	00H
$SG85282 DB	0aH, 'Runaway `('' comment.', 0aH, 00H
	ORG $+1
$SG85292 DB	'STACK ', 00H
	ORG $+1
$SG85293 DB	'RSTACK ', 00H
$SG85294 DB	'HEAP ', 00H
	ORG $+2
$SG85295 DB	'TEMPSTRL ', 00H
	ORG $+2
$SG85296 DB	'TEMPSTRN ', 00H
	ORG $+2
?proname@?1??atl_prologue@@9@9 DD FLAT:$SG85292		; `atl_prologue'::`2'::proname
	DD	FLAT:_atl_stklen
	DD	FLAT:$SG85293
	DD	FLAT:_atl_rstklen
	DD	FLAT:$SG85294
	DD	FLAT:_atl_heaplen
	DD	FLAT:$SG85295
	DD	FLAT:_atl_ltempstr
	DD	FLAT:$SG85296
	DD	FLAT:_atl_ntempstr
$SG85298 DB	'\ *', 00H
$SG85309 DB	'%li', 00H
$SG85336 DB	0aH, 'Forget protected.', 0aH, 00H
$SG85351 DB	' ''%s'' undefined ', 00H
	ORG $+3
$SG85361 DB	' ''%s'' undefined ', 00H
	ORG $+3
$SG85367 DB	0aH, '%s isn''t unique.', 00H
	ORG $+2
$SG85382 DB	' ''%s'' undefined ', 00H
	ORG $+3
$SG85446 DB	'%s', 00H
	ORG $+1
$SG85465 DB	0aH, 'Unknown token type %d', 0aH, 00H
_DATA	ENDS
PUBLIC	_getopt
; Function compile flags: /Odtp
; File c:\a15\facultate\forth\atlast-1.2\getopt.h
_TEXT	SEGMENT
_nargc$ = 8						; size = 4
_nargv$ = 12						; size = 4
_options$ = 16						; size = 4
_getopt	PROC

; 222  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 223  : 
; 224  : 	/*
; 225  : 	 * We don't pass FLAG_PERMUTE to getopt_internal() since
; 226  : 	 * the BSD getopt(3) (unlike GNU) has never done this.
; 227  : 	 *
; 228  : 	 * Furthermore, since many privileged programs call getopt()
; 229  : 	 * before dropping privileges it makes sense to keep things
; 230  : 	 * as simple (and bug-free) as possible.
; 231  : 	 */
; 232  : 	return (getopt_internal(nargc, nargv, options, NULL, NULL, 0));

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	6a 00		 push	 0
  00009	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR _nargv$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR _nargc$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _getopt_internal
  0001a	83 c4 18	 add	 esp, 24			; 00000018H

; 233  : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
_getopt	ENDP
_TEXT	ENDS
EXTRN	_strchr:PROC
EXTRN	_getenv:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_short_too$ = -12					; size = 4
_oli$ = -8						; size = 4
_optchar$ = -4						; size = 4
_nargc$ = 8						; size = 4
_nargv$ = 12						; size = 4
_options$ = 16						; size = 4
_long_options$ = 20					; size = 4
_idx$ = 24						; size = 4
_flags$ = 28						; size = 4
_getopt_internal PROC

; 420  : {

  00020	55		 push	 ebp
  00021	8b ec		 mov	 ebp, esp
  00023	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 421  : 	char *oli;				/* option letter list index */
; 422  : 	int optchar, short_too;
; 423  : 	static int posixly_correct = -1;
; 424  : 
; 425  : 	if (options == NULL)

  00026	83 7d 10 00	 cmp	 DWORD PTR _options$[ebp], 0
  0002a	75 08		 jne	 SHORT $LN54@getopt_int

; 426  : 		return (-1);

  0002c	83 c8 ff	 or	 eax, -1
  0002f	e9 aa 06 00 00	 jmp	 $LN55@getopt_int
$LN54@getopt_int:

; 427  : 
; 428  : 	/*
; 429  : 	 * XXX Some GNU programs (like cvs) set optind to 0 instead of
; 430  : 	 * XXX using optreset.  Work around this braindamage.
; 431  : 	 */
; 432  : 	if (optind == 0)

  00034	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _optind, 0
  0003b	75 14		 jne	 SHORT $LN53@getopt_int

; 433  : 		optind = optreset = 1;

  0003d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ___mingw_optreset, 1
  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR ___mingw_optreset
  0004c	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax
$LN53@getopt_int:

; 434  : 
; 435  : 	/*
; 436  : 	 * Disable GNU extensions if POSIXLY_CORRECT is set or options
; 437  : 	 * string begins with a '+'.
; 438  : 	 *
; 439  : 	 * CV, 2009-12-14: Check POSIXLY_CORRECT anew if optind == 0 or
; 440  : 	 *                 optreset != 0 for GNU compatibility.
; 441  : 	 */
; 442  : 	if (posixly_correct == -1 || optreset != 0)

  00051	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?posixly_correct@?1??getopt_internal@@9@9, -1
  00058	74 09		 je	 SHORT $LN51@getopt_int
  0005a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ___mingw_optreset, 0
  00061	74 18		 je	 SHORT $LN52@getopt_int
$LN51@getopt_int:

; 443  : 		posixly_correct = (getenv("POSIXLY_CORRECT") != NULL);

  00063	68 00 00 00 00	 push	 OFFSET $SG82002
  00068	e8 00 00 00 00	 call	 _getenv
  0006d	83 c4 04	 add	 esp, 4
  00070	f7 d8		 neg	 eax
  00072	1b c0		 sbb	 eax, eax
  00074	f7 d8		 neg	 eax
  00076	a3 00 00 00 00	 mov	 DWORD PTR ?posixly_correct@?1??getopt_internal@@9@9, eax
$LN52@getopt_int:

; 444  : 	if (*options == '-')

  0007b	8b 4d 10	 mov	 ecx, DWORD PTR _options$[ebp]
  0007e	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00081	83 fa 2d	 cmp	 edx, 45			; 0000002dH
  00084	75 0b		 jne	 SHORT $LN50@getopt_int

; 445  : 		flags |= FLAG_ALLARGS;

  00086	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  00089	83 c8 02	 or	 eax, 2
  0008c	89 45 1c	 mov	 DWORD PTR _flags$[ebp], eax
  0008f	eb 1d		 jmp	 SHORT $LN49@getopt_int
$LN50@getopt_int:

; 446  : 	else if (posixly_correct || *options == '+')

  00091	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?posixly_correct@?1??getopt_internal@@9@9, 0
  00098	75 0b		 jne	 SHORT $LN47@getopt_int
  0009a	8b 4d 10	 mov	 ecx, DWORD PTR _options$[ebp]
  0009d	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000a0	83 fa 2b	 cmp	 edx, 43			; 0000002bH
  000a3	75 09		 jne	 SHORT $LN49@getopt_int
$LN47@getopt_int:

; 447  : 		flags &= ~FLAG_PERMUTE;

  000a5	8b 45 1c	 mov	 eax, DWORD PTR _flags$[ebp]
  000a8	83 e0 fe	 and	 eax, -2			; fffffffeH
  000ab	89 45 1c	 mov	 DWORD PTR _flags$[ebp], eax
$LN49@getopt_int:

; 448  : 	if (*options == '+' || *options == '-')

  000ae	8b 4d 10	 mov	 ecx, DWORD PTR _options$[ebp]
  000b1	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000b4	83 fa 2b	 cmp	 edx, 43			; 0000002bH
  000b7	74 0b		 je	 SHORT $LN45@getopt_int
  000b9	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  000bc	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000bf	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  000c2	75 09		 jne	 SHORT $LN46@getopt_int
$LN45@getopt_int:

; 449  : 		options++;

  000c4	8b 55 10	 mov	 edx, DWORD PTR _options$[ebp]
  000c7	83 c2 01	 add	 edx, 1
  000ca	89 55 10	 mov	 DWORD PTR _options$[ebp], edx
$LN46@getopt_int:

; 450  : 
; 451  : 	optarg = NULL;

  000cd	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _optarg, 0

; 452  : 	if (optreset)

  000d7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ___mingw_optreset, 0
  000de	74 14		 je	 SHORT $start$82011

; 453  : 		nonopt_start = nonopt_end = -1;

  000e0	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _nonopt_end, -1
  000ea	a1 00 00 00 00	 mov	 eax, DWORD PTR _nonopt_end
  000ef	a3 00 00 00 00	 mov	 DWORD PTR _nonopt_start, eax
$start$82011:

; 454  : start:
; 455  : 	if (optreset || !*place) {		/* update scanning pointer */

  000f4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ___mingw_optreset, 0
  000fb	75 11		 jne	 SHORT $LN42@getopt_int
  000fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _place
  00103	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00106	85 d2		 test	 edx, edx
  00108	0f 85 73 02 00
	00		 jne	 $LN43@getopt_int
$LN42@getopt_int:

; 456  : 		optreset = 0;

  0010e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ___mingw_optreset, 0

; 457  : 		if (optind >= nargc) {          /* end of argument vector */

  00118	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  0011d	3b 45 08	 cmp	 eax, DWORD PTR _nargc$[ebp]
  00120	0f 8c 80 00 00
	00		 jl	 $LN41@getopt_int

; 458  : 			place = EMSG;

  00126	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _place, OFFSET $SG82015

; 459  : 			if (nonopt_end != -1) {

  00130	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _nonopt_end, -1
  00137	74 3a		 je	 SHORT $LN40@getopt_int

; 460  : 				/* do permutation, if we have to */
; 461  : 				permute_args(nonopt_start, nonopt_end,
; 462  : 				    optind, nargv);

  00139	8b 4d 0c	 mov	 ecx, DWORD PTR _nargv$[ebp]
  0013c	51		 push	 ecx
  0013d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _optind
  00143	52		 push	 edx
  00144	a1 00 00 00 00	 mov	 eax, DWORD PTR _nonopt_end
  00149	50		 push	 eax
  0014a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nonopt_start
  00150	51		 push	 ecx
  00151	e8 00 00 00 00	 call	 _permute_args
  00156	83 c4 10	 add	 esp, 16			; 00000010H

; 463  : 				optind -= nonopt_end - nonopt_start;

  00159	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _nonopt_end
  0015f	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _nonopt_start
  00165	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  0016a	2b c2		 sub	 eax, edx
  0016c	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax
  00171	eb 15		 jmp	 SHORT $LN39@getopt_int
$LN40@getopt_int:

; 464  : 			}
; 465  : 			else if (nonopt_start != -1) {

  00173	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _nonopt_start, -1
  0017a	74 0c		 je	 SHORT $LN39@getopt_int

; 466  : 				/*
; 467  : 				 * If we skipped non-options, set optind
; 468  : 				 * to the first of them.
; 469  : 				 */
; 470  : 				optind = nonopt_start;

  0017c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nonopt_start
  00182	89 0d 00 00 00
	00		 mov	 DWORD PTR _optind, ecx
$LN39@getopt_int:

; 471  : 			}
; 472  : 			nonopt_start = nonopt_end = -1;

  00188	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _nonopt_end, -1
  00192	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _nonopt_end
  00198	89 15 00 00 00
	00		 mov	 DWORD PTR _nonopt_start, edx

; 473  : 			return (-1);

  0019e	83 c8 ff	 or	 eax, -1
  001a1	e9 38 05 00 00	 jmp	 $LN55@getopt_int
$LN41@getopt_int:

; 474  : 		}
; 475  : 		if (*(place = nargv[optind]) != '-' ||
; 476  : 		    (place[1] == '\0' && strchr(options, '-') == NULL)) {

  001a6	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  001ab	8b 4d 0c	 mov	 ecx, DWORD PTR _nargv$[ebp]
  001ae	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  001b1	89 15 00 00 00
	00		 mov	 DWORD PTR _place, edx
  001b7	a1 00 00 00 00	 mov	 eax, DWORD PTR _place
  001bc	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001bf	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  001c2	75 28		 jne	 SHORT $LN36@getopt_int
  001c4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _place
  001ca	0f be 42 01	 movsx	 eax, BYTE PTR [edx+1]
  001ce	85 c0		 test	 eax, eax
  001d0	0f 85 d6 00 00
	00		 jne	 $LN37@getopt_int
  001d6	6a 2d		 push	 45			; 0000002dH
  001d8	8b 4d 10	 mov	 ecx, DWORD PTR _options$[ebp]
  001db	51		 push	 ecx
  001dc	e8 00 00 00 00	 call	 _strchr
  001e1	83 c4 08	 add	 esp, 8
  001e4	85 c0		 test	 eax, eax
  001e6	0f 85 c0 00 00
	00		 jne	 $LN37@getopt_int
$LN36@getopt_int:

; 477  : 			place = EMSG;		/* found non-option */

  001ec	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _place, OFFSET $SG82022

; 478  : 			if (flags & FLAG_ALLARGS) {

  001f6	8b 55 1c	 mov	 edx, DWORD PTR _flags$[ebp]
  001f9	83 e2 02	 and	 edx, 2
  001fc	74 28		 je	 SHORT $LN35@getopt_int

; 479  : 				/*
; 480  : 				 * GNU extension:
; 481  : 				 * return non-option as argument to option 1
; 482  : 				 */
; 483  : 				optarg = nargv[optind++];

  001fe	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  00203	8b 4d 0c	 mov	 ecx, DWORD PTR _nargv$[ebp]
  00206	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00209	89 15 00 00 00
	00		 mov	 DWORD PTR _optarg, edx
  0020f	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  00214	83 c0 01	 add	 eax, 1
  00217	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax

; 484  : 				return (INORDER);

  0021c	b8 01 00 00 00	 mov	 eax, 1
  00221	e9 b8 04 00 00	 jmp	 $LN55@getopt_int
$LN35@getopt_int:

; 485  : 			}
; 486  : 			if (!(flags & FLAG_PERMUTE)) {

  00226	8b 4d 1c	 mov	 ecx, DWORD PTR _flags$[ebp]
  00229	83 e1 01	 and	 ecx, 1
  0022c	75 08		 jne	 SHORT $LN34@getopt_int

; 487  : 				/*
; 488  : 				 * If no permutation wanted, stop parsing
; 489  : 				 * at first non-option.
; 490  : 				 */
; 491  : 				return (-1);

  0022e	83 c8 ff	 or	 eax, -1
  00231	e9 a8 04 00 00	 jmp	 $LN55@getopt_int
$LN34@getopt_int:

; 492  : 			}
; 493  : 			/* do permutation */
; 494  : 			if (nonopt_start == -1)

  00236	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _nonopt_start, -1
  0023d	75 0e		 jne	 SHORT $LN33@getopt_int

; 495  : 				nonopt_start = optind;

  0023f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _optind
  00245	89 15 00 00 00
	00		 mov	 DWORD PTR _nonopt_start, edx
  0024b	eb 4d		 jmp	 SHORT $LN32@getopt_int
$LN33@getopt_int:

; 496  : 			else if (nonopt_end != -1) {

  0024d	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _nonopt_end, -1
  00254	74 44		 je	 SHORT $LN32@getopt_int

; 497  : 				permute_args(nonopt_start, nonopt_end,
; 498  : 				    optind, nargv);

  00256	8b 45 0c	 mov	 eax, DWORD PTR _nargv$[ebp]
  00259	50		 push	 eax
  0025a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _optind
  00260	51		 push	 ecx
  00261	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _nonopt_end
  00267	52		 push	 edx
  00268	a1 00 00 00 00	 mov	 eax, DWORD PTR _nonopt_start
  0026d	50		 push	 eax
  0026e	e8 00 00 00 00	 call	 _permute_args
  00273	83 c4 10	 add	 esp, 16			; 00000010H

; 499  : 				nonopt_start = optind -
; 500  : 				    (nonopt_end - nonopt_start);

  00276	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nonopt_end
  0027c	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _nonopt_start
  00282	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _optind
  00288	2b d1		 sub	 edx, ecx
  0028a	89 15 00 00 00
	00		 mov	 DWORD PTR _nonopt_start, edx

; 501  : 				nonopt_end = -1;

  00290	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _nonopt_end, -1
$LN32@getopt_int:

; 502  : 			}
; 503  : 			optind++;

  0029a	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  0029f	83 c0 01	 add	 eax, 1
  002a2	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax

; 504  : 			/* process next argument */
; 505  : 			goto start;

  002a7	e9 48 fe ff ff	 jmp	 $start$82011
$LN37@getopt_int:

; 506  : 		}
; 507  : 		if (nonopt_start != -1 && nonopt_end == -1)

  002ac	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _nonopt_start, -1
  002b3	74 15		 je	 SHORT $LN30@getopt_int
  002b5	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _nonopt_end, -1
  002bc	75 0c		 jne	 SHORT $LN30@getopt_int

; 508  : 			nonopt_end = optind;

  002be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _optind
  002c4	89 0d 00 00 00
	00		 mov	 DWORD PTR _nonopt_end, ecx
$LN30@getopt_int:

; 509  : 
; 510  : 		/*
; 511  : 		 * If we have "-" do nothing, if "--" we are done.
; 512  : 		 */
; 513  : 		if (place[1] != '\0' && *++place == '-' && place[1] == '\0') {

  002ca	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _place
  002d0	0f be 42 01	 movsx	 eax, BYTE PTR [edx+1]
  002d4	85 c0		 test	 eax, eax
  002d6	0f 84 a5 00 00
	00		 je	 $LN43@getopt_int
  002dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _place
  002e2	83 c1 01	 add	 ecx, 1
  002e5	89 0d 00 00 00
	00		 mov	 DWORD PTR _place, ecx
  002eb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _place
  002f1	0f be 02	 movsx	 eax, BYTE PTR [edx]
  002f4	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  002f7	0f 85 84 00 00
	00		 jne	 $LN43@getopt_int
  002fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _place
  00303	0f be 51 01	 movsx	 edx, BYTE PTR [ecx+1]
  00307	85 d2		 test	 edx, edx
  00309	75 76		 jne	 SHORT $LN43@getopt_int

; 514  : 			optind++;

  0030b	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  00310	83 c0 01	 add	 eax, 1
  00313	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax

; 515  : 			place = EMSG;

  00318	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _place, OFFSET $SG82031

; 516  : 			/*
; 517  : 			 * We found an option (--), so if we skipped
; 518  : 			 * non-options, we have to permute.
; 519  : 			 */
; 520  : 			if (nonopt_end != -1) {

  00322	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _nonopt_end, -1
  00329	74 38		 je	 SHORT $LN28@getopt_int

; 521  : 				permute_args(nonopt_start, nonopt_end,
; 522  : 				    optind, nargv);

  0032b	8b 4d 0c	 mov	 ecx, DWORD PTR _nargv$[ebp]
  0032e	51		 push	 ecx
  0032f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _optind
  00335	52		 push	 edx
  00336	a1 00 00 00 00	 mov	 eax, DWORD PTR _nonopt_end
  0033b	50		 push	 eax
  0033c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nonopt_start
  00342	51		 push	 ecx
  00343	e8 00 00 00 00	 call	 _permute_args
  00348	83 c4 10	 add	 esp, 16			; 00000010H

; 523  : 				optind -= nonopt_end - nonopt_start;

  0034b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _nonopt_end
  00351	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _nonopt_start
  00357	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  0035c	2b c2		 sub	 eax, edx
  0035e	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax
$LN28@getopt_int:

; 524  : 			}
; 525  : 			nonopt_start = nonopt_end = -1;

  00363	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _nonopt_end, -1
  0036d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nonopt_end
  00373	89 0d 00 00 00
	00		 mov	 DWORD PTR _nonopt_start, ecx

; 526  : 			return (-1);

  00379	83 c8 ff	 or	 eax, -1
  0037c	e9 5d 03 00 00	 jmp	 $LN55@getopt_int
$LN43@getopt_int:

; 527  : 		}
; 528  : 	}
; 529  : 
; 530  : 	/*
; 531  : 	 * Check long options if:
; 532  : 	 *  1) we were passed some
; 533  : 	 *  2) the arg is not just "-"
; 534  : 	 *  3) either the arg starts with -- we are getopt_long_only()
; 535  : 	 */
; 536  : 	if (long_options != NULL && place != nargv[optind] &&
; 537  : 	    (*place == '-' || (flags & FLAG_LONGONLY))) {

  00381	83 7d 14 00	 cmp	 DWORD PTR _long_options$[ebp], 0
  00385	0f 84 be 00 00
	00		 je	 $LN27@getopt_int
  0038b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _optind
  00391	8b 45 0c	 mov	 eax, DWORD PTR _nargv$[ebp]
  00394	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _place
  0039a	3b 0c 90	 cmp	 ecx, DWORD PTR [eax+edx*4]
  0039d	0f 84 a6 00 00
	00		 je	 $LN27@getopt_int
  003a3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _place
  003a9	0f be 02	 movsx	 eax, BYTE PTR [edx]
  003ac	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  003af	74 0c		 je	 SHORT $LN26@getopt_int
  003b1	8b 4d 1c	 mov	 ecx, DWORD PTR _flags$[ebp]
  003b4	83 e1 04	 and	 ecx, 4
  003b7	0f 84 8c 00 00
	00		 je	 $LN27@getopt_int
$LN26@getopt_int:

; 538  : 		short_too = 0;

  003bd	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _short_too$[ebp], 0

; 539  : 		if (*place == '-')

  003c4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _place
  003ca	0f be 02	 movsx	 eax, BYTE PTR [edx]
  003cd	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  003d0	75 11		 jne	 SHORT $LN25@getopt_int

; 540  : 			place++;		/* --foo long option */

  003d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _place
  003d8	83 c1 01	 add	 ecx, 1
  003db	89 0d 00 00 00
	00		 mov	 DWORD PTR _place, ecx
  003e1	eb 2f		 jmp	 SHORT $LN24@getopt_int
$LN25@getopt_int:

; 541  : 		else if (*place != ':' && strchr(options, *place) != NULL)

  003e3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _place
  003e9	0f be 02	 movsx	 eax, BYTE PTR [edx]
  003ec	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  003ef	74 21		 je	 SHORT $LN24@getopt_int
  003f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _place
  003f7	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  003fa	52		 push	 edx
  003fb	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  003fe	50		 push	 eax
  003ff	e8 00 00 00 00	 call	 _strchr
  00404	83 c4 08	 add	 esp, 8
  00407	85 c0		 test	 eax, eax
  00409	74 07		 je	 SHORT $LN24@getopt_int

; 542  : 			short_too = 1;		/* could be short option too */

  0040b	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _short_too$[ebp], 1
$LN24@getopt_int:

; 543  : 
; 544  : 		optchar = parse_long_options(nargv, options, long_options,
; 545  : 		    idx, short_too);

  00412	8b 4d f4	 mov	 ecx, DWORD PTR _short_too$[ebp]
  00415	51		 push	 ecx
  00416	8b 55 18	 mov	 edx, DWORD PTR _idx$[ebp]
  00419	52		 push	 edx
  0041a	8b 45 14	 mov	 eax, DWORD PTR _long_options$[ebp]
  0041d	50		 push	 eax
  0041e	8b 4d 10	 mov	 ecx, DWORD PTR _options$[ebp]
  00421	51		 push	 ecx
  00422	8b 55 0c	 mov	 edx, DWORD PTR _nargv$[ebp]
  00425	52		 push	 edx
  00426	e8 00 00 00 00	 call	 _parse_long_options
  0042b	83 c4 14	 add	 esp, 20			; 00000014H
  0042e	89 45 fc	 mov	 DWORD PTR _optchar$[ebp], eax

; 546  : 		if (optchar != -1) {

  00431	83 7d fc ff	 cmp	 DWORD PTR _optchar$[ebp], -1
  00435	74 12		 je	 SHORT $LN27@getopt_int

; 547  : 			place = EMSG;

  00437	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _place, OFFSET $SG82041

; 548  : 			return (optchar);

  00441	8b 45 fc	 mov	 eax, DWORD PTR _optchar$[ebp]
  00444	e9 95 02 00 00	 jmp	 $LN55@getopt_int
$LN27@getopt_int:

; 549  : 		}
; 550  : 	}
; 551  : 
; 552  : 	if ((optchar = (int)*place++) == (int)':' ||
; 553  : 	    (optchar == (int)'-' && *place != '\0') ||
; 554  : 	    (oli = (char*)strchr(options, optchar)) == NULL) {

  00449	a1 00 00 00 00	 mov	 eax, DWORD PTR _place
  0044e	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00451	89 4d fc	 mov	 DWORD PTR _optchar$[ebp], ecx
  00454	8b 55 fc	 mov	 edx, DWORD PTR _optchar$[ebp]
  00457	a1 00 00 00 00	 mov	 eax, DWORD PTR _place
  0045c	83 c0 01	 add	 eax, 1
  0045f	a3 00 00 00 00	 mov	 DWORD PTR _place, eax
  00464	83 fa 3a	 cmp	 edx, 58			; 0000003aH
  00467	74 2c		 je	 SHORT $LN20@getopt_int
  00469	83 7d fc 2d	 cmp	 DWORD PTR _optchar$[ebp], 45 ; 0000002dH
  0046d	75 0d		 jne	 SHORT $LN19@getopt_int
  0046f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _place
  00475	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00478	85 d2		 test	 edx, edx
  0047a	75 19		 jne	 SHORT $LN20@getopt_int
$LN19@getopt_int:
  0047c	8b 45 fc	 mov	 eax, DWORD PTR _optchar$[ebp]
  0047f	50		 push	 eax
  00480	8b 4d 10	 mov	 ecx, DWORD PTR _options$[ebp]
  00483	51		 push	 ecx
  00484	e8 00 00 00 00	 call	 _strchr
  00489	83 c4 08	 add	 esp, 8
  0048c	89 45 f8	 mov	 DWORD PTR _oli$[ebp], eax
  0048f	83 7d f8 00	 cmp	 DWORD PTR _oli$[ebp], 0
  00493	75 6d		 jne	 SHORT $LN21@getopt_int
$LN20@getopt_int:

; 555  : 		/*
; 556  : 		 * If the user specified "-" and  '-' isn't listed in
; 557  : 		 * options, return -1 (non-option) as per POSIX.
; 558  : 		 * Otherwise, it is an unknown option character (or ':').
; 559  : 		 */
; 560  : 		if (optchar == (int)'-' && *place == '\0')

  00495	83 7d fc 2d	 cmp	 DWORD PTR _optchar$[ebp], 45 ; 0000002dH
  00499	75 15		 jne	 SHORT $LN18@getopt_int
  0049b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _place
  004a1	0f be 02	 movsx	 eax, BYTE PTR [edx]
  004a4	85 c0		 test	 eax, eax
  004a6	75 08		 jne	 SHORT $LN18@getopt_int

; 561  : 			return (-1);

  004a8	83 c8 ff	 or	 eax, -1
  004ab	e9 2e 02 00 00	 jmp	 $LN55@getopt_int
$LN18@getopt_int:

; 562  : 		if (!*place)

  004b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _place
  004b6	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  004b9	85 d2		 test	 edx, edx
  004bb	75 0d		 jne	 SHORT $LN17@getopt_int

; 563  : 			++optind;

  004bd	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  004c2	83 c0 01	 add	 eax, 1
  004c5	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax
$LN17@getopt_int:

; 564  : 		if (PRINT_ERROR)

  004ca	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _opterr, 0
  004d1	74 1c		 je	 SHORT $LN16@getopt_int
  004d3	8b 4d 10	 mov	 ecx, DWORD PTR _options$[ebp]
  004d6	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  004d9	83 fa 3a	 cmp	 edx, 58			; 0000003aH
  004dc	74 11		 je	 SHORT $LN16@getopt_int

; 565  : 			warnx(illoptchar, optchar);

  004de	8b 45 fc	 mov	 eax, DWORD PTR _optchar$[ebp]
  004e1	50		 push	 eax
  004e2	68 00 00 00 00	 push	 OFFSET _illoptchar
  004e7	e8 00 00 00 00	 call	 _warnx
  004ec	83 c4 08	 add	 esp, 8
$LN16@getopt_int:

; 566  : 		optopt = optchar;

  004ef	8b 4d fc	 mov	 ecx, DWORD PTR _optchar$[ebp]
  004f2	89 0d 00 00 00
	00		 mov	 DWORD PTR _optopt, ecx

; 567  : 		return (BADCH);

  004f8	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  004fd	e9 dc 01 00 00	 jmp	 $LN55@getopt_int
$LN21@getopt_int:

; 568  : 	}
; 569  : 	if (long_options != NULL && optchar == 'W' && oli[1] == ';') {

  00502	83 7d 14 00	 cmp	 DWORD PTR _long_options$[ebp], 0
  00506	0f 84 d3 00 00
	00		 je	 $LN15@getopt_int
  0050c	83 7d fc 57	 cmp	 DWORD PTR _optchar$[ebp], 87 ; 00000057H
  00510	0f 85 c9 00 00
	00		 jne	 $LN15@getopt_int
  00516	8b 55 f8	 mov	 edx, DWORD PTR _oli$[ebp]
  00519	0f be 42 01	 movsx	 eax, BYTE PTR [edx+1]
  0051d	83 f8 3b	 cmp	 eax, 59			; 0000003bH
  00520	0f 85 b9 00 00
	00		 jne	 $LN15@getopt_int

; 570  : 		/* -W long-option */
; 571  : 		if (*place)			/* no space */

  00526	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _place
  0052c	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0052f	85 d2		 test	 edx, edx
  00531	74 02		 je	 SHORT $LN14@getopt_int
  00533	eb 7b		 jmp	 SHORT $LN13@getopt_int
$LN14@getopt_int:

; 572  : 			/* NOTHING */;
; 573  : 		else if (++optind >= nargc) {	/* no arg */

  00535	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  0053a	83 c0 01	 add	 eax, 1
  0053d	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax
  00542	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _optind
  00548	3b 4d 08	 cmp	 ecx, DWORD PTR _nargc$[ebp]
  0054b	7c 52		 jl	 SHORT $LN12@getopt_int

; 574  : 			place = EMSG;

  0054d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _place, OFFSET $SG82060

; 575  : 			if (PRINT_ERROR)

  00557	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _opterr, 0
  0055e	74 1c		 je	 SHORT $LN11@getopt_int
  00560	8b 55 10	 mov	 edx, DWORD PTR _options$[ebp]
  00563	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00566	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  00569	74 11		 je	 SHORT $LN11@getopt_int

; 576  : 				warnx(recargchar, optchar);

  0056b	8b 4d fc	 mov	 ecx, DWORD PTR _optchar$[ebp]
  0056e	51		 push	 ecx
  0056f	68 00 00 00 00	 push	 OFFSET _recargchar
  00574	e8 00 00 00 00	 call	 _warnx
  00579	83 c4 08	 add	 esp, 8
$LN11@getopt_int:

; 577  : 			optopt = optchar;

  0057c	8b 55 fc	 mov	 edx, DWORD PTR _optchar$[ebp]
  0057f	89 15 00 00 00
	00		 mov	 DWORD PTR _optopt, edx

; 578  : 			return (BADARG);

  00585	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  00588	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0058b	83 e8 3a	 sub	 eax, 58			; 0000003aH
  0058e	f7 d8		 neg	 eax
  00590	1b c0		 sbb	 eax, eax
  00592	83 e0 05	 and	 eax, 5
  00595	83 c0 3a	 add	 eax, 58			; 0000003aH
  00598	e9 41 01 00 00	 jmp	 $LN55@getopt_int

; 579  : 		} else				/* white space */

  0059d	eb 11		 jmp	 SHORT $LN13@getopt_int
$LN12@getopt_int:

; 580  : 			place = nargv[optind];

  0059f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _optind
  005a5	8b 55 0c	 mov	 edx, DWORD PTR _nargv$[ebp]
  005a8	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  005ab	a3 00 00 00 00	 mov	 DWORD PTR _place, eax
$LN13@getopt_int:

; 581  : 		optchar = parse_long_options(nargv, options, long_options,
; 582  : 		    idx, 0);

  005b0	6a 00		 push	 0
  005b2	8b 4d 18	 mov	 ecx, DWORD PTR _idx$[ebp]
  005b5	51		 push	 ecx
  005b6	8b 55 14	 mov	 edx, DWORD PTR _long_options$[ebp]
  005b9	52		 push	 edx
  005ba	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  005bd	50		 push	 eax
  005be	8b 4d 0c	 mov	 ecx, DWORD PTR _nargv$[ebp]
  005c1	51		 push	 ecx
  005c2	e8 00 00 00 00	 call	 _parse_long_options
  005c7	83 c4 14	 add	 esp, 20			; 00000014H
  005ca	89 45 fc	 mov	 DWORD PTR _optchar$[ebp], eax

; 583  : 		place = EMSG;

  005cd	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _place, OFFSET $SG82065

; 584  : 		return (optchar);

  005d7	8b 45 fc	 mov	 eax, DWORD PTR _optchar$[ebp]
  005da	e9 ff 00 00 00	 jmp	 $LN55@getopt_int
$LN15@getopt_int:

; 585  : 	}
; 586  : 	if (*++oli != ':') {			/* doesn't take argument */

  005df	8b 55 f8	 mov	 edx, DWORD PTR _oli$[ebp]
  005e2	83 c2 01	 add	 edx, 1
  005e5	89 55 f8	 mov	 DWORD PTR _oli$[ebp], edx
  005e8	8b 45 f8	 mov	 eax, DWORD PTR _oli$[ebp]
  005eb	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  005ee	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  005f1	74 21		 je	 SHORT $LN9@getopt_int

; 587  : 		if (!*place)

  005f3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _place
  005f9	0f be 02	 movsx	 eax, BYTE PTR [edx]
  005fc	85 c0		 test	 eax, eax
  005fe	75 0f		 jne	 SHORT $LN8@getopt_int

; 588  : 			++optind;

  00600	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _optind
  00606	83 c1 01	 add	 ecx, 1
  00609	89 0d 00 00 00
	00		 mov	 DWORD PTR _optind, ecx
$LN8@getopt_int:

; 589  : 	} else {				/* takes (optional) argument */

  0060f	e9 c7 00 00 00	 jmp	 $LN7@getopt_int
$LN9@getopt_int:

; 590  : 		optarg = NULL;

  00614	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _optarg, 0

; 591  : 		if (*place)			/* no white space */

  0061e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _place
  00624	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00627	85 c0		 test	 eax, eax
  00629	74 11		 je	 SHORT $LN6@getopt_int

; 592  : 			optarg = place;

  0062b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _place
  00631	89 0d 00 00 00
	00		 mov	 DWORD PTR _optarg, ecx
  00637	e9 86 00 00 00	 jmp	 $LN5@getopt_int
$LN6@getopt_int:

; 593  : 		else if (oli[1] != ':') {	/* arg not optional */

  0063c	8b 55 f8	 mov	 edx, DWORD PTR _oli$[ebp]
  0063f	0f be 42 01	 movsx	 eax, BYTE PTR [edx+1]
  00643	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  00646	74 7a		 je	 SHORT $LN5@getopt_int

; 594  : 			if (++optind >= nargc) {	/* no arg */

  00648	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _optind
  0064e	83 c1 01	 add	 ecx, 1
  00651	89 0d 00 00 00
	00		 mov	 DWORD PTR _optind, ecx
  00657	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _optind
  0065d	3b 55 08	 cmp	 edx, DWORD PTR _nargc$[ebp]
  00660	7c 4e		 jl	 SHORT $LN3@getopt_int

; 595  : 				place = EMSG;

  00662	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _place, OFFSET $SG82074

; 596  : 				if (PRINT_ERROR)

  0066c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _opterr, 0
  00673	74 1c		 je	 SHORT $LN2@getopt_int
  00675	8b 45 10	 mov	 eax, DWORD PTR _options$[ebp]
  00678	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0067b	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  0067e	74 11		 je	 SHORT $LN2@getopt_int

; 597  : 					warnx(recargchar, optchar);

  00680	8b 55 fc	 mov	 edx, DWORD PTR _optchar$[ebp]
  00683	52		 push	 edx
  00684	68 00 00 00 00	 push	 OFFSET _recargchar
  00689	e8 00 00 00 00	 call	 _warnx
  0068e	83 c4 08	 add	 esp, 8
$LN2@getopt_int:

; 598  : 				optopt = optchar;

  00691	8b 45 fc	 mov	 eax, DWORD PTR _optchar$[ebp]
  00694	a3 00 00 00 00	 mov	 DWORD PTR _optopt, eax

; 599  : 				return (BADARG);

  00699	8b 4d 10	 mov	 ecx, DWORD PTR _options$[ebp]
  0069c	0f be 01	 movsx	 eax, BYTE PTR [ecx]
  0069f	83 e8 3a	 sub	 eax, 58			; 0000003aH
  006a2	f7 d8		 neg	 eax
  006a4	1b c0		 sbb	 eax, eax
  006a6	83 e0 05	 and	 eax, 5
  006a9	83 c0 3a	 add	 eax, 58			; 0000003aH
  006ac	eb 30		 jmp	 SHORT $LN55@getopt_int

; 600  : 			} else

  006ae	eb 12		 jmp	 SHORT $LN5@getopt_int
$LN3@getopt_int:

; 601  : 				optarg = nargv[optind];

  006b0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _optind
  006b6	8b 45 0c	 mov	 eax, DWORD PTR _nargv$[ebp]
  006b9	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  006bc	89 0d 00 00 00
	00		 mov	 DWORD PTR _optarg, ecx
$LN5@getopt_int:

; 602  : 		}
; 603  : 		place = EMSG;

  006c2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _place, OFFSET $SG82079

; 604  : 		++optind;

  006cc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _optind
  006d2	83 c2 01	 add	 edx, 1
  006d5	89 15 00 00 00
	00		 mov	 DWORD PTR _optind, edx
$LN7@getopt_int:

; 605  : 	}
; 606  : 	/* dump back option letter */
; 607  : 	return (optchar);

  006db	8b 45 fc	 mov	 eax, DWORD PTR _optchar$[ebp]
$LN55@getopt_int:

; 608  : }

  006de	8b e5		 mov	 esp, ebp
  006e0	5d		 pop	 ebp
  006e1	c3		 ret	 0
_getopt_internal ENDP
; Function compile flags: /Odtp
_ap$ = -4						; size = 4
_fmt$ = 8						; size = 4
_warnx	PROC

; 151  : {

  006f0	55		 push	 ebp
  006f1	8b ec		 mov	 ebp, esp
  006f3	51		 push	 ecx

; 152  :   va_list ap;
; 153  :   va_start(ap,fmt);

  006f4	8d 45 0c	 lea	 eax, DWORD PTR _fmt$[ebp+4]
  006f7	89 45 fc	 mov	 DWORD PTR _ap$[ebp], eax

; 154  :   _vwarnx(fmt,ap);

  006fa	8b 4d fc	 mov	 ecx, DWORD PTR _ap$[ebp]
  006fd	51		 push	 ecx
  006fe	8b 55 08	 mov	 edx, DWORD PTR _fmt$[ebp]
  00701	52		 push	 edx
  00702	e8 00 00 00 00	 call	 __vwarnx
  00707	83 c4 08	 add	 esp, 8

; 155  :   va_end(ap);

  0070a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ap$[ebp], 0

; 156  : }

  00711	8b e5		 mov	 esp, ebp
  00713	5d		 pop	 ebp
  00714	c3		 ret	 0
_warnx	ENDP
_TEXT	ENDS
EXTRN	_vfprintf:PROC
EXTRN	_fprintf:PROC
EXTRN	___iob_func:PROC
EXTRN	___argv:DWORD
; Function compile flags: /Odtp
_TEXT	SEGMENT
_fmt$ = 8						; size = 4
_ap$ = 12						; size = 4
__vwarnx PROC

; 142  : {

  00720	55		 push	 ebp
  00721	8b ec		 mov	 ebp, esp

; 143  :   (void)fprintf(stderr,"%s: ",__progname);

  00723	a1 00 00 00 00	 mov	 eax, DWORD PTR ___argv
  00728	8b 08		 mov	 ecx, DWORD PTR [eax]
  0072a	51		 push	 ecx
  0072b	68 00 00 00 00	 push	 OFFSET $SG81845
  00730	e8 00 00 00 00	 call	 ___iob_func
  00735	83 c0 40	 add	 eax, 64			; 00000040H
  00738	50		 push	 eax
  00739	e8 00 00 00 00	 call	 _fprintf
  0073e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 144  :   if (fmt != NULL)

  00741	83 7d 08 00	 cmp	 DWORD PTR _fmt$[ebp], 0
  00745	74 19		 je	 SHORT $LN1@vwarnx

; 145  :     (void)vfprintf(stderr,fmt,ap);

  00747	8b 55 0c	 mov	 edx, DWORD PTR _ap$[ebp]
  0074a	52		 push	 edx
  0074b	8b 45 08	 mov	 eax, DWORD PTR _fmt$[ebp]
  0074e	50		 push	 eax
  0074f	e8 00 00 00 00	 call	 ___iob_func
  00754	83 c0 40	 add	 eax, 64			; 00000040H
  00757	50		 push	 eax
  00758	e8 00 00 00 00	 call	 _vfprintf
  0075d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@vwarnx:

; 146  :   (void)fprintf(stderr,"\n");

  00760	68 00 00 00 00	 push	 OFFSET $SG81850
  00765	e8 00 00 00 00	 call	 ___iob_func
  0076a	83 c0 40	 add	 eax, 64			; 00000040H
  0076d	50		 push	 eax
  0076e	e8 00 00 00 00	 call	 _fprintf
  00773	83 c4 08	 add	 esp, 8

; 147  : }

  00776	5d		 pop	 ebp
  00777	c3		 ret	 0
__vwarnx ENDP
; Function compile flags: /Odtp
_j$ = -36						; size = 4
_pos$ = -32						; size = 4
_swap$ = -28						; size = 4
_cyclelen$ = -24					; size = 4
_ncycle$ = -20						; size = 4
_nopts$ = -16						; size = 4
_cstart$ = -12						; size = 4
_i$ = -8						; size = 4
_nnonopts$ = -4						; size = 4
_panonopt_start$ = 8					; size = 4
_panonopt_end$ = 12					; size = 4
_opt_end$ = 16						; size = 4
_nargv$ = 20						; size = 4
_permute_args PROC

; 184  : {

  00780	55		 push	 ebp
  00781	8b ec		 mov	 ebp, esp
  00783	83 ec 24	 sub	 esp, 36			; 00000024H
  00786	56		 push	 esi

; 185  : 	int cstart, cyclelen, i, j, ncycle, nnonopts, nopts, pos;
; 186  : 	char *swap;
; 187  : 
; 188  : 	/*
; 189  : 	 * compute lengths of blocks and number and size of cycles
; 190  : 	 */
; 191  : 	nnonopts = panonopt_end - panonopt_start;

  00787	8b 45 0c	 mov	 eax, DWORD PTR _panonopt_end$[ebp]
  0078a	2b 45 08	 sub	 eax, DWORD PTR _panonopt_start$[ebp]
  0078d	89 45 fc	 mov	 DWORD PTR _nnonopts$[ebp], eax

; 192  : 	nopts = opt_end - panonopt_end;

  00790	8b 4d 10	 mov	 ecx, DWORD PTR _opt_end$[ebp]
  00793	2b 4d 0c	 sub	 ecx, DWORD PTR _panonopt_end$[ebp]
  00796	89 4d f0	 mov	 DWORD PTR _nopts$[ebp], ecx

; 193  : 	ncycle = gcd(nnonopts, nopts);

  00799	8b 55 f0	 mov	 edx, DWORD PTR _nopts$[ebp]
  0079c	52		 push	 edx
  0079d	8b 45 fc	 mov	 eax, DWORD PTR _nnonopts$[ebp]
  007a0	50		 push	 eax
  007a1	e8 00 00 00 00	 call	 _gcd
  007a6	83 c4 08	 add	 esp, 8
  007a9	89 45 ec	 mov	 DWORD PTR _ncycle$[ebp], eax

; 194  : 	cyclelen = (opt_end - panonopt_start) / ncycle;

  007ac	8b 45 10	 mov	 eax, DWORD PTR _opt_end$[ebp]
  007af	2b 45 08	 sub	 eax, DWORD PTR _panonopt_start$[ebp]
  007b2	99		 cdq
  007b3	f7 7d ec	 idiv	 DWORD PTR _ncycle$[ebp]
  007b6	89 45 e8	 mov	 DWORD PTR _cyclelen$[ebp], eax

; 195  : 
; 196  : 	for (i = 0; i < ncycle; i++) {

  007b9	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  007c0	eb 09		 jmp	 SHORT $LN8@permute_ar
$LN7@permute_ar:
  007c2	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  007c5	83 c1 01	 add	 ecx, 1
  007c8	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
$LN8@permute_ar:
  007cb	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  007ce	3b 55 ec	 cmp	 edx, DWORD PTR _ncycle$[ebp]
  007d1	7d 76		 jge	 SHORT $LN9@permute_ar

; 197  : 		cstart = panonopt_end+i;

  007d3	8b 45 0c	 mov	 eax, DWORD PTR _panonopt_end$[ebp]
  007d6	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  007d9	89 45 f4	 mov	 DWORD PTR _cstart$[ebp], eax

; 198  : 		pos = cstart;

  007dc	8b 4d f4	 mov	 ecx, DWORD PTR _cstart$[ebp]
  007df	89 4d e0	 mov	 DWORD PTR _pos$[ebp], ecx

; 199  : 		for (j = 0; j < cyclelen; j++) {

  007e2	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  007e9	eb 09		 jmp	 SHORT $LN5@permute_ar
$LN4@permute_ar:
  007eb	8b 55 dc	 mov	 edx, DWORD PTR _j$[ebp]
  007ee	83 c2 01	 add	 edx, 1
  007f1	89 55 dc	 mov	 DWORD PTR _j$[ebp], edx
$LN5@permute_ar:
  007f4	8b 45 dc	 mov	 eax, DWORD PTR _j$[ebp]
  007f7	3b 45 e8	 cmp	 eax, DWORD PTR _cyclelen$[ebp]
  007fa	7d 48		 jge	 SHORT $LN3@permute_ar

; 200  : 			if (pos >= panonopt_end)

  007fc	8b 4d e0	 mov	 ecx, DWORD PTR _pos$[ebp]
  007ff	3b 4d 0c	 cmp	 ecx, DWORD PTR _panonopt_end$[ebp]
  00802	7c 0b		 jl	 SHORT $LN2@permute_ar

; 201  : 				pos -= nnonopts;

  00804	8b 55 e0	 mov	 edx, DWORD PTR _pos$[ebp]
  00807	2b 55 fc	 sub	 edx, DWORD PTR _nnonopts$[ebp]
  0080a	89 55 e0	 mov	 DWORD PTR _pos$[ebp], edx

; 202  : 			else

  0080d	eb 09		 jmp	 SHORT $LN1@permute_ar
$LN2@permute_ar:

; 203  : 				pos += nopts;

  0080f	8b 45 e0	 mov	 eax, DWORD PTR _pos$[ebp]
  00812	03 45 f0	 add	 eax, DWORD PTR _nopts$[ebp]
  00815	89 45 e0	 mov	 DWORD PTR _pos$[ebp], eax
$LN1@permute_ar:

; 204  : 			swap = nargv[pos];

  00818	8b 4d e0	 mov	 ecx, DWORD PTR _pos$[ebp]
  0081b	8b 55 14	 mov	 edx, DWORD PTR _nargv$[ebp]
  0081e	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  00821	89 45 e4	 mov	 DWORD PTR _swap$[ebp], eax

; 205  : 			/* LINTED const cast */
; 206  : 			((char **) nargv)[pos] = nargv[cstart];

  00824	8b 4d e0	 mov	 ecx, DWORD PTR _pos$[ebp]
  00827	8b 55 14	 mov	 edx, DWORD PTR _nargv$[ebp]
  0082a	8b 45 f4	 mov	 eax, DWORD PTR _cstart$[ebp]
  0082d	8b 75 14	 mov	 esi, DWORD PTR _nargv$[ebp]
  00830	8b 04 86	 mov	 eax, DWORD PTR [esi+eax*4]
  00833	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 207  : 			/* LINTED const cast */
; 208  : 			((char **)nargv)[cstart] = swap;

  00836	8b 4d f4	 mov	 ecx, DWORD PTR _cstart$[ebp]
  00839	8b 55 14	 mov	 edx, DWORD PTR _nargv$[ebp]
  0083c	8b 45 e4	 mov	 eax, DWORD PTR _swap$[ebp]
  0083f	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 209  : 		}

  00842	eb a7		 jmp	 SHORT $LN4@permute_ar
$LN3@permute_ar:

; 210  : 	}

  00844	e9 79 ff ff ff	 jmp	 $LN7@permute_ar
$LN9@permute_ar:

; 211  : }

  00849	5e		 pop	 esi
  0084a	8b e5		 mov	 esp, ebp
  0084c	5d		 pop	 ebp
  0084d	c3		 ret	 0
_permute_args ENDP
; Function compile flags: /Odtp
_c$ = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_gcd	PROC

; 163  : {

  00850	55		 push	 ebp
  00851	8b ec		 mov	 ebp, esp
  00853	51		 push	 ecx

; 164  : 	int c;
; 165  : 
; 166  : 	c = a % b;

  00854	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00857	99		 cdq
  00858	f7 7d 0c	 idiv	 DWORD PTR _b$[ebp]
  0085b	89 55 fc	 mov	 DWORD PTR _c$[ebp], edx
$LN2@gcd:

; 167  : 	while (c != 0) {

  0085e	83 7d fc 00	 cmp	 DWORD PTR _c$[ebp], 0
  00862	74 18		 je	 SHORT $LN1@gcd

; 168  : 		a = b;

  00864	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  00867	89 45 08	 mov	 DWORD PTR _a$[ebp], eax

; 169  : 		b = c;

  0086a	8b 4d fc	 mov	 ecx, DWORD PTR _c$[ebp]
  0086d	89 4d 0c	 mov	 DWORD PTR _b$[ebp], ecx

; 170  : 		c = a % b;

  00870	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00873	99		 cdq
  00874	f7 7d 0c	 idiv	 DWORD PTR _b$[ebp]
  00877	89 55 fc	 mov	 DWORD PTR _c$[ebp], edx

; 171  : 	}

  0087a	eb e2		 jmp	 SHORT $LN2@gcd
$LN1@gcd:

; 172  : 
; 173  : 	return (b);

  0087c	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]

; 174  : }

  0087f	8b e5		 mov	 esp, ebp
  00881	5d		 pop	 ebp
  00882	c3		 ret	 0
_gcd	ENDP
_TEXT	ENDS
EXTRN	_strncmp:PROC
EXTRN	_strlen:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_has_equal$ = -24					; size = 4
_match$ = -20						; size = 4
_ambiguous$ = -16					; size = 4
_i$ = -12						; size = 4
_current_argv_len$ = -8					; size = 4
_current_argv$ = -4					; size = 4
_nargv$ = 8						; size = 4
_options$ = 12						; size = 4
_long_options$ = 16					; size = 4
_idx$ = 20						; size = 4
_short_too$ = 24					; size = 4
_parse_long_options PROC

; 292  : {

  00890	55		 push	 ebp
  00891	8b ec		 mov	 ebp, esp
  00893	83 ec 18	 sub	 esp, 24			; 00000018H
  00896	56		 push	 esi

; 293  : 	char *current_argv, *has_equal;
; 294  : 	size_t current_argv_len;
; 295  : 	int i, ambiguous, match;
; 296  : 
; 297  : #define IDENTICAL_INTERPRETATION(_x, _y)                                \
; 298  : 	(long_options[(_x)].has_arg == long_options[(_y)].has_arg &&    \
; 299  : 	 long_options[(_x)].flag == long_options[(_y)].flag &&          \
; 300  : 	 long_options[(_x)].val == long_options[(_y)].val)
; 301  : 
; 302  : 	current_argv = place;

  00897	a1 00 00 00 00	 mov	 eax, DWORD PTR _place
  0089c	89 45 fc	 mov	 DWORD PTR _current_argv$[ebp], eax

; 303  : 	match = -1;

  0089f	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR _match$[ebp], -1

; 304  : 	ambiguous = 0;

  008a6	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _ambiguous$[ebp], 0

; 305  : 
; 306  : 	optind++;

  008ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _optind
  008b3	83 c1 01	 add	 ecx, 1
  008b6	89 0d 00 00 00
	00		 mov	 DWORD PTR _optind, ecx

; 307  : 
; 308  : 	if ((has_equal = strchr(current_argv, '=')) != NULL) {

  008bc	6a 3d		 push	 61			; 0000003dH
  008be	8b 55 fc	 mov	 edx, DWORD PTR _current_argv$[ebp]
  008c1	52		 push	 edx
  008c2	e8 00 00 00 00	 call	 _strchr
  008c7	83 c4 08	 add	 esp, 8
  008ca	89 45 e8	 mov	 DWORD PTR _has_equal$[ebp], eax
  008cd	83 7d e8 00	 cmp	 DWORD PTR _has_equal$[ebp], 0
  008d1	74 14		 je	 SHORT $LN34@parse_long

; 309  : 		/* argument found (--option=arg) */
; 310  : 		current_argv_len = has_equal - current_argv;

  008d3	8b 45 e8	 mov	 eax, DWORD PTR _has_equal$[ebp]
  008d6	2b 45 fc	 sub	 eax, DWORD PTR _current_argv$[ebp]
  008d9	89 45 f8	 mov	 DWORD PTR _current_argv_len$[ebp], eax

; 311  : 		has_equal++;

  008dc	8b 4d e8	 mov	 ecx, DWORD PTR _has_equal$[ebp]
  008df	83 c1 01	 add	 ecx, 1
  008e2	89 4d e8	 mov	 DWORD PTR _has_equal$[ebp], ecx

; 312  : 	} else

  008e5	eb 0f		 jmp	 SHORT $LN33@parse_long
$LN34@parse_long:

; 313  : 		current_argv_len = strlen(current_argv);

  008e7	8b 55 fc	 mov	 edx, DWORD PTR _current_argv$[ebp]
  008ea	52		 push	 edx
  008eb	e8 00 00 00 00	 call	 _strlen
  008f0	83 c4 04	 add	 esp, 4
  008f3	89 45 f8	 mov	 DWORD PTR _current_argv_len$[ebp], eax
$LN33@parse_long:

; 314  : 
; 315  : 	for (i = 0; long_options[i].name; i++) {

  008f6	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  008fd	eb 09		 jmp	 SHORT $LN32@parse_long
$LN31@parse_long:
  008ff	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00902	83 c0 01	 add	 eax, 1
  00905	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN32@parse_long:
  00908	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0090b	c1 e1 04	 shl	 ecx, 4
  0090e	8b 55 10	 mov	 edx, DWORD PTR _long_options$[ebp]
  00911	83 3c 0a 00	 cmp	 DWORD PTR [edx+ecx], 0
  00915	0f 84 c8 00 00
	00		 je	 $LN30@parse_long

; 316  : 		/* find matching long option */
; 317  : 		if (strncmp(current_argv, long_options[i].name,
; 318  : 		    current_argv_len))

  0091b	8b 45 f8	 mov	 eax, DWORD PTR _current_argv_len$[ebp]
  0091e	50		 push	 eax
  0091f	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00922	c1 e1 04	 shl	 ecx, 4
  00925	8b 55 10	 mov	 edx, DWORD PTR _long_options$[ebp]
  00928	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0092b	50		 push	 eax
  0092c	8b 4d fc	 mov	 ecx, DWORD PTR _current_argv$[ebp]
  0092f	51		 push	 ecx
  00930	e8 00 00 00 00	 call	 _strncmp
  00935	83 c4 0c	 add	 esp, 12			; 0000000cH
  00938	85 c0		 test	 eax, eax
  0093a	74 02		 je	 SHORT $LN29@parse_long

; 319  : 			continue;

  0093c	eb c1		 jmp	 SHORT $LN31@parse_long
$LN29@parse_long:

; 320  : 
; 321  : 		if (strlen(long_options[i].name) == current_argv_len) {

  0093e	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  00941	c1 e2 04	 shl	 edx, 4
  00944	8b 45 10	 mov	 eax, DWORD PTR _long_options$[ebp]
  00947	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  0094a	51		 push	 ecx
  0094b	e8 00 00 00 00	 call	 _strlen
  00950	83 c4 04	 add	 esp, 4
  00953	3b 45 f8	 cmp	 eax, DWORD PTR _current_argv_len$[ebp]
  00956	75 0f		 jne	 SHORT $LN28@parse_long

; 322  : 			/* exact match */
; 323  : 			match = i;

  00958	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  0095b	89 55 ec	 mov	 DWORD PTR _match$[ebp], edx

; 324  : 			ambiguous = 0;

  0095e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _ambiguous$[ebp], 0

; 325  : 			break;

  00965	eb 7c		 jmp	 SHORT $LN30@parse_long
$LN28@parse_long:

; 326  : 		}
; 327  : 		/*
; 328  : 		 * If this is a known short option, don't allow
; 329  : 		 * a partial match of a single character.
; 330  : 		 */
; 331  : 		if (short_too && current_argv_len == 1)

  00967	83 7d 18 00	 cmp	 DWORD PTR _short_too$[ebp], 0
  0096b	74 08		 je	 SHORT $LN27@parse_long
  0096d	83 7d f8 01	 cmp	 DWORD PTR _current_argv_len$[ebp], 1
  00971	75 02		 jne	 SHORT $LN27@parse_long

; 332  : 			continue;

  00973	eb 8a		 jmp	 SHORT $LN31@parse_long
$LN27@parse_long:

; 333  : 
; 334  : 		if (match == -1)	/* partial match */

  00975	83 7d ec ff	 cmp	 DWORD PTR _match$[ebp], -1
  00979	75 08		 jne	 SHORT $LN26@parse_long

; 335  : 			match = i;

  0097b	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0097e	89 45 ec	 mov	 DWORD PTR _match$[ebp], eax
  00981	eb 5b		 jmp	 SHORT $LN25@parse_long
$LN26@parse_long:

; 336  : 		else if (!IDENTICAL_INTERPRETATION(i, match))

  00983	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  00986	c1 e1 04	 shl	 ecx, 4
  00989	8b 55 ec	 mov	 edx, DWORD PTR _match$[ebp]
  0098c	c1 e2 04	 shl	 edx, 4
  0098f	8b 45 10	 mov	 eax, DWORD PTR _long_options$[ebp]
  00992	8b 75 10	 mov	 esi, DWORD PTR _long_options$[ebp]
  00995	8b 4c 08 04	 mov	 ecx, DWORD PTR [eax+ecx+4]
  00999	3b 4c 16 04	 cmp	 ecx, DWORD PTR [esi+edx+4]
  0099d	75 38		 jne	 SHORT $LN23@parse_long
  0099f	8b 55 f4	 mov	 edx, DWORD PTR _i$[ebp]
  009a2	c1 e2 04	 shl	 edx, 4
  009a5	8b 45 ec	 mov	 eax, DWORD PTR _match$[ebp]
  009a8	c1 e0 04	 shl	 eax, 4
  009ab	8b 4d 10	 mov	 ecx, DWORD PTR _long_options$[ebp]
  009ae	8b 75 10	 mov	 esi, DWORD PTR _long_options$[ebp]
  009b1	8b 54 11 08	 mov	 edx, DWORD PTR [ecx+edx+8]
  009b5	3b 54 06 08	 cmp	 edx, DWORD PTR [esi+eax+8]
  009b9	75 1c		 jne	 SHORT $LN23@parse_long
  009bb	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  009be	c1 e0 04	 shl	 eax, 4
  009c1	8b 4d ec	 mov	 ecx, DWORD PTR _match$[ebp]
  009c4	c1 e1 04	 shl	 ecx, 4
  009c7	8b 55 10	 mov	 edx, DWORD PTR _long_options$[ebp]
  009ca	8b 75 10	 mov	 esi, DWORD PTR _long_options$[ebp]
  009cd	8b 44 02 0c	 mov	 eax, DWORD PTR [edx+eax+12]
  009d1	3b 44 0e 0c	 cmp	 eax, DWORD PTR [esi+ecx+12]
  009d5	74 07		 je	 SHORT $LN25@parse_long
$LN23@parse_long:

; 337  : 			ambiguous = 1;

  009d7	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _ambiguous$[ebp], 1
$LN25@parse_long:

; 338  : 	}

  009de	e9 1c ff ff ff	 jmp	 $LN31@parse_long
$LN30@parse_long:

; 339  : 	if (ambiguous) {

  009e3	83 7d f0 00	 cmp	 DWORD PTR _ambiguous$[ebp], 0
  009e7	74 3d		 je	 SHORT $LN22@parse_long

; 340  : 		/* ambiguous abbreviation */
; 341  : 		if (PRINT_ERROR)

  009e9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _opterr, 0
  009f0	74 20		 je	 SHORT $LN21@parse_long
  009f2	8b 4d 0c	 mov	 ecx, DWORD PTR _options$[ebp]
  009f5	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  009f8	83 fa 3a	 cmp	 edx, 58			; 0000003aH
  009fb	74 15		 je	 SHORT $LN21@parse_long

; 342  : 			warnx(ambig, (int)current_argv_len,
; 343  : 			     current_argv);

  009fd	8b 45 fc	 mov	 eax, DWORD PTR _current_argv$[ebp]
  00a00	50		 push	 eax
  00a01	8b 4d f8	 mov	 ecx, DWORD PTR _current_argv_len$[ebp]
  00a04	51		 push	 ecx
  00a05	68 00 00 00 00	 push	 OFFSET _ambig
  00a0a	e8 00 00 00 00	 call	 _warnx
  00a0f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN21@parse_long:

; 344  : 		optopt = 0;

  00a12	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _optopt, 0

; 345  : 		return (BADCH);

  00a1c	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  00a21	e9 27 02 00 00	 jmp	 $LN35@parse_long
$LN22@parse_long:

; 346  : 	}
; 347  : 	if (match != -1) {		/* option found */

  00a26	83 7d ec ff	 cmp	 DWORD PTR _match$[ebp], -1
  00a2a	0f 84 7d 01 00
	00		 je	 $LN20@parse_long

; 348  : 		if (long_options[match].has_arg == no_argument
; 349  : 		    && has_equal) {

  00a30	8b 55 ec	 mov	 edx, DWORD PTR _match$[ebp]
  00a33	c1 e2 04	 shl	 edx, 4
  00a36	8b 45 10	 mov	 eax, DWORD PTR _long_options$[ebp]
  00a39	83 7c 10 04 00	 cmp	 DWORD PTR [eax+edx+4], 0
  00a3e	75 75		 jne	 SHORT $LN19@parse_long
  00a40	83 7d e8 00	 cmp	 DWORD PTR _has_equal$[ebp], 0
  00a44	74 6f		 je	 SHORT $LN19@parse_long

; 350  : 			if (PRINT_ERROR)

  00a46	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _opterr, 0
  00a4d	74 20		 je	 SHORT $LN18@parse_long
  00a4f	8b 4d 0c	 mov	 ecx, DWORD PTR _options$[ebp]
  00a52	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00a55	83 fa 3a	 cmp	 edx, 58			; 0000003aH
  00a58	74 15		 je	 SHORT $LN18@parse_long

; 351  : 				warnx(noarg, (int)current_argv_len,
; 352  : 				     current_argv);

  00a5a	8b 45 fc	 mov	 eax, DWORD PTR _current_argv$[ebp]
  00a5d	50		 push	 eax
  00a5e	8b 4d f8	 mov	 ecx, DWORD PTR _current_argv_len$[ebp]
  00a61	51		 push	 ecx
  00a62	68 00 00 00 00	 push	 OFFSET _noarg
  00a67	e8 00 00 00 00	 call	 _warnx
  00a6c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN18@parse_long:

; 353  : 			/*
; 354  : 			 * XXX: GNU sets optopt to val regardless of flag
; 355  : 			 */
; 356  : 			if (long_options[match].flag == NULL)

  00a6f	8b 55 ec	 mov	 edx, DWORD PTR _match$[ebp]
  00a72	c1 e2 04	 shl	 edx, 4
  00a75	8b 45 10	 mov	 eax, DWORD PTR _long_options$[ebp]
  00a78	83 7c 10 08 00	 cmp	 DWORD PTR [eax+edx+8], 0
  00a7d	75 14		 jne	 SHORT $LN17@parse_long

; 357  : 				optopt = long_options[match].val;

  00a7f	8b 4d ec	 mov	 ecx, DWORD PTR _match$[ebp]
  00a82	c1 e1 04	 shl	 ecx, 4
  00a85	8b 55 10	 mov	 edx, DWORD PTR _long_options$[ebp]
  00a88	8b 44 0a 0c	 mov	 eax, DWORD PTR [edx+ecx+12]
  00a8c	a3 00 00 00 00	 mov	 DWORD PTR _optopt, eax

; 358  : 			else

  00a91	eb 0a		 jmp	 SHORT $LN16@parse_long
$LN17@parse_long:

; 359  : 				optopt = 0;

  00a93	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _optopt, 0
$LN16@parse_long:

; 360  : 			return (BADARG);

  00a9d	8b 4d 0c	 mov	 ecx, DWORD PTR _options$[ebp]
  00aa0	0f be 01	 movsx	 eax, BYTE PTR [ecx]
  00aa3	83 e8 3a	 sub	 eax, 58			; 0000003aH
  00aa6	f7 d8		 neg	 eax
  00aa8	1b c0		 sbb	 eax, eax
  00aaa	83 e0 05	 and	 eax, 5
  00aad	83 c0 3a	 add	 eax, 58			; 0000003aH
  00ab0	e9 98 01 00 00	 jmp	 $LN35@parse_long
$LN19@parse_long:

; 361  : 		}
; 362  : 		if (long_options[match].has_arg == required_argument ||
; 363  : 		    long_options[match].has_arg == optional_argument) {

  00ab5	8b 55 ec	 mov	 edx, DWORD PTR _match$[ebp]
  00ab8	c1 e2 04	 shl	 edx, 4
  00abb	8b 45 10	 mov	 eax, DWORD PTR _long_options$[ebp]
  00abe	83 7c 10 04 01	 cmp	 DWORD PTR [eax+edx+4], 1
  00ac3	74 10		 je	 SHORT $LN14@parse_long
  00ac5	8b 4d ec	 mov	 ecx, DWORD PTR _match$[ebp]
  00ac8	c1 e1 04	 shl	 ecx, 4
  00acb	8b 55 10	 mov	 edx, DWORD PTR _long_options$[ebp]
  00ace	83 7c 0a 04 02	 cmp	 DWORD PTR [edx+ecx+4], 2
  00ad3	75 3e		 jne	 SHORT $LN15@parse_long
$LN14@parse_long:

; 364  : 			if (has_equal)

  00ad5	83 7d e8 00	 cmp	 DWORD PTR _has_equal$[ebp], 0
  00ad9	74 0a		 je	 SHORT $LN13@parse_long

; 365  : 				optarg = has_equal;

  00adb	8b 45 e8	 mov	 eax, DWORD PTR _has_equal$[ebp]
  00ade	a3 00 00 00 00	 mov	 DWORD PTR _optarg, eax

; 366  : 			else if (long_options[match].has_arg ==

  00ae3	eb 2e		 jmp	 SHORT $LN15@parse_long
$LN13@parse_long:

; 367  : 			    required_argument) {

  00ae5	8b 4d ec	 mov	 ecx, DWORD PTR _match$[ebp]
  00ae8	c1 e1 04	 shl	 ecx, 4
  00aeb	8b 55 10	 mov	 edx, DWORD PTR _long_options$[ebp]
  00aee	83 7c 0a 04 01	 cmp	 DWORD PTR [edx+ecx+4], 1
  00af3	75 1e		 jne	 SHORT $LN15@parse_long

; 368  : 				/*
; 369  : 				 * optional argument doesn't use next nargv
; 370  : 				 */
; 371  : 				optarg = nargv[optind++];

  00af5	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  00afa	8b 4d 08	 mov	 ecx, DWORD PTR _nargv$[ebp]
  00afd	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00b00	89 15 00 00 00
	00		 mov	 DWORD PTR _optarg, edx
  00b06	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  00b0b	83 c0 01	 add	 eax, 1
  00b0e	a3 00 00 00 00	 mov	 DWORD PTR _optind, eax
$LN15@parse_long:

; 372  : 			}
; 373  : 		}
; 374  : 		if ((long_options[match].has_arg == required_argument)
; 375  : 		    && (optarg == NULL)) {

  00b13	8b 4d ec	 mov	 ecx, DWORD PTR _match$[ebp]
  00b16	c1 e1 04	 shl	 ecx, 4
  00b19	8b 55 10	 mov	 edx, DWORD PTR _long_options$[ebp]
  00b1c	83 7c 0a 04 01	 cmp	 DWORD PTR [edx+ecx+4], 1
  00b21	0f 85 84 00 00
	00		 jne	 $LN10@parse_long
  00b27	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _optarg, 0
  00b2e	75 7b		 jne	 SHORT $LN10@parse_long

; 376  : 			/*
; 377  : 			 * Missing argument; leading ':' indicates no error
; 378  : 			 * should be generated.
; 379  : 			 */
; 380  : 			if (PRINT_ERROR)

  00b30	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _opterr, 0
  00b37	74 1c		 je	 SHORT $LN9@parse_long
  00b39	8b 45 0c	 mov	 eax, DWORD PTR _options$[ebp]
  00b3c	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00b3f	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  00b42	74 11		 je	 SHORT $LN9@parse_long

; 381  : 				warnx(recargstring,
; 382  : 				    current_argv);

  00b44	8b 55 fc	 mov	 edx, DWORD PTR _current_argv$[ebp]
  00b47	52		 push	 edx
  00b48	68 00 00 00 00	 push	 OFFSET _recargstring
  00b4d	e8 00 00 00 00	 call	 _warnx
  00b52	83 c4 08	 add	 esp, 8
$LN9@parse_long:

; 383  : 			/*
; 384  : 			 * XXX: GNU sets optopt to val regardless of flag
; 385  : 			 */
; 386  : 			if (long_options[match].flag == NULL)

  00b55	8b 45 ec	 mov	 eax, DWORD PTR _match$[ebp]
  00b58	c1 e0 04	 shl	 eax, 4
  00b5b	8b 4d 10	 mov	 ecx, DWORD PTR _long_options$[ebp]
  00b5e	83 7c 01 08 00	 cmp	 DWORD PTR [ecx+eax+8], 0
  00b63	75 15		 jne	 SHORT $LN8@parse_long

; 387  : 				optopt = long_options[match].val;

  00b65	8b 55 ec	 mov	 edx, DWORD PTR _match$[ebp]
  00b68	c1 e2 04	 shl	 edx, 4
  00b6b	8b 45 10	 mov	 eax, DWORD PTR _long_options$[ebp]
  00b6e	8b 4c 10 0c	 mov	 ecx, DWORD PTR [eax+edx+12]
  00b72	89 0d 00 00 00
	00		 mov	 DWORD PTR _optopt, ecx

; 388  : 			else

  00b78	eb 0a		 jmp	 SHORT $LN7@parse_long
$LN8@parse_long:

; 389  : 				optopt = 0;

  00b7a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _optopt, 0
$LN7@parse_long:

; 390  : 			--optind;

  00b84	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _optind
  00b8a	83 ea 01	 sub	 edx, 1
  00b8d	89 15 00 00 00
	00		 mov	 DWORD PTR _optind, edx

; 391  : 			return (BADARG);

  00b93	8b 45 0c	 mov	 eax, DWORD PTR _options$[ebp]
  00b96	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00b99	83 e8 3a	 sub	 eax, 58			; 0000003aH
  00b9c	f7 d8		 neg	 eax
  00b9e	1b c0		 sbb	 eax, eax
  00ba0	83 e0 05	 and	 eax, 5
  00ba3	83 c0 3a	 add	 eax, 58			; 0000003aH
  00ba6	e9 a2 00 00 00	 jmp	 $LN35@parse_long
$LN10@parse_long:

; 392  : 		}
; 393  : 	} else {			/* unknown option */

  00bab	eb 53		 jmp	 SHORT $LN6@parse_long
$LN20@parse_long:

; 394  : 		if (short_too) {

  00bad	83 7d 18 00	 cmp	 DWORD PTR _short_too$[ebp], 0
  00bb1	74 17		 je	 SHORT $LN5@parse_long

; 395  : 			--optind;

  00bb3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _optind
  00bb9	83 e9 01	 sub	 ecx, 1
  00bbc	89 0d 00 00 00
	00		 mov	 DWORD PTR _optind, ecx

; 396  : 			return (-1);

  00bc2	83 c8 ff	 or	 eax, -1
  00bc5	e9 83 00 00 00	 jmp	 $LN35@parse_long
$LN5@parse_long:

; 397  : 		}
; 398  : 		if (PRINT_ERROR)

  00bca	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _opterr, 0
  00bd1	74 1c		 je	 SHORT $LN4@parse_long
  00bd3	8b 55 0c	 mov	 edx, DWORD PTR _options$[ebp]
  00bd6	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00bd9	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  00bdc	74 11		 je	 SHORT $LN4@parse_long

; 399  : 			warnx(illoptstring, current_argv);

  00bde	8b 4d fc	 mov	 ecx, DWORD PTR _current_argv$[ebp]
  00be1	51		 push	 ecx
  00be2	68 00 00 00 00	 push	 OFFSET _illoptstring
  00be7	e8 00 00 00 00	 call	 _warnx
  00bec	83 c4 08	 add	 esp, 8
$LN4@parse_long:

; 400  : 		optopt = 0;

  00bef	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _optopt, 0

; 401  : 		return (BADCH);

  00bf9	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  00bfe	eb 4d		 jmp	 SHORT $LN35@parse_long
$LN6@parse_long:

; 402  : 	}
; 403  : 	if (idx)

  00c00	83 7d 14 00	 cmp	 DWORD PTR _idx$[ebp], 0
  00c04	74 08		 je	 SHORT $LN3@parse_long

; 404  : 		*idx = match;

  00c06	8b 55 14	 mov	 edx, DWORD PTR _idx$[ebp]
  00c09	8b 45 ec	 mov	 eax, DWORD PTR _match$[ebp]
  00c0c	89 02		 mov	 DWORD PTR [edx], eax
$LN3@parse_long:

; 405  : 	if (long_options[match].flag) {

  00c0e	8b 4d ec	 mov	 ecx, DWORD PTR _match$[ebp]
  00c11	c1 e1 04	 shl	 ecx, 4
  00c14	8b 55 10	 mov	 edx, DWORD PTR _long_options$[ebp]
  00c17	83 7c 0a 08 00	 cmp	 DWORD PTR [edx+ecx+8], 0
  00c1c	74 22		 je	 SHORT $LN2@parse_long

; 406  : 		*long_options[match].flag = long_options[match].val;

  00c1e	8b 45 ec	 mov	 eax, DWORD PTR _match$[ebp]
  00c21	c1 e0 04	 shl	 eax, 4
  00c24	8b 4d ec	 mov	 ecx, DWORD PTR _match$[ebp]
  00c27	c1 e1 04	 shl	 ecx, 4
  00c2a	8b 55 10	 mov	 edx, DWORD PTR _long_options$[ebp]
  00c2d	8b 4c 0a 08	 mov	 ecx, DWORD PTR [edx+ecx+8]
  00c31	8b 55 10	 mov	 edx, DWORD PTR _long_options$[ebp]
  00c34	8b 44 02 0c	 mov	 eax, DWORD PTR [edx+eax+12]
  00c38	89 01		 mov	 DWORD PTR [ecx], eax

; 407  : 		return (0);

  00c3a	33 c0		 xor	 eax, eax
  00c3c	eb 0f		 jmp	 SHORT $LN35@parse_long

; 408  : 	} else

  00c3e	eb 0d		 jmp	 SHORT $LN35@parse_long
$LN2@parse_long:

; 409  : 		return (long_options[match].val);

  00c40	8b 4d ec	 mov	 ecx, DWORD PTR _match$[ebp]
  00c43	c1 e1 04	 shl	 ecx, 4
  00c46	8b 55 10	 mov	 edx, DWORD PTR _long_options$[ebp]
  00c49	8b 44 0a 0c	 mov	 eax, DWORD PTR [edx+ecx+12]
$LN35@parse_long:

; 410  : #undef IDENTICAL_INTERPRETATION
; 411  : }

  00c4d	5e		 pop	 esi
  00c4e	8b e5		 mov	 esp, ebp
  00c50	5d		 pop	 ebp
  00c51	c3		 ret	 0
_parse_long_options ENDP
_TEXT	ENDS
PUBLIC	_getopt_long
; Function compile flags: /Odtp
_TEXT	SEGMENT
_nargc$ = 8						; size = 4
_nargv$ = 12						; size = 4
_options$ = 16						; size = 4
_long_options$ = 20					; size = 4
_idx$ = 24						; size = 4
_getopt_long PROC

; 617  : {

  00c60	55		 push	 ebp
  00c61	8b ec		 mov	 ebp, esp

; 618  : 
; 619  : 	return (getopt_internal(nargc, nargv, options, long_options, idx,
; 620  : 	    FLAG_PERMUTE));

  00c63	6a 01		 push	 1
  00c65	8b 45 18	 mov	 eax, DWORD PTR _idx$[ebp]
  00c68	50		 push	 eax
  00c69	8b 4d 14	 mov	 ecx, DWORD PTR _long_options$[ebp]
  00c6c	51		 push	 ecx
  00c6d	8b 55 10	 mov	 edx, DWORD PTR _options$[ebp]
  00c70	52		 push	 edx
  00c71	8b 45 0c	 mov	 eax, DWORD PTR _nargv$[ebp]
  00c74	50		 push	 eax
  00c75	8b 4d 08	 mov	 ecx, DWORD PTR _nargc$[ebp]
  00c78	51		 push	 ecx
  00c79	e8 00 00 00 00	 call	 _getopt_internal
  00c7e	83 c4 18	 add	 esp, 24			; 00000018H

; 621  : }

  00c81	5d		 pop	 ebp
  00c82	c3		 ret	 0
_getopt_long ENDP
_TEXT	ENDS
PUBLIC	_getopt_long_only
; Function compile flags: /Odtp
_TEXT	SEGMENT
_nargc$ = 8						; size = 4
_nargv$ = 12						; size = 4
_options$ = 16						; size = 4
_long_options$ = 20					; size = 4
_idx$ = 24						; size = 4
_getopt_long_only PROC

; 630  : {

  00c90	55		 push	 ebp
  00c91	8b ec		 mov	 ebp, esp

; 631  : 
; 632  : 	return (getopt_internal(nargc, nargv, options, long_options, idx,
; 633  : 	    FLAG_PERMUTE|FLAG_LONGONLY));

  00c93	6a 05		 push	 5
  00c95	8b 45 18	 mov	 eax, DWORD PTR _idx$[ebp]
  00c98	50		 push	 eax
  00c99	8b 4d 14	 mov	 ecx, DWORD PTR _long_options$[ebp]
  00c9c	51		 push	 ecx
  00c9d	8b 55 10	 mov	 edx, DWORD PTR _options$[ebp]
  00ca0	52		 push	 edx
  00ca1	8b 45 0c	 mov	 eax, DWORD PTR _nargv$[ebp]
  00ca4	50		 push	 eax
  00ca5	8b 4d 08	 mov	 ecx, DWORD PTR _nargc$[ebp]
  00ca8	51		 push	 ecx
  00ca9	e8 00 00 00 00	 call	 _getopt_internal
  00cae	83 c4 18	 add	 esp, 24			; 00000018H

; 634  : }

  00cb1	5d		 pop	 ebp
  00cb2	c3		 ret	 0
_getopt_long_only ENDP
_TEXT	ENDS
PUBLIC	_atl_fgetsp
EXTRN	_ungetc:PROC
EXTRN	_getc:PROC
; Function compile flags: /Odtp
; File c:\a15\facultate\forth\atlast-1.2\atlast.c
_TEXT	SEGMENT
_ch$ = -8						; size = 4
_i$ = -4						; size = 4
_s$ = 8							; size = 4
_n$ = 12						; size = 4
_stream$ = 16						; size = 4
_atl_fgetsp PROC

; 500  : {

  00cc0	55		 push	 ebp
  00cc1	8b ec		 mov	 ebp, esp
  00cc3	83 ec 08	 sub	 esp, 8

; 501  : 	int i = 0, ch;

  00cc6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN9@atl_fgetsp:

; 502  : 
; 503  : 	while (True) {

  00ccd	b8 01 00 00 00	 mov	 eax, 1
  00cd2	85 c0		 test	 eax, eax
  00cd4	0f 84 a2 00 00
	00		 je	 $LN8@atl_fgetsp

; 504  : 	   ch = getc(stream);

  00cda	8b 4d 10	 mov	 ecx, DWORD PTR _stream$[ebp]
  00cdd	51		 push	 ecx
  00cde	e8 00 00 00 00	 call	 _getc
  00ce3	83 c4 04	 add	 esp, 4
  00ce6	89 45 f8	 mov	 DWORD PTR _ch$[ebp], eax

; 505  : 	   if (ch == EOF) {

  00ce9	83 7d f8 ff	 cmp	 DWORD PTR _ch$[ebp], -1
  00ced	75 0f		 jne	 SHORT $LN7@atl_fgetsp

; 506  : 	      if (i == 0)

  00cef	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  00cf3	75 07		 jne	 SHORT $LN6@atl_fgetsp

; 507  : 		 return NULL;

  00cf5	33 c0		 xor	 eax, eax
  00cf7	e9 8c 00 00 00	 jmp	 $LN10@atl_fgetsp
$LN6@atl_fgetsp:

; 508  : 	      break;

  00cfc	eb 7e		 jmp	 SHORT $LN8@atl_fgetsp
$LN7@atl_fgetsp:

; 509  : 	   }
; 510  :            if (ch == '\r') {

  00cfe	83 7d f8 0d	 cmp	 DWORD PTR _ch$[ebp], 13	; 0000000dH
  00d02	75 27		 jne	 SHORT $LN5@atl_fgetsp

; 511  : 	      ch = getc(stream);

  00d04	8b 55 10	 mov	 edx, DWORD PTR _stream$[ebp]
  00d07	52		 push	 edx
  00d08	e8 00 00 00 00	 call	 _getc
  00d0d	83 c4 04	 add	 esp, 4
  00d10	89 45 f8	 mov	 DWORD PTR _ch$[ebp], eax

; 512  :               if (ch != '\n')

  00d13	83 7d f8 0a	 cmp	 DWORD PTR _ch$[ebp], 10	; 0000000aH
  00d17	74 10		 je	 SHORT $LN4@atl_fgetsp

; 513  : 		 V ungetc(ch, stream);

  00d19	8b 45 10	 mov	 eax, DWORD PTR _stream$[ebp]
  00d1c	50		 push	 eax
  00d1d	8b 4d f8	 mov	 ecx, DWORD PTR _ch$[ebp]
  00d20	51		 push	 ecx
  00d21	e8 00 00 00 00	 call	 _ungetc
  00d26	83 c4 08	 add	 esp, 8
$LN4@atl_fgetsp:

; 514  : 	      break;

  00d29	eb 51		 jmp	 SHORT $LN8@atl_fgetsp
$LN5@atl_fgetsp:

; 515  : 	   }
; 516  :            if (ch == '\n') {

  00d2b	83 7d f8 0a	 cmp	 DWORD PTR _ch$[ebp], 10	; 0000000aH
  00d2f	75 27		 jne	 SHORT $LN3@atl_fgetsp

; 517  : 	      ch = getc(stream);

  00d31	8b 55 10	 mov	 edx, DWORD PTR _stream$[ebp]
  00d34	52		 push	 edx
  00d35	e8 00 00 00 00	 call	 _getc
  00d3a	83 c4 04	 add	 esp, 4
  00d3d	89 45 f8	 mov	 DWORD PTR _ch$[ebp], eax

; 518  :               if (ch != '\r')

  00d40	83 7d f8 0d	 cmp	 DWORD PTR _ch$[ebp], 13	; 0000000dH
  00d44	74 10		 je	 SHORT $LN2@atl_fgetsp

; 519  : 		 V ungetc(ch, stream);

  00d46	8b 45 10	 mov	 eax, DWORD PTR _stream$[ebp]
  00d49	50		 push	 eax
  00d4a	8b 4d f8	 mov	 ecx, DWORD PTR _ch$[ebp]
  00d4d	51		 push	 ecx
  00d4e	e8 00 00 00 00	 call	 _ungetc
  00d53	83 c4 08	 add	 esp, 8
$LN2@atl_fgetsp:

; 520  : 	      break;

  00d56	eb 24		 jmp	 SHORT $LN8@atl_fgetsp
$LN3@atl_fgetsp:

; 521  : 	   }
; 522  : 	   if (i < (n - 1))

  00d58	8b 55 0c	 mov	 edx, DWORD PTR _n$[ebp]
  00d5b	83 ea 01	 sub	 edx, 1
  00d5e	39 55 fc	 cmp	 DWORD PTR _i$[ebp], edx
  00d61	7d 14		 jge	 SHORT $LN1@atl_fgetsp

; 523  : 	      s[i++] = ch;

  00d63	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00d66	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00d69	8a 4d f8	 mov	 cl, BYTE PTR _ch$[ebp]
  00d6c	88 08		 mov	 BYTE PTR [eax], cl
  00d6e	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00d71	83 c2 01	 add	 edx, 1
  00d74	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN1@atl_fgetsp:

; 524  : 	}

  00d77	e9 51 ff ff ff	 jmp	 $LN9@atl_fgetsp
$LN8@atl_fgetsp:

; 525  : 	s[i] = EOS;

  00d7c	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00d7f	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00d82	c6 00 00	 mov	 BYTE PTR [eax], 0

; 526  : 	return s;

  00d85	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
$LN10@atl_fgetsp:

; 527  : }

  00d88	8b e5		 mov	 esp, ebp
  00d8a	5d		 pop	 ebp
  00d8b	c3		 ret	 0
_atl_fgetsp ENDP
_TEXT	ENDS
EXTRN	_printf:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_atl_memstat PROC

; 534  : {

  00d90	55		 push	 ebp
  00d91	8b ec		 mov	 ebp, esp

; 535  :     static char fmt[] = "   %-12s %6ld    %6ld    %6ld       %3ld\n";
; 536  : 
; 537  :     V printf("\n             Memory Usage Summary\n\n");

  00d93	68 00 00 00 00	 push	 OFFSET $SG83019
  00d98	e8 00 00 00 00	 call	 _printf
  00d9d	83 c4 04	 add	 esp, 4

; 538  :     V printf("                 Current   Maximum    Items     Percent\n");

  00da0	68 00 00 00 00	 push	 OFFSET $SG83021
  00da5	e8 00 00 00 00	 call	 _printf
  00daa	83 c4 04	 add	 esp, 4

; 539  :     V printf("  Memory Area     usage     used    allocated   in use \n");

  00dad	68 00 00 00 00	 push	 OFFSET $SG83023
  00db2	e8 00 00 00 00	 call	 _printf
  00db7	83 c4 04	 add	 esp, 4

; 540  : 
; 541  :     V printf(fmt, "Stack",
; 542  : 	((long) (stk - stack)),
; 543  : 	((long) (stackmax - stack)),
; 544  : 	atl_stklen,
; 545  : 	(100L * (stk - stack)) / atl_stklen);

  00dba	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  00dbf	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  00dc5	c1 f8 02	 sar	 eax, 2
  00dc8	6b c0 64	 imul	 eax, 100		; 00000064H
  00dcb	99		 cdq
  00dcc	f7 3d 00 00 00
	00		 idiv	 DWORD PTR _atl_stklen
  00dd2	50		 push	 eax
  00dd3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_stklen
  00dd8	50		 push	 eax
  00dd9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sx
  00ddf	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _atl__sk
  00de5	c1 f9 02	 sar	 ecx, 2
  00de8	51		 push	 ecx
  00de9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  00def	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _atl__sk
  00df5	c1 fa 02	 sar	 edx, 2
  00df8	52		 push	 edx
  00df9	68 00 00 00 00	 push	 OFFSET $SG83027
  00dfe	68 00 00 00 00	 push	 OFFSET ?fmt@?1??atl_memstat@@9@9
  00e03	e8 00 00 00 00	 call	 _printf
  00e08	83 c4 18	 add	 esp, 24			; 00000018H

; 546  :     V printf(fmt, "Return stack",
; 547  : 	((long) (rstk - rstack)),
; 548  : 	((long) (rstackmax - rstack)),
; 549  : 	atl_rstklen,
; 550  : 	(100L * (rstk - rstack)) / atl_rstklen);

  00e0b	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__rp
  00e10	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__rk
  00e16	c1 f8 02	 sar	 eax, 2
  00e19	6b c0 64	 imul	 eax, 100		; 00000064H
  00e1c	99		 cdq
  00e1d	f7 3d 00 00 00
	00		 idiv	 DWORD PTR _atl_rstklen
  00e23	50		 push	 eax
  00e24	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_rstklen
  00e29	50		 push	 eax
  00e2a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__rx
  00e30	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _atl__rk
  00e36	c1 f9 02	 sar	 ecx, 2
  00e39	51		 push	 ecx
  00e3a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__rp
  00e40	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _atl__rk
  00e46	c1 fa 02	 sar	 edx, 2
  00e49	52		 push	 edx
  00e4a	68 00 00 00 00	 push	 OFFSET $SG83031
  00e4f	68 00 00 00 00	 push	 OFFSET ?fmt@?1??atl_memstat@@9@9
  00e54	e8 00 00 00 00	 call	 _printf
  00e59	83 c4 18	 add	 esp, 24			; 00000018H

; 551  :     V printf(fmt, "Heap",
; 552  : 	((long) (hptr - heap)),
; 553  : 	((long) (heapmax - heap)),
; 554  : 	atl_heaplen,
; 555  : 	(100L * (hptr - heap)) / atl_heaplen);

  00e5c	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  00e61	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__hb
  00e67	c1 f8 02	 sar	 eax, 2
  00e6a	6b c0 64	 imul	 eax, 100		; 00000064H
  00e6d	99		 cdq
  00e6e	f7 3d 00 00 00
	00		 idiv	 DWORD PTR _atl_heaplen
  00e74	50		 push	 eax
  00e75	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_heaplen
  00e7a	50		 push	 eax
  00e7b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hx
  00e81	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _atl__hb
  00e87	c1 f9 02	 sar	 ecx, 2
  00e8a	51		 push	 ecx
  00e8b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  00e91	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _atl__hb
  00e97	c1 fa 02	 sar	 edx, 2
  00e9a	52		 push	 edx
  00e9b	68 00 00 00 00	 push	 OFFSET $SG83035
  00ea0	68 00 00 00 00	 push	 OFFSET ?fmt@?1??atl_memstat@@9@9
  00ea5	e8 00 00 00 00	 call	 _printf
  00eaa	83 c4 18	 add	 esp, 24			; 00000018H

; 556  : }

  00ead	5d		 pop	 ebp
  00eae	c3		 ret	 0
_atl_memstat ENDP
_TEXT	ENDS
PUBLIC	_atl__Esu
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_plus	PROC

; 607  : {

  00eb0	55		 push	 ebp
  00eb1	8b ec		 mov	 ebp, esp

; 608  :     Sl(2);

  00eb3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  00eb8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  00ebe	c1 f8 02	 sar	 eax, 2
  00ec1	83 f8 02	 cmp	 eax, 2
  00ec4	7d 07		 jge	 SHORT $LN1@P_plus
  00ec6	e8 00 00 00 00	 call	 _atl__Esu
  00ecb	eb 29		 jmp	 SHORT $LN2@P_plus
$LN1@P_plus:

; 609  : /* printf("PLUS %lx + %lx = %lx\n", S1, S0, (S1 + S0)); */
; 610  :     S1 += S0;

  00ecd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  00ed3	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  00ed6	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  00edb	03 50 fc	 add	 edx, DWORD PTR [eax-4]
  00ede	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  00ee4	89 51 f8	 mov	 DWORD PTR [ecx-8], edx

; 611  :     Pop;

  00ee7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  00eed	83 ea 04	 sub	 edx, 4
  00ef0	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN2@P_plus:

; 612  : }

  00ef6	5d		 pop	 ebp
  00ef7	c3		 ret	 0
_P_plus	ENDP
; Function compile flags: /Odtp
_P_minus PROC

; 615  : {

  00f00	55		 push	 ebp
  00f01	8b ec		 mov	 ebp, esp

; 616  :     Sl(2);

  00f03	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  00f08	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  00f0e	c1 f8 02	 sar	 eax, 2
  00f11	83 f8 02	 cmp	 eax, 2
  00f14	7d 07		 jge	 SHORT $LN1@P_minus
  00f16	e8 00 00 00 00	 call	 _atl__Esu
  00f1b	eb 2a		 jmp	 SHORT $LN2@P_minus
$LN1@P_minus:

; 617  :     S1 -= S0;

  00f1d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  00f23	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  00f29	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00f2c	2b 42 fc	 sub	 eax, DWORD PTR [edx-4]
  00f2f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  00f35	89 41 f8	 mov	 DWORD PTR [ecx-8], eax

; 618  :     Pop;

  00f38	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  00f3e	83 ea 04	 sub	 edx, 4
  00f41	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN2@P_minus:

; 619  : }

  00f47	5d		 pop	 ebp
  00f48	c3		 ret	 0
_P_minus ENDP
; Function compile flags: /Odtp
_P_times PROC

; 622  : {

  00f50	55		 push	 ebp
  00f51	8b ec		 mov	 ebp, esp

; 623  :     Sl(2);

  00f53	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  00f58	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  00f5e	c1 f8 02	 sar	 eax, 2
  00f61	83 f8 02	 cmp	 eax, 2
  00f64	7d 07		 jge	 SHORT $LN1@P_times
  00f66	e8 00 00 00 00	 call	 _atl__Esu
  00f6b	eb 2b		 jmp	 SHORT $LN2@P_times
$LN1@P_times:

; 624  :     S1 *= S0;

  00f6d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  00f73	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  00f79	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  00f7c	0f af 42 fc	 imul	 eax, DWORD PTR [edx-4]
  00f80	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  00f86	89 41 f8	 mov	 DWORD PTR [ecx-8], eax

; 625  :     Pop;

  00f89	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  00f8f	83 ea 04	 sub	 edx, 4
  00f92	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN2@P_times:

; 626  : }

  00f98	5d		 pop	 ebp
  00f99	c3		 ret	 0
_P_times ENDP
; Function compile flags: /Odtp
_P_div	PROC

; 629  : {

  00fa0	55		 push	 ebp
  00fa1	8b ec		 mov	 ebp, esp

; 630  :     Sl(2);

  00fa3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  00fa8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  00fae	c1 f8 02	 sar	 eax, 2
  00fb1	83 f8 02	 cmp	 eax, 2
  00fb4	7d 07		 jge	 SHORT $LN2@P_div
  00fb6	e8 00 00 00 00	 call	 _atl__Esu
  00fbb	eb 3c		 jmp	 SHORT $LN3@P_div
$LN2@P_div:

; 631  : #ifndef NOMEMCHECK
; 632  :     if (S0 == 0) {

  00fbd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  00fc3	83 79 fc 00	 cmp	 DWORD PTR [ecx-4], 0
  00fc7	75 07		 jne	 SHORT $LN1@P_div

; 633  : 	divzero();

  00fc9	e8 00 00 00 00	 call	 _divzero

; 634  : 	return;

  00fce	eb 29		 jmp	 SHORT $LN3@P_div
$LN1@P_div:

; 635  :     }
; 636  : #endif /* NOMEMCHECK */
; 637  :     S1 /= S0;

  00fd0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  00fd6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  00fdc	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  00fdf	99		 cdq
  00fe0	f7 79 fc	 idiv	 DWORD PTR [ecx-4]
  00fe3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  00fe9	89 42 f8	 mov	 DWORD PTR [edx-8], eax

; 638  :     Pop;

  00fec	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  00ff1	83 e8 04	 sub	 eax, 4
  00ff4	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN3@P_div:

; 639  : }

  00ff9	5d		 pop	 ebp
  00ffa	c3		 ret	 0
_P_div	ENDP
; Function compile flags: /Odtp
_P_mod	PROC

; 642  : {

  01000	55		 push	 ebp
  01001	8b ec		 mov	 ebp, esp

; 643  :     Sl(2);

  01003	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01008	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0100e	c1 f8 02	 sar	 eax, 2
  01011	83 f8 02	 cmp	 eax, 2
  01014	7d 07		 jge	 SHORT $LN2@P_mod
  01016	e8 00 00 00 00	 call	 _atl__Esu
  0101b	eb 3d		 jmp	 SHORT $LN3@P_mod
$LN2@P_mod:

; 644  : #ifndef NOMEMCHECK
; 645  :     if (S0 == 0) {

  0101d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01023	83 79 fc 00	 cmp	 DWORD PTR [ecx-4], 0
  01027	75 07		 jne	 SHORT $LN1@P_mod

; 646  : 	divzero();

  01029	e8 00 00 00 00	 call	 _divzero

; 647  : 	return;

  0102e	eb 2a		 jmp	 SHORT $LN3@P_mod
$LN1@P_mod:

; 648  :     }
; 649  : #endif /* NOMEMCHECK */
; 650  :     S1 %= S0;

  01030	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  01036	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0103c	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  0103f	99		 cdq
  01040	f7 79 fc	 idiv	 DWORD PTR [ecx-4]
  01043	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01048	89 50 f8	 mov	 DWORD PTR [eax-8], edx

; 651  :     Pop;

  0104b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01051	83 e9 04	 sub	 ecx, 4
  01054	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN3@P_mod:

; 652  : }

  0105a	5d		 pop	 ebp
  0105b	c3		 ret	 0
_P_mod	ENDP
; Function compile flags: /Odtp
_quot$ = -4						; size = 4
_P_divmod PROC

; 655  : {

  01060	55		 push	 ebp
  01061	8b ec		 mov	 ebp, esp
  01063	51		 push	 ecx

; 656  :     stackitem quot;
; 657  : 
; 658  :     Sl(2);

  01064	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01069	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0106f	c1 f8 02	 sar	 eax, 2
  01072	83 f8 02	 cmp	 eax, 2
  01075	7d 07		 jge	 SHORT $LN2@P_divmod
  01077	e8 00 00 00 00	 call	 _atl__Esu
  0107c	eb 50		 jmp	 SHORT $LN3@P_divmod
$LN2@P_divmod:

; 659  : #ifndef NOMEMCHECK
; 660  :     if (S0 == 0) {

  0107e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01084	83 79 fc 00	 cmp	 DWORD PTR [ecx-4], 0
  01088	75 07		 jne	 SHORT $LN1@P_divmod

; 661  : 	divzero();

  0108a	e8 00 00 00 00	 call	 _divzero

; 662  : 	return;

  0108f	eb 3d		 jmp	 SHORT $LN3@P_divmod
$LN1@P_divmod:

; 663  :     }
; 664  : #endif /* NOMEMCHECK */
; 665  :     quot = S1 / S0;

  01091	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  01097	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0109d	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  010a0	99		 cdq
  010a1	f7 79 fc	 idiv	 DWORD PTR [ecx-4]
  010a4	89 45 fc	 mov	 DWORD PTR _quot$[ebp], eax

; 666  :     S1 %= S0;

  010a7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  010ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  010b3	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  010b6	99		 cdq
  010b7	f7 79 fc	 idiv	 DWORD PTR [ecx-4]
  010ba	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  010bf	89 50 f8	 mov	 DWORD PTR [eax-8], edx

; 667  :     S0 = quot;

  010c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  010c8	8b 55 fc	 mov	 edx, DWORD PTR _quot$[ebp]
  010cb	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN3@P_divmod:

; 668  : }

  010ce	8b e5		 mov	 esp, ebp
  010d0	5d		 pop	 ebp
  010d1	c3		 ret	 0
_P_divmod ENDP
; Function compile flags: /Odtp
tv73 = -4						; size = 4
_P_min	PROC

; 671  : {

  010e0	55		 push	 ebp
  010e1	8b ec		 mov	 ebp, esp
  010e3	51		 push	 ecx

; 672  :     Sl(2);

  010e4	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  010e9	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  010ef	c1 f8 02	 sar	 eax, 2
  010f2	83 f8 02	 cmp	 eax, 2
  010f5	7d 07		 jge	 SHORT $LN1@P_min
  010f7	e8 00 00 00 00	 call	 _atl__Esu
  010fc	eb 48		 jmp	 SHORT $LN2@P_min
$LN1@P_min:

; 673  :     S1 = min(S1, S0);

  010fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01104	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0110a	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  0110d	3b 42 fc	 cmp	 eax, DWORD PTR [edx-4]
  01110	7f 0e		 jg	 SHORT $LN4@P_min
  01112	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01118	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  0111b	89 55 fc	 mov	 DWORD PTR tv73[ebp], edx
  0111e	eb 0b		 jmp	 SHORT $LN5@P_min
$LN4@P_min:
  01120	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01125	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  01128	89 4d fc	 mov	 DWORD PTR tv73[ebp], ecx
$LN5@P_min:
  0112b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  01131	8b 45 fc	 mov	 eax, DWORD PTR tv73[ebp]
  01134	89 42 f8	 mov	 DWORD PTR [edx-8], eax

; 674  :     Pop;

  01137	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0113d	83 e9 04	 sub	 ecx, 4
  01140	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN2@P_min:

; 675  : }

  01146	8b e5		 mov	 esp, ebp
  01148	5d		 pop	 ebp
  01149	c3		 ret	 0
_P_min	ENDP
; Function compile flags: /Odtp
tv73 = -4						; size = 4
_P_max	PROC

; 678  : {

  01150	55		 push	 ebp
  01151	8b ec		 mov	 ebp, esp
  01153	51		 push	 ecx

; 679  :     Sl(2);

  01154	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01159	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0115f	c1 f8 02	 sar	 eax, 2
  01162	83 f8 02	 cmp	 eax, 2
  01165	7d 07		 jge	 SHORT $LN1@P_max
  01167	e8 00 00 00 00	 call	 _atl__Esu
  0116c	eb 48		 jmp	 SHORT $LN2@P_max
$LN1@P_max:

; 680  :     S1 = max(S1, S0);

  0116e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01174	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0117a	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  0117d	3b 42 fc	 cmp	 eax, DWORD PTR [edx-4]
  01180	7e 0e		 jle	 SHORT $LN4@P_max
  01182	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01188	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  0118b	89 55 fc	 mov	 DWORD PTR tv73[ebp], edx
  0118e	eb 0b		 jmp	 SHORT $LN5@P_max
$LN4@P_max:
  01190	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01195	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  01198	89 4d fc	 mov	 DWORD PTR tv73[ebp], ecx
$LN5@P_max:
  0119b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  011a1	8b 45 fc	 mov	 eax, DWORD PTR tv73[ebp]
  011a4	89 42 f8	 mov	 DWORD PTR [edx-8], eax

; 681  :     Pop;

  011a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  011ad	83 e9 04	 sub	 ecx, 4
  011b0	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN2@P_max:

; 682  : }

  011b6	8b e5		 mov	 esp, ebp
  011b8	5d		 pop	 ebp
  011b9	c3		 ret	 0
_P_max	ENDP
; Function compile flags: /Odtp
_P_neg	PROC

; 685  : {

  011c0	55		 push	 ebp
  011c1	8b ec		 mov	 ebp, esp

; 686  :     Sl(1);

  011c3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  011c8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  011ce	c1 f8 02	 sar	 eax, 2
  011d1	83 f8 01	 cmp	 eax, 1
  011d4	7d 07		 jge	 SHORT $LN1@P_neg
  011d6	e8 00 00 00 00	 call	 _atl__Esu
  011db	eb 13		 jmp	 SHORT $LN2@P_neg
$LN1@P_neg:

; 687  :     S0 = - S0;

  011dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  011e3	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  011e6	f7 da		 neg	 edx
  011e8	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  011ed	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN2@P_neg:

; 688  : }

  011f0	5d		 pop	 ebp
  011f1	c3		 ret	 0
_P_neg	ENDP
; Function compile flags: /Odtp
tv73 = -4						; size = 4
_P_abs	PROC

; 691  : {

  01200	55		 push	 ebp
  01201	8b ec		 mov	 ebp, esp
  01203	51		 push	 ecx

; 692  :     Sl(1);

  01204	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01209	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0120f	c1 f8 02	 sar	 eax, 2
  01212	83 f8 01	 cmp	 eax, 1
  01215	7d 07		 jge	 SHORT $LN1@P_abs
  01217	e8 00 00 00 00	 call	 _atl__Esu
  0121c	eb 33		 jmp	 SHORT $LN2@P_abs
$LN1@P_abs:

; 693  :     S0 = abs(S0);

  0121e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01224	83 79 fc 00	 cmp	 DWORD PTR [ecx-4], 0
  01228	7d 10		 jge	 SHORT $LN4@P_abs
  0122a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  01230	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  01233	f7 d8		 neg	 eax
  01235	89 45 fc	 mov	 DWORD PTR tv73[ebp], eax
  01238	eb 0c		 jmp	 SHORT $LN5@P_abs
$LN4@P_abs:
  0123a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01240	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  01243	89 55 fc	 mov	 DWORD PTR tv73[ebp], edx
$LN5@P_abs:
  01246	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0124b	8b 4d fc	 mov	 ecx, DWORD PTR tv73[ebp]
  0124e	89 48 fc	 mov	 DWORD PTR [eax-4], ecx
$LN2@P_abs:

; 694  : }

  01251	8b e5		 mov	 esp, ebp
  01253	5d		 pop	 ebp
  01254	c3		 ret	 0
_P_abs	ENDP
; Function compile flags: /Odtp
_P_equal PROC

; 697  : {

  01260	55		 push	 ebp
  01261	8b ec		 mov	 ebp, esp

; 698  :     Sl(2);

  01263	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01268	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0126e	c1 f8 02	 sar	 eax, 2
  01271	83 f8 02	 cmp	 eax, 2
  01274	7d 07		 jge	 SHORT $LN1@P_equal
  01276	e8 00 00 00 00	 call	 _atl__Esu
  0127b	eb 33		 jmp	 SHORT $LN2@P_equal
$LN1@P_equal:

; 699  :     S1 = (S1 == S0) ? Truth : Falsity;

  0127d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01283	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  01289	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  0128c	2b 42 fc	 sub	 eax, DWORD PTR [edx-4]
  0128f	f7 d8		 neg	 eax
  01291	1b c0		 sbb	 eax, eax
  01293	f7 d8		 neg	 eax
  01295	83 e8 01	 sub	 eax, 1
  01298	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0129e	89 41 f8	 mov	 DWORD PTR [ecx-8], eax

; 700  :     Pop;

  012a1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  012a7	83 ea 04	 sub	 edx, 4
  012aa	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN2@P_equal:

; 701  : }

  012b0	5d		 pop	 ebp
  012b1	c3		 ret	 0
_P_equal ENDP
; Function compile flags: /Odtp
_P_unequal PROC

; 704  : {

  012c0	55		 push	 ebp
  012c1	8b ec		 mov	 ebp, esp

; 705  :     Sl(2);

  012c3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  012c8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  012ce	c1 f8 02	 sar	 eax, 2
  012d1	83 f8 02	 cmp	 eax, 2
  012d4	7d 07		 jge	 SHORT $LN1@P_unequal
  012d6	e8 00 00 00 00	 call	 _atl__Esu
  012db	eb 2e		 jmp	 SHORT $LN2@P_unequal
$LN1@P_unequal:

; 706  :     S1 = (S1 != S0) ? Truth : Falsity;

  012dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  012e3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  012e9	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  012ec	2b 42 fc	 sub	 eax, DWORD PTR [edx-4]
  012ef	f7 d8		 neg	 eax
  012f1	1b c0		 sbb	 eax, eax
  012f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  012f9	89 41 f8	 mov	 DWORD PTR [ecx-8], eax

; 707  :     Pop;

  012fc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  01302	83 ea 04	 sub	 edx, 4
  01305	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN2@P_unequal:

; 708  : }

  0130b	5d		 pop	 ebp
  0130c	c3		 ret	 0
_P_unequal ENDP
; Function compile flags: /Odtp
_P_gtr	PROC

; 711  : {

  01310	55		 push	 ebp
  01311	8b ec		 mov	 ebp, esp

; 712  :     Sl(2);

  01313	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01318	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0131e	c1 f8 02	 sar	 eax, 2
  01321	83 f8 02	 cmp	 eax, 2
  01324	7d 07		 jge	 SHORT $LN1@P_gtr
  01326	e8 00 00 00 00	 call	 _atl__Esu
  0132b	eb 30		 jmp	 SHORT $LN2@P_gtr
$LN1@P_gtr:

; 713  :     S1 = (S1 > S0) ? Truth : Falsity;

  0132d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01333	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  01339	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  0133c	33 c9		 xor	 ecx, ecx
  0133e	3b 42 fc	 cmp	 eax, DWORD PTR [edx-4]
  01341	0f 9e c1	 setle	 cl
  01344	83 e9 01	 sub	 ecx, 1
  01347	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0134d	89 4a f8	 mov	 DWORD PTR [edx-8], ecx

; 714  :     Pop;

  01350	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01355	83 e8 04	 sub	 eax, 4
  01358	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN2@P_gtr:

; 715  : }

  0135d	5d		 pop	 ebp
  0135e	c3		 ret	 0
_P_gtr	ENDP
; Function compile flags: /Odtp
_P_lss	PROC

; 718  : {

  01360	55		 push	 ebp
  01361	8b ec		 mov	 ebp, esp

; 719  :     Sl(2);

  01363	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01368	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0136e	c1 f8 02	 sar	 eax, 2
  01371	83 f8 02	 cmp	 eax, 2
  01374	7d 07		 jge	 SHORT $LN1@P_lss
  01376	e8 00 00 00 00	 call	 _atl__Esu
  0137b	eb 30		 jmp	 SHORT $LN2@P_lss
$LN1@P_lss:

; 720  :     S1 = (S1 < S0) ? Truth : Falsity;

  0137d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01383	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  01389	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  0138c	33 c9		 xor	 ecx, ecx
  0138e	3b 42 fc	 cmp	 eax, DWORD PTR [edx-4]
  01391	0f 9d c1	 setge	 cl
  01394	83 e9 01	 sub	 ecx, 1
  01397	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0139d	89 4a f8	 mov	 DWORD PTR [edx-8], ecx

; 721  :     Pop;

  013a0	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  013a5	83 e8 04	 sub	 eax, 4
  013a8	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN2@P_lss:

; 722  : }

  013ad	5d		 pop	 ebp
  013ae	c3		 ret	 0
_P_lss	ENDP
; Function compile flags: /Odtp
_P_geq	PROC

; 725  : {

  013b0	55		 push	 ebp
  013b1	8b ec		 mov	 ebp, esp

; 726  :     Sl(2);

  013b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  013b8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  013be	c1 f8 02	 sar	 eax, 2
  013c1	83 f8 02	 cmp	 eax, 2
  013c4	7d 07		 jge	 SHORT $LN1@P_geq
  013c6	e8 00 00 00 00	 call	 _atl__Esu
  013cb	eb 30		 jmp	 SHORT $LN2@P_geq
$LN1@P_geq:

; 727  :     S1 = (S1 >= S0) ? Truth : Falsity;

  013cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  013d3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  013d9	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  013dc	33 c9		 xor	 ecx, ecx
  013de	3b 42 fc	 cmp	 eax, DWORD PTR [edx-4]
  013e1	0f 9c c1	 setl	 cl
  013e4	83 e9 01	 sub	 ecx, 1
  013e7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  013ed	89 4a f8	 mov	 DWORD PTR [edx-8], ecx

; 728  :     Pop;

  013f0	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  013f5	83 e8 04	 sub	 eax, 4
  013f8	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN2@P_geq:

; 729  : }

  013fd	5d		 pop	 ebp
  013fe	c3		 ret	 0
_P_geq	ENDP
; Function compile flags: /Odtp
_P_leq	PROC

; 732  : {

  01400	55		 push	 ebp
  01401	8b ec		 mov	 ebp, esp

; 733  :     Sl(2);

  01403	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01408	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0140e	c1 f8 02	 sar	 eax, 2
  01411	83 f8 02	 cmp	 eax, 2
  01414	7d 07		 jge	 SHORT $LN1@P_leq
  01416	e8 00 00 00 00	 call	 _atl__Esu
  0141b	eb 30		 jmp	 SHORT $LN2@P_leq
$LN1@P_leq:

; 734  :     S1 = (S1 <= S0) ? Truth : Falsity;

  0141d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01423	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  01429	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  0142c	33 c9		 xor	 ecx, ecx
  0142e	3b 42 fc	 cmp	 eax, DWORD PTR [edx-4]
  01431	0f 9f c1	 setg	 cl
  01434	83 e9 01	 sub	 ecx, 1
  01437	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0143d	89 4a f8	 mov	 DWORD PTR [edx-8], ecx

; 735  :     Pop;

  01440	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01445	83 e8 04	 sub	 eax, 4
  01448	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN2@P_leq:

; 736  : }

  0144d	5d		 pop	 ebp
  0144e	c3		 ret	 0
_P_leq	ENDP
; Function compile flags: /Odtp
_P_and	PROC

; 739  : {

  01450	55		 push	 ebp
  01451	8b ec		 mov	 ebp, esp

; 740  :     Sl(2);

  01453	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01458	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0145e	c1 f8 02	 sar	 eax, 2
  01461	83 f8 02	 cmp	 eax, 2
  01464	7d 07		 jge	 SHORT $LN1@P_and
  01466	e8 00 00 00 00	 call	 _atl__Esu
  0146b	eb 2a		 jmp	 SHORT $LN2@P_and
$LN1@P_and:

; 741  : /* printf("AND %lx & %lx = %lx\n", S1, S0, (S1 & S0)); */
; 742  :     S1 &= S0;

  0146d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01473	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  01479	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  0147c	23 42 fc	 and	 eax, DWORD PTR [edx-4]
  0147f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01485	89 41 f8	 mov	 DWORD PTR [ecx-8], eax

; 743  :     Pop;

  01488	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0148e	83 ea 04	 sub	 edx, 4
  01491	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN2@P_and:

; 744  : }

  01497	5d		 pop	 ebp
  01498	c3		 ret	 0
_P_and	ENDP
; Function compile flags: /Odtp
_P_or	PROC

; 747  : {

  014a0	55		 push	 ebp
  014a1	8b ec		 mov	 ebp, esp

; 748  :     Sl(2);

  014a3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  014a8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  014ae	c1 f8 02	 sar	 eax, 2
  014b1	83 f8 02	 cmp	 eax, 2
  014b4	7d 07		 jge	 SHORT $LN1@P_or
  014b6	e8 00 00 00 00	 call	 _atl__Esu
  014bb	eb 2a		 jmp	 SHORT $LN2@P_or
$LN1@P_or:

; 749  :     S1 |= S0;

  014bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  014c3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  014c9	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  014cc	0b 42 fc	 or	 eax, DWORD PTR [edx-4]
  014cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  014d5	89 41 f8	 mov	 DWORD PTR [ecx-8], eax

; 750  :     Pop;

  014d8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  014de	83 ea 04	 sub	 edx, 4
  014e1	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN2@P_or:

; 751  : }

  014e7	5d		 pop	 ebp
  014e8	c3		 ret	 0
_P_or	ENDP
; Function compile flags: /Odtp
_P_xor	PROC

; 754  : {

  014f0	55		 push	 ebp
  014f1	8b ec		 mov	 ebp, esp

; 755  :     Sl(2);

  014f3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  014f8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  014fe	c1 f8 02	 sar	 eax, 2
  01501	83 f8 02	 cmp	 eax, 2
  01504	7d 07		 jge	 SHORT $LN1@P_xor
  01506	e8 00 00 00 00	 call	 _atl__Esu
  0150b	eb 2a		 jmp	 SHORT $LN2@P_xor
$LN1@P_xor:

; 756  :     S1 ^= S0;

  0150d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01513	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  01519	8b 41 f8	 mov	 eax, DWORD PTR [ecx-8]
  0151c	33 42 fc	 xor	 eax, DWORD PTR [edx-4]
  0151f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01525	89 41 f8	 mov	 DWORD PTR [ecx-8], eax

; 757  :     Pop;

  01528	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0152e	83 ea 04	 sub	 edx, 4
  01531	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN2@P_xor:

; 758  : }

  01537	5d		 pop	 ebp
  01538	c3		 ret	 0
_P_xor	ENDP
; Function compile flags: /Odtp
_P_not	PROC

; 761  : {

  01540	55		 push	 ebp
  01541	8b ec		 mov	 ebp, esp

; 762  :     Sl(1);

  01543	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01548	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0154e	c1 f8 02	 sar	 eax, 2
  01551	83 f8 01	 cmp	 eax, 1
  01554	7d 07		 jge	 SHORT $LN1@P_not
  01556	e8 00 00 00 00	 call	 _atl__Esu
  0155b	eb 13		 jmp	 SHORT $LN2@P_not
$LN1@P_not:

; 763  :     S0 = ~S0;

  0155d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01563	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  01566	f7 d2		 not	 edx
  01568	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0156d	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN2@P_not:

; 764  : }

  01570	5d		 pop	 ebp
  01571	c3		 ret	 0
_P_not	ENDP
; Function compile flags: /Odtp
tv77 = -4						; size = 4
_P_shift PROC

; 767  : {

  01580	55		 push	 ebp
  01581	8b ec		 mov	 ebp, esp
  01583	51		 push	 ecx

; 768  :     Sl(1);

  01584	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01589	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0158f	c1 f8 02	 sar	 eax, 2
  01592	83 f8 01	 cmp	 eax, 1
  01595	7d 07		 jge	 SHORT $LN1@P_shift
  01597	e8 00 00 00 00	 call	 _atl__Esu
  0159c	eb 56		 jmp	 SHORT $LN2@P_shift
$LN1@P_shift:

; 769  :     S1 = (S0 < 0) ? (((unsigned long) S1) >> (-S0)) :
; 770  : 		    (((unsigned long) S1) <<   S0);

  0159e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  015a4	83 79 fc 00	 cmp	 DWORD PTR [ecx-4], 0
  015a8	7d 1a		 jge	 SHORT $LN4@P_shift
  015aa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  015b0	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  015b3	f7 d9		 neg	 ecx
  015b5	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  015ba	8b 50 f8	 mov	 edx, DWORD PTR [eax-8]
  015bd	d3 ea		 shr	 edx, cl
  015bf	89 55 fc	 mov	 DWORD PTR tv77[ebp], edx
  015c2	eb 16		 jmp	 SHORT $LN5@P_shift
$LN4@P_shift:
  015c4	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  015c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  015cf	8b 50 f8	 mov	 edx, DWORD PTR [eax-8]
  015d2	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  015d5	d3 e2		 shl	 edx, cl
  015d7	89 55 fc	 mov	 DWORD PTR tv77[ebp], edx
$LN5@P_shift:
  015da	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  015df	8b 4d fc	 mov	 ecx, DWORD PTR tv77[ebp]
  015e2	89 48 f8	 mov	 DWORD PTR [eax-8], ecx

; 771  :     Pop;

  015e5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  015eb	83 ea 04	 sub	 edx, 4
  015ee	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN2@P_shift:

; 772  : }

  015f4	8b e5		 mov	 esp, ebp
  015f6	5d		 pop	 ebp
  015f7	c3		 ret	 0
_P_shift ENDP
; Function compile flags: /Odtp
_P_1plus PROC

; 777  : {

  01600	55		 push	 ebp
  01601	8b ec		 mov	 ebp, esp

; 778  :     Sl(1);

  01603	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01608	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0160e	c1 f8 02	 sar	 eax, 2
  01611	83 f8 01	 cmp	 eax, 1
  01614	7d 07		 jge	 SHORT $LN1@P_1plus
  01616	e8 00 00 00 00	 call	 _atl__Esu
  0161b	eb 14		 jmp	 SHORT $LN2@P_1plus
$LN1@P_1plus:

; 779  :     S0++;

  0161d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01623	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  01626	83 c2 01	 add	 edx, 1
  01629	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0162e	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN2@P_1plus:

; 780  : }

  01631	5d		 pop	 ebp
  01632	c3		 ret	 0
_P_1plus ENDP
; Function compile flags: /Odtp
_P_2plus PROC

; 783  : {

  01640	55		 push	 ebp
  01641	8b ec		 mov	 ebp, esp

; 784  :     Sl(1);

  01643	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01648	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0164e	c1 f8 02	 sar	 eax, 2
  01651	83 f8 01	 cmp	 eax, 1
  01654	7d 07		 jge	 SHORT $LN1@P_2plus
  01656	e8 00 00 00 00	 call	 _atl__Esu
  0165b	eb 14		 jmp	 SHORT $LN2@P_2plus
$LN1@P_2plus:

; 785  :     S0 += 2;

  0165d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01663	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  01666	83 c2 02	 add	 edx, 2
  01669	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0166e	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN2@P_2plus:

; 786  : }

  01671	5d		 pop	 ebp
  01672	c3		 ret	 0
_P_2plus ENDP
; Function compile flags: /Odtp
_P_1minus PROC

; 789  : {

  01680	55		 push	 ebp
  01681	8b ec		 mov	 ebp, esp

; 790  :     Sl(1);

  01683	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01688	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0168e	c1 f8 02	 sar	 eax, 2
  01691	83 f8 01	 cmp	 eax, 1
  01694	7d 07		 jge	 SHORT $LN1@P_1minus
  01696	e8 00 00 00 00	 call	 _atl__Esu
  0169b	eb 14		 jmp	 SHORT $LN2@P_1minus
$LN1@P_1minus:

; 791  :     S0--;

  0169d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  016a3	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  016a6	83 ea 01	 sub	 edx, 1
  016a9	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  016ae	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN2@P_1minus:

; 792  : }

  016b1	5d		 pop	 ebp
  016b2	c3		 ret	 0
_P_1minus ENDP
; Function compile flags: /Odtp
_P_2minus PROC

; 795  : {

  016c0	55		 push	 ebp
  016c1	8b ec		 mov	 ebp, esp

; 796  :     Sl(1);

  016c3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  016c8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  016ce	c1 f8 02	 sar	 eax, 2
  016d1	83 f8 01	 cmp	 eax, 1
  016d4	7d 07		 jge	 SHORT $LN1@P_2minus
  016d6	e8 00 00 00 00	 call	 _atl__Esu
  016db	eb 14		 jmp	 SHORT $LN2@P_2minus
$LN1@P_2minus:

; 797  :     S0 -= 2;

  016dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  016e3	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  016e6	83 ea 02	 sub	 edx, 2
  016e9	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  016ee	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN2@P_2minus:

; 798  : }

  016f1	5d		 pop	 ebp
  016f2	c3		 ret	 0
_P_2minus ENDP
; Function compile flags: /Odtp
_P_2times PROC

; 801  : {

  01700	55		 push	 ebp
  01701	8b ec		 mov	 ebp, esp

; 802  :     Sl(1);

  01703	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01708	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0170e	c1 f8 02	 sar	 eax, 2
  01711	83 f8 01	 cmp	 eax, 1
  01714	7d 07		 jge	 SHORT $LN1@P_2times
  01716	e8 00 00 00 00	 call	 _atl__Esu
  0171b	eb 13		 jmp	 SHORT $LN2@P_2times
$LN1@P_2times:

; 803  :     S0 *= 2;

  0171d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01723	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  01726	d1 e2		 shl	 edx, 1
  01728	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0172d	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN2@P_2times:

; 804  : }

  01730	5d		 pop	 ebp
  01731	c3		 ret	 0
_P_2times ENDP
; Function compile flags: /Odtp
_P_2div PROC

; 807  : {

  01740	55		 push	 ebp
  01741	8b ec		 mov	 ebp, esp

; 808  :     Sl(1);

  01743	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01748	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0174e	c1 f8 02	 sar	 eax, 2
  01751	83 f8 01	 cmp	 eax, 1
  01754	7d 07		 jge	 SHORT $LN1@P_2div
  01756	e8 00 00 00 00	 call	 _atl__Esu
  0175b	eb 17		 jmp	 SHORT $LN2@P_2div
$LN1@P_2div:

; 809  :     S0 /= 2;

  0175d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01763	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  01766	99		 cdq
  01767	2b c2		 sub	 eax, edx
  01769	d1 f8		 sar	 eax, 1
  0176b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  01771	89 42 fc	 mov	 DWORD PTR [edx-4], eax
$LN2@P_2div:

; 810  : }

  01774	5d		 pop	 ebp
  01775	c3		 ret	 0
_P_2div	ENDP
; Function compile flags: /Odtp
_P_0equal PROC

; 817  : {

  01780	55		 push	 ebp
  01781	8b ec		 mov	 ebp, esp

; 818  :     Sl(1);

  01783	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01788	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0178e	c1 f8 02	 sar	 eax, 2
  01791	83 f8 01	 cmp	 eax, 1
  01794	7d 07		 jge	 SHORT $LN1@P_0equal
  01796	e8 00 00 00 00	 call	 _atl__Esu
  0179b	eb 1a		 jmp	 SHORT $LN2@P_0equal
$LN1@P_0equal:

; 819  :     S0 = (S0 == 0) ? Truth : Falsity;

  0179d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  017a3	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  017a6	f7 da		 neg	 edx
  017a8	1b d2		 sbb	 edx, edx
  017aa	f7 da		 neg	 edx
  017ac	83 ea 01	 sub	 edx, 1
  017af	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  017b4	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN2@P_0equal:

; 820  : }

  017b7	5d		 pop	 ebp
  017b8	c3		 ret	 0
_P_0equal ENDP
; Function compile flags: /Odtp
_P_0notequal PROC

; 823  : {

  017c0	55		 push	 ebp
  017c1	8b ec		 mov	 ebp, esp

; 824  :     Sl(1);

  017c3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  017c8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  017ce	c1 f8 02	 sar	 eax, 2
  017d1	83 f8 01	 cmp	 eax, 1
  017d4	7d 07		 jge	 SHORT $LN1@P_0notequa
  017d6	e8 00 00 00 00	 call	 _atl__Esu
  017db	eb 15		 jmp	 SHORT $LN2@P_0notequa
$LN1@P_0notequa:

; 825  :     S0 = (S0 != 0) ? Truth : Falsity;

  017dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  017e3	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  017e6	f7 da		 neg	 edx
  017e8	1b d2		 sbb	 edx, edx
  017ea	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  017ef	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN2@P_0notequa:

; 826  : }

  017f2	5d		 pop	 ebp
  017f3	c3		 ret	 0
_P_0notequal ENDP
; Function compile flags: /Odtp
_P_0gtr PROC

; 829  : {

  01800	55		 push	 ebp
  01801	8b ec		 mov	 ebp, esp

; 830  :     Sl(1);

  01803	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01808	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0180e	c1 f8 02	 sar	 eax, 2
  01811	83 f8 01	 cmp	 eax, 1
  01814	7d 07		 jge	 SHORT $LN1@P_0gtr
  01816	e8 00 00 00 00	 call	 _atl__Esu
  0181b	eb 1a		 jmp	 SHORT $LN2@P_0gtr
$LN1@P_0gtr:

; 831  :     S0 = (S0 > 0) ? Truth : Falsity;

  0181d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01823	33 d2		 xor	 edx, edx
  01825	83 79 fc 00	 cmp	 DWORD PTR [ecx-4], 0
  01829	0f 9e c2	 setle	 dl
  0182c	83 ea 01	 sub	 edx, 1
  0182f	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01834	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN2@P_0gtr:

; 832  : }

  01837	5d		 pop	 ebp
  01838	c3		 ret	 0
_P_0gtr	ENDP
; Function compile flags: /Odtp
_P_0lss PROC

; 835  : {

  01840	55		 push	 ebp
  01841	8b ec		 mov	 ebp, esp

; 836  :     Sl(1);

  01843	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01848	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0184e	c1 f8 02	 sar	 eax, 2
  01851	83 f8 01	 cmp	 eax, 1
  01854	7d 07		 jge	 SHORT $LN1@P_0lss
  01856	e8 00 00 00 00	 call	 _atl__Esu
  0185b	eb 1a		 jmp	 SHORT $LN2@P_0lss
$LN1@P_0lss:

; 837  :     S0 = (S0 < 0) ? Truth : Falsity;

  0185d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01863	33 d2		 xor	 edx, edx
  01865	83 79 fc 00	 cmp	 DWORD PTR [ecx-4], 0
  01869	0f 9d c2	 setge	 dl
  0186c	83 ea 01	 sub	 edx, 1
  0186f	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01874	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN2@P_0lss:

; 838  : }

  01877	5d		 pop	 ebp
  01878	c3		 ret	 0
_P_0lss	ENDP
_TEXT	ENDS
PUBLIC	_atl__Eso
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_here	PROC

; 845  : {

  01880	55		 push	 ebp
  01881	8b ec		 mov	 ebp, esp

; 846  :     So(1);

  01883	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01888	83 c0 04	 add	 eax, 4
  0188b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__sx
  01891	76 0f		 jbe	 SHORT $LN2@P_here
  01893	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01899	83 c1 04	 add	 ecx, 4
  0189c	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sx, ecx
$LN2@P_here:
  018a2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  018a8	83 c2 04	 add	 edx, 4
  018ab	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__st
  018b1	76 07		 jbe	 SHORT $LN1@P_here
  018b3	e8 00 00 00 00	 call	 _atl__Eso
  018b8	eb 1c		 jmp	 SHORT $LN3@P_here
$LN1@P_here:

; 847  :     Push = (stackitem) hptr;

  018ba	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  018bf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  018c5	89 08		 mov	 DWORD PTR [eax], ecx
  018c7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  018cd	83 c2 04	 add	 edx, 4
  018d0	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN3@P_here:

; 848  : }

  018d6	5d		 pop	 ebp
  018d7	c3		 ret	 0
_P_here	ENDP
_TEXT	ENDS
PUBLIC	_atl__Ebp
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_bang	PROC

; 851  : {

  018e0	55		 push	 ebp
  018e1	8b ec		 mov	 ebp, esp

; 852  :     Sl(2);

  018e3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  018e8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  018ee	c1 f8 02	 sar	 eax, 2
  018f1	83 f8 02	 cmp	 eax, 2
  018f4	7d 07		 jge	 SHORT $LN3@P_bang
  018f6	e8 00 00 00 00	 call	 _atl__Esu
  018fb	eb 49		 jmp	 SHORT $LN4@P_bang
$LN3@P_bang:

; 853  :     Hpc(S0);

  018fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01903	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  01906	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  0190c	72 10		 jb	 SHORT $LN1@P_bang
  0190e	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01913	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  01916	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  0191c	72 07		 jb	 SHORT $LN2@P_bang
$LN1@P_bang:
  0191e	e8 00 00 00 00	 call	 _atl__Ebp
  01923	eb 21		 jmp	 SHORT $LN4@P_bang
$LN2@P_bang:

; 854  :     *((stackitem *) S0) = S1;

  01925	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0192b	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  0192e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01934	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  01937	89 10		 mov	 DWORD PTR [eax], edx

; 855  :     Pop2;

  01939	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0193e	83 e8 08	 sub	 eax, 8
  01941	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN4@P_bang:

; 856  : }

  01946	5d		 pop	 ebp
  01947	c3		 ret	 0
_P_bang	ENDP
; Function compile flags: /Odtp
_P_at	PROC

; 859  : {

  01950	55		 push	 ebp
  01951	8b ec		 mov	 ebp, esp

; 860  :     Sl(1);

  01953	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01958	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0195e	c1 f8 02	 sar	 eax, 2
  01961	83 f8 01	 cmp	 eax, 1
  01964	7d 07		 jge	 SHORT $LN3@P_at
  01966	e8 00 00 00 00	 call	 _atl__Esu
  0196b	eb 3c		 jmp	 SHORT $LN4@P_at
$LN3@P_at:

; 861  :     Hpc(S0);

  0196d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01973	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  01976	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  0197c	72 10		 jb	 SHORT $LN1@P_at
  0197e	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01983	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  01986	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  0198c	72 07		 jb	 SHORT $LN2@P_at
$LN1@P_at:
  0198e	e8 00 00 00 00	 call	 _atl__Ebp
  01993	eb 14		 jmp	 SHORT $LN4@P_at
$LN2@P_at:

; 862  :     S0 = *((stackitem *) S0);

  01995	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0199b	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  0199e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  019a4	8b 10		 mov	 edx, DWORD PTR [eax]
  019a6	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN4@P_at:

; 863  : }

  019a9	5d		 pop	 ebp
  019aa	c3		 ret	 0
_P_at	ENDP
; Function compile flags: /Odtp
_P_plusbang PROC

; 866  : {

  019b0	55		 push	 ebp
  019b1	8b ec		 mov	 ebp, esp

; 867  :     Sl(2);

  019b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  019b8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  019be	c1 f8 02	 sar	 eax, 2
  019c1	83 f8 02	 cmp	 eax, 2
  019c4	7d 07		 jge	 SHORT $LN3@P_plusbang
  019c6	e8 00 00 00 00	 call	 _atl__Esu
  019cb	eb 53		 jmp	 SHORT $LN4@P_plusbang
$LN3@P_plusbang:

; 868  :     Hpc(S0);

  019cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  019d3	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  019d6	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  019dc	72 10		 jb	 SHORT $LN1@P_plusbang
  019de	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  019e3	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  019e6	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  019ec	72 07		 jb	 SHORT $LN2@P_plusbang
$LN1@P_plusbang:
  019ee	e8 00 00 00 00	 call	 _atl__Ebp
  019f3	eb 2b		 jmp	 SHORT $LN4@P_plusbang
$LN2@P_plusbang:

; 869  :     *((stackitem *) S0) += S1;

  019f5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  019fb	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  019fe	8b 08		 mov	 ecx, DWORD PTR [eax]
  01a00	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  01a06	03 4a f8	 add	 ecx, DWORD PTR [edx-8]
  01a09	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01a0e	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  01a11	89 0a		 mov	 DWORD PTR [edx], ecx

; 870  :     Pop2;

  01a13	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01a18	83 e8 08	 sub	 eax, 8
  01a1b	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN4@P_plusbang:

; 871  : }

  01a20	5d		 pop	 ebp
  01a21	c3		 ret	 0
_P_plusbang ENDP
_TEXT	ENDS
PUBLIC	_atl__Eho
; Function compile flags: /Odtp
_TEXT	SEGMENT
_n$ = -4						; size = 4
_P_allot PROC

; 874  : {

  01a30	55		 push	 ebp
  01a31	8b ec		 mov	 ebp, esp
  01a33	51		 push	 ecx

; 875  :     stackitem n;
; 876  : 
; 877  :     Sl(1);

  01a34	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01a39	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  01a3f	c1 f8 02	 sar	 eax, 2
  01a42	83 f8 01	 cmp	 eax, 1
  01a45	7d 07		 jge	 SHORT $LN3@P_allot
  01a47	e8 00 00 00 00	 call	 _atl__Esu
  01a4c	eb 70		 jmp	 SHORT $LN4@P_allot
$LN3@P_allot:

; 878  :     n = (S0 + (sizeof(stackitem) - 1)) / sizeof(stackitem);

  01a4e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01a54	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  01a57	83 c2 03	 add	 edx, 3
  01a5a	c1 ea 02	 shr	 edx, 2
  01a5d	89 55 fc	 mov	 DWORD PTR _n$[ebp], edx

; 879  :     Pop;

  01a60	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01a65	83 e8 04	 sub	 eax, 4
  01a68	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax

; 880  :     Ho(n);

  01a6d	8b 4d fc	 mov	 ecx, DWORD PTR _n$[ebp]
  01a70	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  01a76	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  01a79	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hx
  01a7f	76 11		 jbe	 SHORT $LN2@P_allot
  01a81	8b 4d fc	 mov	 ecx, DWORD PTR _n$[ebp]
  01a84	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  01a8a	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  01a8d	a3 00 00 00 00	 mov	 DWORD PTR _atl__hx, eax
$LN2@P_allot:
  01a92	8b 4d fc	 mov	 ecx, DWORD PTR _n$[ebp]
  01a95	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  01a9b	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  01a9e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__ht
  01aa4	76 07		 jbe	 SHORT $LN1@P_allot
  01aa6	e8 00 00 00 00	 call	 _atl__Eho
  01aab	eb 11		 jmp	 SHORT $LN4@P_allot
$LN1@P_allot:

; 881  :     hptr += n;

  01aad	8b 4d fc	 mov	 ecx, DWORD PTR _n$[ebp]
  01ab0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  01ab6	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  01ab9	a3 00 00 00 00	 mov	 DWORD PTR _atl__hp, eax
$LN4@P_allot:

; 882  : }

  01abe	8b e5		 mov	 esp, ebp
  01ac0	5d		 pop	 ebp
  01ac1	c3		 ret	 0
_P_allot ENDP
; Function compile flags: /Odtp
_P_comma PROC

; 885  : {

  01ad0	55		 push	 ebp
  01ad1	8b ec		 mov	 ebp, esp

; 886  :     Sl(1);

  01ad3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01ad8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  01ade	c1 f8 02	 sar	 eax, 2
  01ae1	83 f8 01	 cmp	 eax, 1
  01ae4	7d 07		 jge	 SHORT $LN3@P_comma
  01ae6	e8 00 00 00 00	 call	 _atl__Esu
  01aeb	eb 66		 jmp	 SHORT $LN4@P_comma
$LN3@P_comma:

; 887  :     Ho(1);

  01aed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  01af3	83 c1 04	 add	 ecx, 4
  01af6	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__hx
  01afc	76 0f		 jbe	 SHORT $LN2@P_comma
  01afe	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  01b04	83 c2 04	 add	 edx, 4
  01b07	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hx, edx
$LN2@P_comma:
  01b0d	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  01b12	83 c0 04	 add	 eax, 4
  01b15	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__ht
  01b1b	76 07		 jbe	 SHORT $LN1@P_comma
  01b1d	e8 00 00 00 00	 call	 _atl__Eho
  01b22	eb 2f		 jmp	 SHORT $LN4@P_comma
$LN1@P_comma:

; 888  :     Hstore = S0;

  01b24	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  01b2a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  01b30	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  01b33	89 01		 mov	 DWORD PTR [ecx], eax
  01b35	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  01b3b	83 c1 04	 add	 ecx, 4
  01b3e	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hp, ecx

; 889  :     Pop;

  01b44	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  01b4a	83 ea 04	 sub	 edx, 4
  01b4d	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN4@P_comma:

; 890  : }

  01b53	5d		 pop	 ebp
  01b54	c3		 ret	 0
_P_comma ENDP
; Function compile flags: /Odtp
_P_cbang PROC

; 893  : {

  01b60	55		 push	 ebp
  01b61	8b ec		 mov	 ebp, esp

; 894  :     Sl(2);

  01b63	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01b68	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  01b6e	c1 f8 02	 sar	 eax, 2
  01b71	83 f8 02	 cmp	 eax, 2
  01b74	7d 07		 jge	 SHORT $LN3@P_cbang
  01b76	e8 00 00 00 00	 call	 _atl__Esu
  01b7b	eb 49		 jmp	 SHORT $LN4@P_cbang
$LN3@P_cbang:

; 895  :     Hpc(S0);

  01b7d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01b83	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  01b86	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  01b8c	72 10		 jb	 SHORT $LN1@P_cbang
  01b8e	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01b93	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  01b96	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  01b9c	72 07		 jb	 SHORT $LN2@P_cbang
$LN1@P_cbang:
  01b9e	e8 00 00 00 00	 call	 _atl__Ebp
  01ba3	eb 21		 jmp	 SHORT $LN4@P_cbang
$LN2@P_cbang:

; 896  :     *((unsigned char *) S0) = S1;

  01ba5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  01bab	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  01bae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01bb4	8a 51 f8	 mov	 dl, BYTE PTR [ecx-8]
  01bb7	88 10		 mov	 BYTE PTR [eax], dl

; 897  :     Pop2;

  01bb9	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01bbe	83 e8 08	 sub	 eax, 8
  01bc1	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN4@P_cbang:

; 898  : }

  01bc6	5d		 pop	 ebp
  01bc7	c3		 ret	 0
_P_cbang ENDP
; Function compile flags: /Odtp
_P_cat	PROC

; 901  : {

  01bd0	55		 push	 ebp
  01bd1	8b ec		 mov	 ebp, esp

; 902  :     Sl(1);

  01bd3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01bd8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  01bde	c1 f8 02	 sar	 eax, 2
  01be1	83 f8 01	 cmp	 eax, 1
  01be4	7d 07		 jge	 SHORT $LN3@P_cat
  01be6	e8 00 00 00 00	 call	 _atl__Esu
  01beb	eb 3d		 jmp	 SHORT $LN4@P_cat
$LN3@P_cat:

; 903  :     Hpc(S0);

  01bed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01bf3	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  01bf6	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  01bfc	72 10		 jb	 SHORT $LN1@P_cat
  01bfe	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01c03	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  01c06	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  01c0c	72 07		 jb	 SHORT $LN2@P_cat
$LN1@P_cat:
  01c0e	e8 00 00 00 00	 call	 _atl__Ebp
  01c13	eb 15		 jmp	 SHORT $LN4@P_cat
$LN2@P_cat:

; 904  :     S0 = *((unsigned char *) S0);

  01c15	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  01c1b	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  01c1e	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  01c21	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  01c27	89 4a fc	 mov	 DWORD PTR [edx-4], ecx
$LN4@P_cat:

; 905  : }

  01c2a	5d		 pop	 ebp
  01c2b	c3		 ret	 0
_P_cat	ENDP
; Function compile flags: /Odtp
_chp$ = -4						; size = 4
_P_ccomma PROC

; 908  : {

  01c30	55		 push	 ebp
  01c31	8b ec		 mov	 ebp, esp
  01c33	51		 push	 ecx

; 909  :     unsigned char *chp;
; 910  : 
; 911  :     Sl(1);

  01c34	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01c39	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  01c3f	c1 f8 02	 sar	 eax, 2
  01c42	83 f8 01	 cmp	 eax, 1
  01c45	7d 07		 jge	 SHORT $LN3@P_ccomma
  01c47	e8 00 00 00 00	 call	 _atl__Esu
  01c4c	eb 6d		 jmp	 SHORT $LN4@P_ccomma
$LN3@P_ccomma:

; 912  :     Ho(1);

  01c4e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  01c54	83 c1 04	 add	 ecx, 4
  01c57	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__hx
  01c5d	76 0f		 jbe	 SHORT $LN2@P_ccomma
  01c5f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  01c65	83 c2 04	 add	 edx, 4
  01c68	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hx, edx
$LN2@P_ccomma:
  01c6e	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  01c73	83 c0 04	 add	 eax, 4
  01c76	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__ht
  01c7c	76 07		 jbe	 SHORT $LN1@P_ccomma
  01c7e	e8 00 00 00 00	 call	 _atl__Eho
  01c83	eb 36		 jmp	 SHORT $LN4@P_ccomma
$LN1@P_ccomma:

; 913  :     chp = ((unsigned char *) hptr);

  01c85	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  01c8b	89 4d fc	 mov	 DWORD PTR _chp$[ebp], ecx

; 914  :     *chp++ = S0;

  01c8e	8b 55 fc	 mov	 edx, DWORD PTR _chp$[ebp]
  01c91	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01c96	8a 48 fc	 mov	 cl, BYTE PTR [eax-4]
  01c99	88 0a		 mov	 BYTE PTR [edx], cl
  01c9b	8b 55 fc	 mov	 edx, DWORD PTR _chp$[ebp]
  01c9e	83 c2 01	 add	 edx, 1
  01ca1	89 55 fc	 mov	 DWORD PTR _chp$[ebp], edx

; 915  :     hptr = (stackitem *) chp;

  01ca4	8b 45 fc	 mov	 eax, DWORD PTR _chp$[ebp]
  01ca7	a3 00 00 00 00	 mov	 DWORD PTR _atl__hp, eax

; 916  :     Pop;

  01cac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01cb2	83 e9 04	 sub	 ecx, 4
  01cb5	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN4@P_ccomma:

; 917  : }

  01cbb	8b e5		 mov	 esp, ebp
  01cbd	5d		 pop	 ebp
  01cbe	c3		 ret	 0
_P_ccomma ENDP
; Function compile flags: /Odtp
_chp$83214 = -8					; size = 4
_n$ = -4						; size = 4
_P_cequal PROC

; 920  : {				      /* a series of bytes. */

  01cc0	55		 push	 ebp
  01cc1	8b ec		 mov	 ebp, esp
  01cc3	83 ec 08	 sub	 esp, 8

; 921  :     stackitem n = (((stackitem) hptr) - ((stackitem) heap)) %
; 922  : 			(sizeof(stackitem));

  01cc6	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  01ccb	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__hb
  01cd1	33 d2		 xor	 edx, edx
  01cd3	b9 04 00 00 00	 mov	 ecx, 4
  01cd8	f7 f1		 div	 ecx
  01cda	89 55 fc	 mov	 DWORD PTR _n$[ebp], edx

; 923  : 
; 924  :     if (n != 0) {

  01cdd	83 7d fc 00	 cmp	 DWORD PTR _n$[ebp], 0
  01ce1	74 20		 je	 SHORT $LN2@P_cequal

; 925  : 	char *chp = ((char *) hptr);

  01ce3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  01ce9	89 55 f8	 mov	 DWORD PTR _chp$83214[ebp], edx

; 926  : 
; 927  : 	chp += sizeof(stackitem) - n;

  01cec	b8 04 00 00 00	 mov	 eax, 4
  01cf1	2b 45 fc	 sub	 eax, DWORD PTR _n$[ebp]
  01cf4	03 45 f8	 add	 eax, DWORD PTR _chp$83214[ebp]
  01cf7	89 45 f8	 mov	 DWORD PTR _chp$83214[ebp], eax

; 928  : 	hptr = ((stackitem *) chp);

  01cfa	8b 4d f8	 mov	 ecx, DWORD PTR _chp$83214[ebp]
  01cfd	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hp, ecx
$LN2@P_cequal:

; 929  :     }
; 930  : }

  01d03	8b e5		 mov	 esp, ebp
  01d05	5d		 pop	 ebp
  01d06	c3		 ret	 0
_P_cequal ENDP
; Function compile flags: /Odtp
_atl__Pcr PROC

; 941  : {

  01d10	55		 push	 ebp
  01d11	8b ec		 mov	 ebp, esp

; 942  :     defpend = True;		      /* Set definition pending */

  01d13	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _defpend, 1

; 943  :     Ho(Dictwordl);

  01d1d	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  01d22	83 c0 0c	 add	 eax, 12			; 0000000cH
  01d25	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hx
  01d2b	76 0f		 jbe	 SHORT $LN2@atl__Pcr
  01d2d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  01d33	83 c1 0c	 add	 ecx, 12			; 0000000cH
  01d36	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hx, ecx
$LN2@atl__Pcr:
  01d3c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  01d42	83 c2 0c	 add	 edx, 12			; 0000000cH
  01d45	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__ht
  01d4b	76 07		 jbe	 SHORT $LN1@atl__Pcr
  01d4d	e8 00 00 00 00	 call	 _atl__Eho
  01d52	eb 31		 jmp	 SHORT $LN3@atl__Pcr
$LN1@atl__Pcr:

; 944  :     createword = (dictword *) hptr;   /* Develop address of word */

  01d54	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  01d59	a3 00 00 00 00	 mov	 DWORD PTR _atl__wd, eax

; 945  :     createword->wname = NULL;	      /* Clear pointer to name string */

  01d5e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__wd
  01d64	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 946  :     createword->wcode = P_var;	      /* Store default code */

  01d6b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__wd
  01d71	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], OFFSET _P_var

; 947  :     hptr += Dictwordl;		      /* Allocate heap space for word */

  01d78	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  01d7d	83 c0 0c	 add	 eax, 12			; 0000000cH
  01d80	a3 00 00 00 00	 mov	 DWORD PTR _atl__hp, eax
$LN3@atl__Pcr:

; 948  : }

  01d85	5d		 pop	 ebp
  01d86	c3		 ret	 0
_atl__Pcr ENDP
; Function compile flags: /Odtp
_P_var	PROC

; 935  : {

  01d90	55		 push	 ebp
  01d91	8b ec		 mov	 ebp, esp

; 936  :     So(1);

  01d93	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01d98	83 c0 04	 add	 eax, 4
  01d9b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__sx
  01da1	76 0f		 jbe	 SHORT $LN2@P_var
  01da3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01da9	83 c1 04	 add	 ecx, 4
  01dac	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sx, ecx
$LN2@P_var:
  01db2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  01db8	83 c2 04	 add	 edx, 4
  01dbb	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__st
  01dc1	76 07		 jbe	 SHORT $LN1@P_var
  01dc3	e8 00 00 00 00	 call	 _atl__Eso
  01dc8	eb 1f		 jmp	 SHORT $LN3@P_var
$LN1@P_var:

; 937  :     Push = (stackitem) (((stackitem *) curword) + Dictwordl);

  01dca	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__cw
  01dcf	83 c0 0c	 add	 eax, 12			; 0000000cH
  01dd2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01dd8	89 01		 mov	 DWORD PTR [ecx], eax
  01dda	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  01de0	83 c2 04	 add	 edx, 4
  01de3	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN3@P_var:

; 938  : }

  01de9	5d		 pop	 ebp
  01dea	c3		 ret	 0
_P_var	ENDP
; Function compile flags: /Odtp
_P_forget PROC

; 951  : {

  01df0	55		 push	 ebp
  01df1	8b ec		 mov	 ebp, esp

; 952  :     forgetpend = True;		      /* Mark forget pending */

  01df3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _forgetpend, 1

; 953  : }

  01dfd	5d		 pop	 ebp
  01dfe	c3		 ret	 0
_P_forget ENDP
; Function compile flags: /Odtp
_P_variable PROC

; 956  : {

  01e00	55		 push	 ebp
  01e01	8b ec		 mov	 ebp, esp

; 957  :     P_create(); 		      /* Create dictionary item */

  01e03	e8 00 00 00 00	 call	 _atl__Pcr

; 958  :     Ho(1);

  01e08	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  01e0d	83 c0 04	 add	 eax, 4
  01e10	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hx
  01e16	76 0f		 jbe	 SHORT $LN2@P_variable
  01e18	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  01e1e	83 c1 04	 add	 ecx, 4
  01e21	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hx, ecx
$LN2@P_variable:
  01e27	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  01e2d	83 c2 04	 add	 edx, 4
  01e30	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__ht
  01e36	76 07		 jbe	 SHORT $LN1@P_variable
  01e38	e8 00 00 00 00	 call	 _atl__Eho
  01e3d	eb 1a		 jmp	 SHORT $LN3@P_variable
$LN1@P_variable:

; 959  :     Hstore = 0; 		      /* Initial value = 0 */

  01e3f	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  01e44	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  01e4a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  01e50	83 c1 04	 add	 ecx, 4
  01e53	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hp, ecx
$LN3@P_variable:

; 960  : }

  01e59	5d		 pop	 ebp
  01e5a	c3		 ret	 0
_P_variable ENDP
; Function compile flags: /Odtp
_P_constant PROC

; 969  : {

  01e60	55		 push	 ebp
  01e61	8b ec		 mov	 ebp, esp

; 970  :     Sl(1);

  01e63	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01e68	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  01e6e	c1 f8 02	 sar	 eax, 2
  01e71	83 f8 01	 cmp	 eax, 1
  01e74	7d 07		 jge	 SHORT $LN3@P_constant
  01e76	e8 00 00 00 00	 call	 _atl__Esu
  01e7b	eb 74		 jmp	 SHORT $LN4@P_constant
$LN3@P_constant:

; 971  :     P_create(); 		      /* Create dictionary item */

  01e7d	e8 00 00 00 00	 call	 _atl__Pcr

; 972  :     createword->wcode = P_con;	      /* Set code to constant push */

  01e82	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__wd
  01e88	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], OFFSET _P_con

; 973  :     Ho(1);

  01e8f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  01e95	83 c2 04	 add	 edx, 4
  01e98	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hx
  01e9e	76 0d		 jbe	 SHORT $LN2@P_constant
  01ea0	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  01ea5	83 c0 04	 add	 eax, 4
  01ea8	a3 00 00 00 00	 mov	 DWORD PTR _atl__hx, eax
$LN2@P_constant:
  01ead	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  01eb3	83 c1 04	 add	 ecx, 4
  01eb6	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  01ebc	76 07		 jbe	 SHORT $LN1@P_constant
  01ebe	e8 00 00 00 00	 call	 _atl__Eho
  01ec3	eb 2c		 jmp	 SHORT $LN4@P_constant
$LN1@P_constant:

; 974  :     Hstore = S0;		      /* Store constant value in body */

  01ec5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  01ecb	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01ed0	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  01ed3	89 0a		 mov	 DWORD PTR [edx], ecx
  01ed5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  01edb	83 c2 04	 add	 edx, 4
  01ede	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hp, edx

; 975  :     Pop;

  01ee4	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01ee9	83 e8 04	 sub	 eax, 4
  01eec	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN4@P_constant:

; 976  : }

  01ef1	5d		 pop	 ebp
  01ef2	c3		 ret	 0
_P_constant ENDP
; Function compile flags: /Odtp
_P_con	PROC

; 963  : {

  01f00	55		 push	 ebp
  01f01	8b ec		 mov	 ebp, esp

; 964  :     So(1);

  01f03	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01f08	83 c0 04	 add	 eax, 4
  01f0b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__sx
  01f11	76 0f		 jbe	 SHORT $LN2@P_con
  01f13	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01f19	83 c1 04	 add	 ecx, 4
  01f1c	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sx, ecx
$LN2@P_con:
  01f22	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  01f28	83 c2 04	 add	 edx, 4
  01f2b	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__st
  01f31	76 07		 jbe	 SHORT $LN1@P_con
  01f33	e8 00 00 00 00	 call	 _atl__Eso
  01f38	eb 1d		 jmp	 SHORT $LN3@P_con
$LN1@P_con:

; 965  :     Push = *(((stackitem *) curword) + Dictwordl);

  01f3a	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01f3f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__cw
  01f45	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  01f48	89 10		 mov	 DWORD PTR [eax], edx
  01f4a	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01f4f	83 c0 04	 add	 eax, 4
  01f52	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN3@P_con:

; 966  : }

  01f57	5d		 pop	 ebp
  01f58	c3		 ret	 0
_P_con	ENDP
; Function compile flags: /Odtp
_isp$ = -16						; size = 4
_asize$ = -12						; size = 4
_nsubs$ = -8						; size = 4
_i$ = -4						; size = 4
_P_array PROC

; 1016 : {				      /* sub1 sub2 ... subn n esize -- array */

  01f60	55		 push	 ebp
  01f61	8b ec		 mov	 ebp, esp
  01f63	83 ec 10	 sub	 esp, 16			; 00000010H

; 1017 :     int i, nsubs, asize = 1;

  01f66	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _asize$[ebp], 1

; 1018 :     stackitem *isp;
; 1019 : 
; 1020 :     Sl(2);

  01f6d	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01f72	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  01f78	c1 f8 02	 sar	 eax, 2
  01f7b	83 f8 02	 cmp	 eax, 2
  01f7e	7d 0a		 jge	 SHORT $LN15@P_array
  01f80	e8 00 00 00 00	 call	 _atl__Esu
  01f85	e9 ec 01 00 00	 jmp	 $LN16@P_array
$LN15@P_array:

; 1021 : #ifndef NOMEMCHECK
; 1022 :     if (S0 <= 0)

  01f8a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01f90	83 79 fc 00	 cmp	 DWORD PTR [ecx-4], 0
  01f94	7f 0d		 jg	 SHORT $LN14@P_array

; 1023 :         trouble("Bad array element size");

  01f96	68 00 00 00 00	 push	 OFFSET $SG83304
  01f9b	e8 00 00 00 00	 call	 _trouble
  01fa0	83 c4 04	 add	 esp, 4
$LN14@P_array:

; 1024 :     if (S1 <= 0)

  01fa3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  01fa9	83 7a f8 00	 cmp	 DWORD PTR [edx-8], 0
  01fad	7f 0d		 jg	 SHORT $LN13@P_array

; 1025 :         trouble("Bad array subscript count");

  01faf	68 00 00 00 00	 push	 OFFSET $SG83306
  01fb4	e8 00 00 00 00	 call	 _trouble
  01fb9	83 c4 04	 add	 esp, 4
$LN13@P_array:

; 1026 : #endif /* NOMEMCHECK */
; 1027 : 
; 1028 :     nsubs = S1; 		      /* Number of subscripts */

  01fbc	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01fc1	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  01fc4	89 4d f8	 mov	 DWORD PTR _nsubs$[ebp], ecx

; 1029 :     Sl(nsubs + 2);		      /* Verify that dimensions are present */

  01fc7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  01fcd	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _atl__sk
  01fd3	c1 fa 02	 sar	 edx, 2
  01fd6	8b 45 f8	 mov	 eax, DWORD PTR _nsubs$[ebp]
  01fd9	83 c0 02	 add	 eax, 2
  01fdc	3b d0		 cmp	 edx, eax
  01fde	7d 0a		 jge	 SHORT $LN12@P_array
  01fe0	e8 00 00 00 00	 call	 _atl__Esu
  01fe5	e9 8c 01 00 00	 jmp	 $LN16@P_array
$LN12@P_array:

; 1030 : 
; 1031 :     /* Calculate size of array as the product of the subscripts */
; 1032 : 
; 1033 :     asize = S0; 		      /* Fundamental element size */

  01fea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  01ff0	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  01ff3	89 55 f4	 mov	 DWORD PTR _asize$[ebp], edx

; 1034 :     isp = &S2;

  01ff6	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  01ffb	83 e8 0c	 sub	 eax, 12			; 0000000cH
  01ffe	89 45 f0	 mov	 DWORD PTR _isp$[ebp], eax

; 1035 :     for (i = 0; i < nsubs; i++) {

  02001	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  02008	eb 09		 jmp	 SHORT $LN11@P_array
$LN10@P_array:
  0200a	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0200d	83 c1 01	 add	 ecx, 1
  02010	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN11@P_array:
  02013	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  02016	3b 55 f8	 cmp	 edx, DWORD PTR _nsubs$[ebp]
  02019	7d 2c		 jge	 SHORT $LN9@P_array

; 1036 : #ifndef NOMEMCHECK
; 1037 : 	if (*isp <= 0)

  0201b	8b 45 f0	 mov	 eax, DWORD PTR _isp$[ebp]
  0201e	83 38 00	 cmp	 DWORD PTR [eax], 0
  02021	7f 0d		 jg	 SHORT $LN8@P_array

; 1038 :             trouble("Bad array dimension");

  02023	68 00 00 00 00	 push	 OFFSET $SG83312
  02028	e8 00 00 00 00	 call	 _trouble
  0202d	83 c4 04	 add	 esp, 4
$LN8@P_array:

; 1039 : #endif /* NOMEMCHECK */
; 1040 : 	asize *= *isp--;

  02030	8b 4d f0	 mov	 ecx, DWORD PTR _isp$[ebp]
  02033	8b 55 f4	 mov	 edx, DWORD PTR _asize$[ebp]
  02036	0f af 11	 imul	 edx, DWORD PTR [ecx]
  02039	89 55 f4	 mov	 DWORD PTR _asize$[ebp], edx
  0203c	8b 45 f0	 mov	 eax, DWORD PTR _isp$[ebp]
  0203f	83 e8 04	 sub	 eax, 4
  02042	89 45 f0	 mov	 DWORD PTR _isp$[ebp], eax

; 1041 :     }

  02045	eb c3		 jmp	 SHORT $LN10@P_array
$LN9@P_array:

; 1042 : 
; 1043 :     asize = (asize + (sizeof(stackitem) - 1)) / sizeof(stackitem);

  02047	8b 4d f4	 mov	 ecx, DWORD PTR _asize$[ebp]
  0204a	83 c1 03	 add	 ecx, 3
  0204d	c1 e9 02	 shr	 ecx, 2
  02050	89 4d f4	 mov	 DWORD PTR _asize$[ebp], ecx

; 1044 :     Ho(asize + nsubs + 2);	      /* Reserve space for array and header */

  02053	8b 55 f4	 mov	 edx, DWORD PTR _asize$[ebp]
  02056	03 55 f8	 add	 edx, DWORD PTR _nsubs$[ebp]
  02059	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  0205e	8d 4c 90 08	 lea	 ecx, DWORD PTR [eax+edx*4+8]
  02062	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__hx
  02068	76 15		 jbe	 SHORT $LN7@P_array
  0206a	8b 55 f4	 mov	 edx, DWORD PTR _asize$[ebp]
  0206d	03 55 f8	 add	 edx, DWORD PTR _nsubs$[ebp]
  02070	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  02075	8d 4c 90 08	 lea	 ecx, DWORD PTR [eax+edx*4+8]
  02079	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hx, ecx
$LN7@P_array:
  0207f	8b 55 f4	 mov	 edx, DWORD PTR _asize$[ebp]
  02082	03 55 f8	 add	 edx, DWORD PTR _nsubs$[ebp]
  02085	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  0208a	8d 4c 90 08	 lea	 ecx, DWORD PTR [eax+edx*4+8]
  0208e	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  02094	76 0a		 jbe	 SHORT $LN6@P_array
  02096	e8 00 00 00 00	 call	 _atl__Eho
  0209b	e9 d6 00 00 00	 jmp	 $LN16@P_array
$LN6@P_array:

; 1045 :     P_create(); 		      /* Create variable */

  020a0	e8 00 00 00 00	 call	 _atl__Pcr

; 1046 :     createword->wcode = P_arraysub;   /* Set method to subscript calculate */

  020a5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__wd
  020ab	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], OFFSET _P_arraysub

; 1047 :     Hstore = nsubs;		      /* Header <- Number of subscripts */

  020b2	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  020b7	8b 4d f8	 mov	 ecx, DWORD PTR _nsubs$[ebp]
  020ba	89 08		 mov	 DWORD PTR [eax], ecx
  020bc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  020c2	83 c2 04	 add	 edx, 4
  020c5	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hp, edx

; 1048 :     Hstore = S0;		      /* Header <- Fundamental element size */

  020cb	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  020d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  020d6	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  020d9	89 10		 mov	 DWORD PTR [eax], edx
  020db	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  020e0	83 c0 04	 add	 eax, 4
  020e3	a3 00 00 00 00	 mov	 DWORD PTR _atl__hp, eax

; 1049 :     isp = &S2;

  020e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  020ee	83 e9 0c	 sub	 ecx, 12			; 0000000cH
  020f1	89 4d f0	 mov	 DWORD PTR _isp$[ebp], ecx

; 1050 :     for (i = 0; i < nsubs; i++) {     /* Header <- Store subscripts */

  020f4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  020fb	eb 09		 jmp	 SHORT $LN5@P_array
$LN4@P_array:
  020fd	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  02100	83 c2 01	 add	 edx, 1
  02103	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN5@P_array:
  02106	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  02109	3b 45 f8	 cmp	 eax, DWORD PTR _nsubs$[ebp]
  0210c	7d 27		 jge	 SHORT $LN2@P_array

; 1051 : 	Hstore = *isp--;

  0210e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  02114	8b 55 f0	 mov	 edx, DWORD PTR _isp$[ebp]
  02117	8b 02		 mov	 eax, DWORD PTR [edx]
  02119	89 01		 mov	 DWORD PTR [ecx], eax
  0211b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  02121	83 c1 04	 add	 ecx, 4
  02124	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hp, ecx
  0212a	8b 55 f0	 mov	 edx, DWORD PTR _isp$[ebp]
  0212d	83 ea 04	 sub	 edx, 4
  02130	89 55 f0	 mov	 DWORD PTR _isp$[ebp], edx

; 1052 :     }

  02133	eb c8		 jmp	 SHORT $LN4@P_array
$LN2@P_array:

; 1053 :     while (asize-- > 0) 	      /* Clear the array to zero */

  02135	8b 45 f4	 mov	 eax, DWORD PTR _asize$[ebp]
  02138	8b 4d f4	 mov	 ecx, DWORD PTR _asize$[ebp]
  0213b	83 e9 01	 sub	 ecx, 1
  0213e	89 4d f4	 mov	 DWORD PTR _asize$[ebp], ecx
  02141	85 c0		 test	 eax, eax
  02143	7e 1b		 jle	 SHORT $LN1@P_array

; 1054 : 	Hstore = 0;

  02145	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  0214b	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  02151	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  02156	83 c0 04	 add	 eax, 4
  02159	a3 00 00 00 00	 mov	 DWORD PTR _atl__hp, eax
  0215e	eb d5		 jmp	 SHORT $LN2@P_array
$LN1@P_array:

; 1055 :     Npop(nsubs + 2);

  02160	8b 4d f8	 mov	 ecx, DWORD PTR _nsubs$[ebp]
  02163	8d 14 8d 08 00
	00 00		 lea	 edx, DWORD PTR [ecx*4+8]
  0216a	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0216f	2b c2		 sub	 eax, edx
  02171	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN16@P_array:

; 1056 : }

  02176	8b e5		 mov	 esp, ebp
  02178	5d		 pop	 ebp
  02179	c3		 ret	 0
_P_array ENDP
; Function compile flags: /Odtp
_subn$83283 = -28					; size = 4
_array$ = -24						; size = 4
_isp$ = -20						; size = 4
_offset$ = -16						; size = 4
_nsubs$ = -12						; size = 4
_i$ = -8						; size = 4
_esize$ = -4						; size = 4
_P_arraysub PROC

; 982  : {				      /* sub1 sub2 ... subn -- addr */

  02180	55		 push	 ebp
  02181	8b ec		 mov	 ebp, esp
  02183	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 983  :     int i, offset, esize, nsubs;
; 984  :     stackitem *array;
; 985  :     stackitem *isp;
; 986  : 
; 987  :     Sl(1);

  02186	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0218b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  02191	c1 f8 02	 sar	 eax, 2
  02194	83 f8 01	 cmp	 eax, 1
  02197	7d 0a		 jge	 SHORT $LN11@P_arraysub
  02199	e8 00 00 00 00	 call	 _atl__Esu
  0219e	e9 30 01 00 00	 jmp	 $LN12@P_arraysub
$LN11@P_arraysub:

; 988  :     array = (((stackitem *) curword) + Dictwordl);

  021a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__cw
  021a9	83 c1 0c	 add	 ecx, 12			; 0000000cH
  021ac	89 4d e8	 mov	 DWORD PTR _array$[ebp], ecx

; 989  :     Hpc(array);

  021af	8b 55 e8	 mov	 edx, DWORD PTR _array$[ebp]
  021b2	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  021b8	72 0b		 jb	 SHORT $LN9@P_arraysub
  021ba	8b 45 e8	 mov	 eax, DWORD PTR _array$[ebp]
  021bd	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__ht
  021c3	72 0a		 jb	 SHORT $LN10@P_arraysub
$LN9@P_arraysub:
  021c5	e8 00 00 00 00	 call	 _atl__Ebp
  021ca	e9 04 01 00 00	 jmp	 $LN12@P_arraysub
$LN10@P_arraysub:

; 990  :     nsubs = *array++;		      /* Load number of subscripts */

  021cf	8b 4d e8	 mov	 ecx, DWORD PTR _array$[ebp]
  021d2	8b 11		 mov	 edx, DWORD PTR [ecx]
  021d4	89 55 f4	 mov	 DWORD PTR _nsubs$[ebp], edx
  021d7	8b 45 e8	 mov	 eax, DWORD PTR _array$[ebp]
  021da	83 c0 04	 add	 eax, 4
  021dd	89 45 e8	 mov	 DWORD PTR _array$[ebp], eax

; 991  :     esize = *array++;		      /* Load element size */

  021e0	8b 4d e8	 mov	 ecx, DWORD PTR _array$[ebp]
  021e3	8b 11		 mov	 edx, DWORD PTR [ecx]
  021e5	89 55 fc	 mov	 DWORD PTR _esize$[ebp], edx
  021e8	8b 45 e8	 mov	 eax, DWORD PTR _array$[ebp]
  021eb	83 c0 04	 add	 eax, 4
  021ee	89 45 e8	 mov	 DWORD PTR _array$[ebp], eax

; 992  : #ifndef NOMEMCHECK
; 993  :     isp = &S0;

  021f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  021f7	83 e9 04	 sub	 ecx, 4
  021fa	89 4d ec	 mov	 DWORD PTR _isp$[ebp], ecx

; 994  :     for (i = 0; i < nsubs; i++) {

  021fd	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  02204	eb 09		 jmp	 SHORT $LN8@P_arraysub
$LN7@P_arraysub:
  02206	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  02209	83 c2 01	 add	 edx, 1
  0220c	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$LN8@P_arraysub:
  0220f	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  02212	3b 45 f4	 cmp	 eax, DWORD PTR _nsubs$[ebp]
  02215	7d 34		 jge	 SHORT $LN6@P_arraysub

; 995  : 	stackitem subn = *isp--;

  02217	8b 4d ec	 mov	 ecx, DWORD PTR _isp$[ebp]
  0221a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0221c	89 55 e4	 mov	 DWORD PTR _subn$83283[ebp], edx
  0221f	8b 45 ec	 mov	 eax, DWORD PTR _isp$[ebp]
  02222	83 e8 04	 sub	 eax, 4
  02225	89 45 ec	 mov	 DWORD PTR _isp$[ebp], eax

; 996  : 
; 997  : 	if (subn < 0 || subn >= array[i])

  02228	83 7d e4 00	 cmp	 DWORD PTR _subn$83283[ebp], 0
  0222c	7c 0e		 jl	 SHORT $LN4@P_arraysub
  0222e	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  02231	8b 55 e8	 mov	 edx, DWORD PTR _array$[ebp]
  02234	8b 45 e4	 mov	 eax, DWORD PTR _subn$83283[ebp]
  02237	3b 04 8a	 cmp	 eax, DWORD PTR [edx+ecx*4]
  0223a	7c 0d		 jl	 SHORT $LN5@P_arraysub
$LN4@P_arraysub:

; 998  :             trouble("Subscript out of range");

  0223c	68 00 00 00 00	 push	 OFFSET $SG83286
  02241	e8 00 00 00 00	 call	 _trouble
  02246	83 c4 04	 add	 esp, 4
$LN5@P_arraysub:

; 999  :     }

  02249	eb bb		 jmp	 SHORT $LN7@P_arraysub
$LN6@P_arraysub:

; 1000 : #endif /* NOMEMCHECK */
; 1001 :     isp = &S0;

  0224b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02251	83 e9 04	 sub	 ecx, 4
  02254	89 4d ec	 mov	 DWORD PTR _isp$[ebp], ecx

; 1002 :     offset = *isp;		      /* Load initial offset */

  02257	8b 55 ec	 mov	 edx, DWORD PTR _isp$[ebp]
  0225a	8b 02		 mov	 eax, DWORD PTR [edx]
  0225c	89 45 f0	 mov	 DWORD PTR _offset$[ebp], eax

; 1003 :     for (i = 1; i < nsubs; i++)

  0225f	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  02266	eb 09		 jmp	 SHORT $LN3@P_arraysub
$LN2@P_arraysub:
  02268	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0226b	83 c1 01	 add	 ecx, 1
  0226e	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
$LN3@P_arraysub:
  02271	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  02274	3b 55 f4	 cmp	 edx, DWORD PTR _nsubs$[ebp]
  02277	7d 25		 jge	 SHORT $LN1@P_arraysub

; 1004 : 	offset = (offset * (*(++array))) + *(--isp);

  02279	8b 45 e8	 mov	 eax, DWORD PTR _array$[ebp]
  0227c	83 c0 04	 add	 eax, 4
  0227f	89 45 e8	 mov	 DWORD PTR _array$[ebp], eax
  02282	8b 4d ec	 mov	 ecx, DWORD PTR _isp$[ebp]
  02285	83 e9 04	 sub	 ecx, 4
  02288	89 4d ec	 mov	 DWORD PTR _isp$[ebp], ecx
  0228b	8b 55 e8	 mov	 edx, DWORD PTR _array$[ebp]
  0228e	8b 45 f0	 mov	 eax, DWORD PTR _offset$[ebp]
  02291	0f af 02	 imul	 eax, DWORD PTR [edx]
  02294	8b 4d ec	 mov	 ecx, DWORD PTR _isp$[ebp]
  02297	03 01		 add	 eax, DWORD PTR [ecx]
  02299	89 45 f0	 mov	 DWORD PTR _offset$[ebp], eax
  0229c	eb ca		 jmp	 SHORT $LN2@P_arraysub
$LN1@P_arraysub:

; 1005 :     Npop(nsubs - 1);

  0229e	8b 55 f4	 mov	 edx, DWORD PTR _nsubs$[ebp]
  022a1	8d 04 95 fc ff
	ff ff		 lea	 eax, DWORD PTR [edx*4-4]
  022a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  022ae	2b c8		 sub	 ecx, eax
  022b0	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx

; 1006 :     /* Calculate subscripted address.  We start at the current word,
; 1007 :        advance to the body, skip two more words for the subscript count
; 1008 :        and the fundamental element size, then skip the subscript bounds
; 1009 :        words (as many as there are subscripts).  Then, finally, we
; 1010 :        can add the calculated offset into the array. */
; 1011 :     S0 = (stackitem) (((char *) (((stackitem *) curword) +
; 1012 : 	    Dictwordl + 2 + nsubs)) + (esize * offset));

  022b6	8b 55 f4	 mov	 edx, DWORD PTR _nsubs$[ebp]
  022b9	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__cw
  022be	8d 4c 90 14	 lea	 ecx, DWORD PTR [eax+edx*4+20]
  022c2	8b 55 fc	 mov	 edx, DWORD PTR _esize$[ebp]
  022c5	0f af 55 f0	 imul	 edx, DWORD PTR _offset$[ebp]
  022c9	03 ca		 add	 ecx, edx
  022cb	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  022d0	89 48 fc	 mov	 DWORD PTR [eax-4], ecx
$LN12@P_arraysub:

; 1013 : }

  022d3	8b e5		 mov	 esp, ebp
  022d5	5d		 pop	 ebp
  022d6	c3		 ret	 0
_P_arraysub ENDP
; Function compile flags: /Odtp
_P_strlit PROC

; 1064 : {

  022e0	55		 push	 ebp
  022e1	8b ec		 mov	 ebp, esp

; 1065 :     So(1);

  022e3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  022e8	83 c0 04	 add	 eax, 4
  022eb	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__sx
  022f1	76 0f		 jbe	 SHORT $LN3@P_strlit
  022f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  022f9	83 c1 04	 add	 ecx, 4
  022fc	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sx, ecx
$LN3@P_strlit:
  02302	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  02308	83 c2 04	 add	 edx, 4
  0230b	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__st
  02311	76 07		 jbe	 SHORT $LN2@P_strlit
  02313	e8 00 00 00 00	 call	 _atl__Eso
  02318	eb 55		 jmp	 SHORT $LN4@P_strlit
$LN2@P_strlit:

; 1066 :     Push = (stackitem) (((char *) ip) + 1);

  0231a	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__ip
  0231f	83 c0 01	 add	 eax, 1
  02322	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02328	89 01		 mov	 DWORD PTR [ecx], eax
  0232a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  02330	83 c2 04	 add	 edx, 4
  02333	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx

; 1067 : #ifdef TRACE
; 1068 :     if (atl_trace) {

  02339	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _atl_trace, 0
  02340	74 16		 je	 SHORT $LN1@P_strlit

; 1069 :         V printf("\"%s\" ", (((char *) ip) + 1));

  02342	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__ip
  02347	83 c0 01	 add	 eax, 1
  0234a	50		 push	 eax
  0234b	68 00 00 00 00	 push	 OFFSET $SG83332
  02350	e8 00 00 00 00	 call	 _printf
  02355	83 c4 08	 add	 esp, 8
$LN1@P_strlit:

; 1070 :     }
; 1071 : #endif /* TRACE */
; 1072 :     Skipstring; 		      /* Advance IP past it */

  02358	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__ip
  0235e	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  02361	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__ip
  02366	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  02369	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__ip, ecx
$LN4@P_strlit:

; 1073 : }

  0236f	5d		 pop	 ebp
  02370	c3		 ret	 0
_P_strlit ENDP
; Function compile flags: /Odtp
_P_string PROC

; 1076 : {

  02380	55		 push	 ebp
  02381	8b ec		 mov	 ebp, esp

; 1077 :     Sl(1);

  02383	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02388	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0238e	c1 f8 02	 sar	 eax, 2
  02391	83 f8 01	 cmp	 eax, 1
  02394	7d 0a		 jge	 SHORT $LN3@P_string
  02396	e8 00 00 00 00	 call	 _atl__Esu
  0239b	e9 94 00 00 00	 jmp	 $LN4@P_string
$LN3@P_string:

; 1078 :     Ho((S0 + 1 + sizeof(stackitem)) / sizeof(stackitem));

  023a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  023a6	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  023a9	83 c2 05	 add	 edx, 5
  023ac	c1 ea 02	 shr	 edx, 2
  023af	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  023b4	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  023b7	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__hx
  023bd	76 1e		 jbe	 SHORT $LN2@P_string
  023bf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  023c5	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  023c8	83 c0 05	 add	 eax, 5
  023cb	c1 e8 02	 shr	 eax, 2
  023ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  023d4	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  023d7	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hx, edx
$LN2@P_string:
  023dd	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  023e2	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  023e5	83 c1 05	 add	 ecx, 5
  023e8	c1 e9 02	 shr	 ecx, 2
  023eb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  023f1	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  023f4	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__ht
  023fa	76 07		 jbe	 SHORT $LN1@P_string
  023fc	e8 00 00 00 00	 call	 _atl__Eho
  02401	eb 31		 jmp	 SHORT $LN4@P_string
$LN1@P_string:

; 1079 :     P_create(); 		      /* Create variable */

  02403	e8 00 00 00 00	 call	 _atl__Pcr

; 1080 :     /* Allocate storage for string */
; 1081 :     hptr += (S0 + 1 + sizeof(stackitem)) / sizeof(stackitem);

  02408	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0240e	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  02411	83 c2 05	 add	 edx, 5
  02414	c1 ea 02	 shr	 edx, 2
  02417	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  0241c	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  0241f	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hp, ecx

; 1082 :     Pop;

  02425	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0242b	83 ea 04	 sub	 edx, 4
  0242e	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN4@P_string:

; 1083 : }

  02434	5d		 pop	 ebp
  02435	c3		 ret	 0
_P_string ENDP
_TEXT	ENDS
EXTRN	_strcpy:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_strcpy PROC

; 1086 : {

  02440	55		 push	 ebp
  02441	8b ec		 mov	 ebp, esp

; 1087 :     Sl(2);

  02443	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02448	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0244e	c1 f8 02	 sar	 eax, 2
  02451	83 f8 02	 cmp	 eax, 2
  02454	7d 07		 jge	 SHORT $LN5@P_strcpy
  02456	e8 00 00 00 00	 call	 _atl__Esu
  0245b	eb 7b		 jmp	 SHORT $LN6@P_strcpy
$LN5@P_strcpy:

; 1088 :     Hpc(S0);

  0245d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02463	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  02466	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  0246c	72 10		 jb	 SHORT $LN3@P_strcpy
  0246e	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02473	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  02476	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  0247c	72 07		 jb	 SHORT $LN4@P_strcpy
$LN3@P_strcpy:
  0247e	e8 00 00 00 00	 call	 _atl__Ebp
  02483	eb 53		 jmp	 SHORT $LN6@P_strcpy
$LN4@P_strcpy:

; 1089 :     Hpc(S1);

  02485	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0248b	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  0248e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hs
  02494	72 11		 jb	 SHORT $LN1@P_strcpy
  02496	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0249c	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  0249f	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__ht
  024a5	72 07		 jb	 SHORT $LN2@P_strcpy
$LN1@P_strcpy:
  024a7	e8 00 00 00 00	 call	 _atl__Ebp
  024ac	eb 2a		 jmp	 SHORT $LN6@P_strcpy
$LN2@P_strcpy:

; 1090 :     V strcpy((char *) S0, (char *) S1);

  024ae	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  024b3	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  024b6	51		 push	 ecx
  024b7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  024bd	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  024c0	50		 push	 eax
  024c1	e8 00 00 00 00	 call	 _strcpy
  024c6	83 c4 08	 add	 esp, 8

; 1091 :     Pop2;

  024c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  024cf	83 e9 08	 sub	 ecx, 8
  024d2	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN6@P_strcpy:

; 1092 : }

  024d8	5d		 pop	 ebp
  024d9	c3		 ret	 0
_P_strcpy ENDP
_TEXT	ENDS
EXTRN	_strcat:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_strcat PROC

; 1095 : {

  024e0	55		 push	 ebp
  024e1	8b ec		 mov	 ebp, esp

; 1096 :     Sl(2);

  024e3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  024e8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  024ee	c1 f8 02	 sar	 eax, 2
  024f1	83 f8 02	 cmp	 eax, 2
  024f4	7d 07		 jge	 SHORT $LN5@P_strcat
  024f6	e8 00 00 00 00	 call	 _atl__Esu
  024fb	eb 7b		 jmp	 SHORT $LN6@P_strcat
$LN5@P_strcat:

; 1097 :     Hpc(S0);

  024fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02503	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  02506	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  0250c	72 10		 jb	 SHORT $LN3@P_strcat
  0250e	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02513	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  02516	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  0251c	72 07		 jb	 SHORT $LN4@P_strcat
$LN3@P_strcat:
  0251e	e8 00 00 00 00	 call	 _atl__Ebp
  02523	eb 53		 jmp	 SHORT $LN6@P_strcat
$LN4@P_strcat:

; 1098 :     Hpc(S1);

  02525	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0252b	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  0252e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hs
  02534	72 11		 jb	 SHORT $LN1@P_strcat
  02536	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0253c	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  0253f	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__ht
  02545	72 07		 jb	 SHORT $LN2@P_strcat
$LN1@P_strcat:
  02547	e8 00 00 00 00	 call	 _atl__Ebp
  0254c	eb 2a		 jmp	 SHORT $LN6@P_strcat
$LN2@P_strcat:

; 1099 :     V strcat((char *) S0, (char *) S1);

  0254e	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02553	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  02556	51		 push	 ecx
  02557	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0255d	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  02560	50		 push	 eax
  02561	e8 00 00 00 00	 call	 _strcat
  02566	83 c4 08	 add	 esp, 8

; 1100 :     Pop2;

  02569	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0256f	83 e9 08	 sub	 ecx, 8
  02572	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN6@P_strcat:

; 1101 : }

  02578	5d		 pop	 ebp
  02579	c3		 ret	 0
_P_strcat ENDP
; Function compile flags: /Odtp
_P_strlen PROC

; 1104 : {

  02580	55		 push	 ebp
  02581	8b ec		 mov	 ebp, esp

; 1105 :     Sl(1);

  02583	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02588	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0258e	c1 f8 02	 sar	 eax, 2
  02591	83 f8 01	 cmp	 eax, 1
  02594	7d 07		 jge	 SHORT $LN3@P_strlen
  02596	e8 00 00 00 00	 call	 _atl__Esu
  0259b	eb 43		 jmp	 SHORT $LN4@P_strlen
$LN3@P_strlen:

; 1106 :     Hpc(S0);

  0259d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  025a3	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  025a6	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  025ac	72 10		 jb	 SHORT $LN1@P_strlen
  025ae	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  025b3	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  025b6	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  025bc	72 07		 jb	 SHORT $LN2@P_strlen
$LN1@P_strlen:
  025be	e8 00 00 00 00	 call	 _atl__Ebp
  025c3	eb 1b		 jmp	 SHORT $LN4@P_strlen
$LN2@P_strlen:

; 1107 :     S0 = strlen((char *) S0);

  025c5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  025cb	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  025ce	50		 push	 eax
  025cf	e8 00 00 00 00	 call	 _strlen
  025d4	83 c4 04	 add	 esp, 4
  025d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  025dd	89 41 fc	 mov	 DWORD PTR [ecx-4], eax
$LN4@P_strlen:

; 1108 : }

  025e0	5d		 pop	 ebp
  025e1	c3		 ret	 0
_P_strlen ENDP
_TEXT	ENDS
EXTRN	_strcmp:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv84 = -8						; size = 4
_i$ = -4						; size = 4
_P_strcmp PROC

; 1111 : {

  025f0	55		 push	 ebp
  025f1	8b ec		 mov	 ebp, esp
  025f3	83 ec 08	 sub	 esp, 8

; 1112 :     int i;
; 1113 : 
; 1114 :     Sl(2);

  025f6	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  025fb	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  02601	c1 f8 02	 sar	 eax, 2
  02604	83 f8 02	 cmp	 eax, 2
  02607	7d 0a		 jge	 SHORT $LN5@P_strcmp
  02609	e8 00 00 00 00	 call	 _atl__Esu
  0260e	e9 ac 00 00 00	 jmp	 $LN6@P_strcmp
$LN5@P_strcmp:

; 1115 :     Hpc(S0);

  02613	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02619	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  0261c	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  02622	72 10		 jb	 SHORT $LN3@P_strcmp
  02624	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02629	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0262c	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  02632	72 0a		 jb	 SHORT $LN4@P_strcmp
$LN3@P_strcmp:
  02634	e8 00 00 00 00	 call	 _atl__Ebp
  02639	e9 81 00 00 00	 jmp	 $LN6@P_strcmp
$LN4@P_strcmp:

; 1116 :     Hpc(S1);

  0263e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  02644	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  02647	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hs
  0264d	72 11		 jb	 SHORT $LN1@P_strcmp
  0264f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02655	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  02658	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__ht
  0265e	72 07		 jb	 SHORT $LN2@P_strcmp
$LN1@P_strcmp:
  02660	e8 00 00 00 00	 call	 _atl__Ebp
  02665	eb 58		 jmp	 SHORT $LN6@P_strcmp
$LN2@P_strcmp:

; 1117 :     i = strcmp((char *) S1, (char *) S0);

  02667	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0266c	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0266f	51		 push	 ecx
  02670	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  02676	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  02679	50		 push	 eax
  0267a	e8 00 00 00 00	 call	 _strcmp
  0267f	83 c4 08	 add	 esp, 8
  02682	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 1118 :     S1 = (i == 0) ? 0L : ((i > 0) ? 1L : -1L);

  02685	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  02689	75 09		 jne	 SHORT $LN8@P_strcmp
  0268b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv84[ebp], 0
  02692	eb 10		 jmp	 SHORT $LN9@P_strcmp
$LN8@P_strcmp:
  02694	33 c9		 xor	 ecx, ecx
  02696	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  0269a	0f 9f c1	 setg	 cl
  0269d	8d 4c 09 ff	 lea	 ecx, DWORD PTR [ecx+ecx-1]
  026a1	89 4d f8	 mov	 DWORD PTR tv84[ebp], ecx
$LN9@P_strcmp:
  026a4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  026aa	8b 45 f8	 mov	 eax, DWORD PTR tv84[ebp]
  026ad	89 42 f8	 mov	 DWORD PTR [edx-8], eax

; 1119 :     Pop;

  026b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  026b6	83 e9 04	 sub	 ecx, 4
  026b9	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN6@P_strcmp:

; 1120 : }

  026bf	8b e5		 mov	 esp, ebp
  026c1	5d		 pop	 ebp
  026c2	c3		 ret	 0
_P_strcmp ENDP
; Function compile flags: /Odtp
_P_strchar PROC

; 1123 : {

  026d0	55		 push	 ebp
  026d1	8b ec		 mov	 ebp, esp

; 1124 :     Sl(2);

  026d3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  026d8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  026de	c1 f8 02	 sar	 eax, 2
  026e1	83 f8 02	 cmp	 eax, 2
  026e4	7d 0a		 jge	 SHORT $LN5@P_strchar
  026e6	e8 00 00 00 00	 call	 _atl__Esu
  026eb	e9 84 00 00 00	 jmp	 $LN6@P_strchar
$LN5@P_strchar:

; 1125 :     Hpc(S0);

  026f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  026f6	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  026f9	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  026ff	72 10		 jb	 SHORT $LN3@P_strchar
  02701	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02706	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  02709	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  0270f	72 07		 jb	 SHORT $LN4@P_strchar
$LN3@P_strchar:
  02711	e8 00 00 00 00	 call	 _atl__Ebp
  02716	eb 5c		 jmp	 SHORT $LN6@P_strchar
$LN4@P_strchar:

; 1126 :     Hpc(S1);

  02718	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0271e	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  02721	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hs
  02727	72 11		 jb	 SHORT $LN1@P_strchar
  02729	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0272f	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  02732	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__ht
  02738	72 07		 jb	 SHORT $LN2@P_strchar
$LN1@P_strchar:
  0273a	e8 00 00 00 00	 call	 _atl__Ebp
  0273f	eb 33		 jmp	 SHORT $LN6@P_strchar
$LN2@P_strchar:

; 1127 :     S1 = (stackitem) strchr((char *) S1, *((char *) S0));

  02741	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02746	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  02749	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0274c	52		 push	 edx
  0274d	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02752	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  02755	51		 push	 ecx
  02756	e8 00 00 00 00	 call	 _strchr
  0275b	83 c4 08	 add	 esp, 8
  0275e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  02764	89 42 f8	 mov	 DWORD PTR [edx-8], eax

; 1128 :     Pop;

  02767	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0276c	83 e8 04	 sub	 eax, 4
  0276f	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN6@P_strchar:

; 1129 : }

  02774	5d		 pop	 ebp
  02775	c3		 ret	 0
_P_strchar ENDP
; Function compile flags: /Odtp
_sl$ = -24						; size = 4
_ss$ = -20						; size = 4
_se$ = -16						; size = 4
_ds$ = -12						; size = 4
_sn$ = -8						; size = 4
_sp$ = -4						; size = 4
_P_substr PROC

; 1132 : {				      /* source start length/-1 dest -- */

  02780	55		 push	 ebp
  02781	8b ec		 mov	 ebp, esp
  02783	83 ec 18	 sub	 esp, 24			; 00000018H

; 1133 :     long sl, sn;
; 1134 :     char *ss, *sp, *se, *ds;
; 1135 : 
; 1136 :     Sl(4);

  02786	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0278b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  02791	c1 f8 02	 sar	 eax, 2
  02794	83 f8 04	 cmp	 eax, 4
  02797	7d 0a		 jge	 SHORT $LN8@P_substr
  02799	e8 00 00 00 00	 call	 _atl__Esu
  0279e	e9 04 01 00 00	 jmp	 $LN9@P_substr
$LN8@P_substr:

; 1137 :     Hpc(S0);

  027a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  027a9	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  027ac	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  027b2	72 10		 jb	 SHORT $LN6@P_substr
  027b4	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  027b9	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  027bc	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  027c2	72 0a		 jb	 SHORT $LN7@P_substr
$LN6@P_substr:
  027c4	e8 00 00 00 00	 call	 _atl__Ebp
  027c9	e9 d9 00 00 00	 jmp	 $LN9@P_substr
$LN7@P_substr:

; 1138 :     Hpc(S3);

  027ce	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  027d4	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  027d7	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hs
  027dd	72 11		 jb	 SHORT $LN4@P_substr
  027df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  027e5	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  027e8	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__ht
  027ee	72 0a		 jb	 SHORT $LN5@P_substr
$LN4@P_substr:
  027f0	e8 00 00 00 00	 call	 _atl__Ebp
  027f5	e9 ad 00 00 00	 jmp	 $LN9@P_substr
$LN5@P_substr:

; 1139 :     sl = strlen(ss = ((char *) S3));

  027fa	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  027ff	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  02802	89 4d ec	 mov	 DWORD PTR _ss$[ebp], ecx
  02805	8b 55 ec	 mov	 edx, DWORD PTR _ss$[ebp]
  02808	52		 push	 edx
  02809	e8 00 00 00 00	 call	 _strlen
  0280e	83 c4 04	 add	 esp, 4
  02811	89 45 e8	 mov	 DWORD PTR _sl$[ebp], eax

; 1140 :     se = ss + sl;

  02814	8b 45 ec	 mov	 eax, DWORD PTR _ss$[ebp]
  02817	03 45 e8	 add	 eax, DWORD PTR _sl$[ebp]
  0281a	89 45 f0	 mov	 DWORD PTR _se$[ebp], eax

; 1141 :     sp = ((char *) S3) + S2;

  0281d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02823	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  02826	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0282b	03 50 f4	 add	 edx, DWORD PTR [eax-12]
  0282e	89 55 fc	 mov	 DWORD PTR _sp$[ebp], edx

; 1142 :     if ((sn = S1) < 0)

  02831	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02837	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  0283a	89 55 f8	 mov	 DWORD PTR _sn$[ebp], edx
  0283d	83 7d f8 00	 cmp	 DWORD PTR _sn$[ebp], 0
  02841	7d 07		 jge	 SHORT $LN3@P_substr

; 1143 : 	sn = 999999L;

  02843	c7 45 f8 3f 42
	0f 00		 mov	 DWORD PTR _sn$[ebp], 999999 ; 000f423fH
$LN3@P_substr:

; 1144 :     ds = (char *) S0;

  0284a	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0284f	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  02852	89 4d f4	 mov	 DWORD PTR _ds$[ebp], ecx
$LN2@P_substr:

; 1145 :     while (sn-- && (sp < se))

  02855	8b 55 f8	 mov	 edx, DWORD PTR _sn$[ebp]
  02858	8b 45 f8	 mov	 eax, DWORD PTR _sn$[ebp]
  0285b	83 e8 01	 sub	 eax, 1
  0285e	89 45 f8	 mov	 DWORD PTR _sn$[ebp], eax
  02861	85 d2		 test	 edx, edx
  02863	74 26		 je	 SHORT $LN1@P_substr
  02865	8b 4d fc	 mov	 ecx, DWORD PTR _sp$[ebp]
  02868	3b 4d f0	 cmp	 ecx, DWORD PTR _se$[ebp]
  0286b	73 1e		 jae	 SHORT $LN1@P_substr

; 1146 : 	*ds++ = *sp++;

  0286d	8b 55 f4	 mov	 edx, DWORD PTR _ds$[ebp]
  02870	8b 45 fc	 mov	 eax, DWORD PTR _sp$[ebp]
  02873	8a 08		 mov	 cl, BYTE PTR [eax]
  02875	88 0a		 mov	 BYTE PTR [edx], cl
  02877	8b 55 f4	 mov	 edx, DWORD PTR _ds$[ebp]
  0287a	83 c2 01	 add	 edx, 1
  0287d	89 55 f4	 mov	 DWORD PTR _ds$[ebp], edx
  02880	8b 45 fc	 mov	 eax, DWORD PTR _sp$[ebp]
  02883	83 c0 01	 add	 eax, 1
  02886	89 45 fc	 mov	 DWORD PTR _sp$[ebp], eax
  02889	eb ca		 jmp	 SHORT $LN2@P_substr
$LN1@P_substr:

; 1147 :     *ds++ = EOS;

  0288b	8b 4d f4	 mov	 ecx, DWORD PTR _ds$[ebp]
  0288e	c6 01 00	 mov	 BYTE PTR [ecx], 0
  02891	8b 55 f4	 mov	 edx, DWORD PTR _ds$[ebp]
  02894	83 c2 01	 add	 edx, 1
  02897	89 55 f4	 mov	 DWORD PTR _ds$[ebp], edx

; 1148 :     Npop(4);

  0289a	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0289f	83 e8 10	 sub	 eax, 16			; 00000010H
  028a2	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN9@P_substr:

; 1149 : }

  028a7	8b e5		 mov	 esp, ebp
  028a9	5d		 pop	 ebp
  028aa	c3		 ret	 0
_P_substr ENDP
_TEXT	ENDS
EXTRN	_sprintf:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_strform PROC

; 1152 : {                                     /* value "%ld" str -- */

  028b0	55		 push	 ebp
  028b1	8b ec		 mov	 ebp, esp

; 1153 :     Sl(2);

  028b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  028b8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  028be	c1 f8 02	 sar	 eax, 2
  028c1	83 f8 02	 cmp	 eax, 2
  028c4	7d 0a		 jge	 SHORT $LN5@P_strform
  028c6	e8 00 00 00 00	 call	 _atl__Esu
  028cb	e9 83 00 00 00	 jmp	 $LN6@P_strform
$LN5@P_strform:

; 1154 :     Hpc(S0);

  028d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  028d6	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  028d9	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  028df	72 10		 jb	 SHORT $LN3@P_strform
  028e1	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  028e6	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  028e9	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  028ef	72 07		 jb	 SHORT $LN4@P_strform
$LN3@P_strform:
  028f1	e8 00 00 00 00	 call	 _atl__Ebp
  028f6	eb 5b		 jmp	 SHORT $LN6@P_strform
$LN4@P_strform:

; 1155 :     Hpc(S1);

  028f8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  028fe	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  02901	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hs
  02907	72 11		 jb	 SHORT $LN1@P_strform
  02909	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0290f	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  02912	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__ht
  02918	72 07		 jb	 SHORT $LN2@P_strform
$LN1@P_strform:
  0291a	e8 00 00 00 00	 call	 _atl__Ebp
  0291f	eb 32		 jmp	 SHORT $LN6@P_strform
$LN2@P_strform:

; 1156 :     V sprintf((char *) S0, (char *) S1, S2);

  02921	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02926	8b 48 f4	 mov	 ecx, DWORD PTR [eax-12]
  02929	51		 push	 ecx
  0292a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  02930	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  02933	50		 push	 eax
  02934	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0293a	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  0293d	52		 push	 edx
  0293e	e8 00 00 00 00	 call	 _sprintf
  02943	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1157 :     Npop(3);

  02946	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0294b	83 e8 0c	 sub	 eax, 12			; 0000000cH
  0294e	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN6@P_strform:

; 1158 : }

  02953	5d		 pop	 ebp
  02954	c3		 ret	 0
_P_strform ENDP
_TEXT	ENDS
EXTRN	__fltused:DWORD
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_fstrform PROC

; 1162 : {                                     /* rvalue "%6.2f" str -- */

  02960	55		 push	 ebp
  02961	8b ec		 mov	 ebp, esp

; 1163 :     Sl(4);

  02963	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02968	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0296e	c1 f8 02	 sar	 eax, 2
  02971	83 f8 04	 cmp	 eax, 4
  02974	7d 0a		 jge	 SHORT $LN5@P_fstrform
  02976	e8 00 00 00 00	 call	 _atl__Esu
  0297b	e9 89 00 00 00	 jmp	 $LN6@P_fstrform
$LN5@P_fstrform:

; 1164 :     Hpc(S0);

  02980	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02986	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  02989	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  0298f	72 10		 jb	 SHORT $LN3@P_fstrform
  02991	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02996	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  02999	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  0299f	72 07		 jb	 SHORT $LN4@P_fstrform
$LN3@P_fstrform:
  029a1	e8 00 00 00 00	 call	 _atl__Ebp
  029a6	eb 61		 jmp	 SHORT $LN6@P_fstrform
$LN4@P_fstrform:

; 1165 :     Hpc(S1);

  029a8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  029ae	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  029b1	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hs
  029b7	72 11		 jb	 SHORT $LN1@P_fstrform
  029b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  029bf	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  029c2	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__ht
  029c8	72 07		 jb	 SHORT $LN2@P_fstrform
$LN1@P_fstrform:
  029ca	e8 00 00 00 00	 call	 _atl__Ebp
  029cf	eb 38		 jmp	 SHORT $LN6@P_fstrform
$LN2@P_fstrform:

; 1166 :     V sprintf((char *) S0, (char *) S1, REAL1);

  029d1	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  029d6	83 ec 08	 sub	 esp, 8
  029d9	dd 40 f0	 fld	 QWORD PTR [eax-16]
  029dc	dd 1c 24	 fstp	 QWORD PTR [esp]
  029df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  029e5	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  029e8	52		 push	 edx
  029e9	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  029ee	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  029f1	51		 push	 ecx
  029f2	e8 00 00 00 00	 call	 _sprintf
  029f7	83 c4 10	 add	 esp, 16			; 00000010H

; 1167 :     Npop(4);

  029fa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  02a00	83 ea 10	 sub	 edx, 16			; 00000010H
  02a03	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN6@P_fstrform:

; 1168 : }

  02a09	5d		 pop	 ebp
  02a0a	c3		 ret	 0
_P_fstrform ENDP
_TEXT	ENDS
EXTRN	_strtoul:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_eptr$ = -8						; size = 4
_is$ = -4						; size = 4
_P_strint PROC

; 1172 : {				      /* str -- endptr value */

  02a10	55		 push	 ebp
  02a11	8b ec		 mov	 ebp, esp
  02a13	83 ec 08	 sub	 esp, 8

; 1173 :     stackitem is;
; 1174 :     char *eptr;
; 1175 : 
; 1176 :     Sl(1);

  02a16	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02a1b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  02a21	c1 f8 02	 sar	 eax, 2
  02a24	83 f8 01	 cmp	 eax, 1
  02a27	7d 0a		 jge	 SHORT $LN5@P_strint
  02a29	e8 00 00 00 00	 call	 _atl__Esu
  02a2e	e9 9d 00 00 00	 jmp	 $LN6@P_strint
$LN5@P_strint:

; 1177 :     So(1);

  02a33	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02a39	83 c1 04	 add	 ecx, 4
  02a3c	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__sx
  02a42	76 0f		 jbe	 SHORT $LN4@P_strint
  02a44	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  02a4a	83 c2 04	 add	 edx, 4
  02a4d	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sx, edx
$LN4@P_strint:
  02a53	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02a58	83 c0 04	 add	 eax, 4
  02a5b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__st
  02a61	76 07		 jbe	 SHORT $LN3@P_strint
  02a63	e8 00 00 00 00	 call	 _atl__Eso
  02a68	eb 66		 jmp	 SHORT $LN6@P_strint
$LN3@P_strint:

; 1178 :     Hpc(S0);

  02a6a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02a70	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  02a73	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  02a79	72 10		 jb	 SHORT $LN1@P_strint
  02a7b	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02a80	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  02a83	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  02a89	72 07		 jb	 SHORT $LN2@P_strint
$LN1@P_strint:
  02a8b	e8 00 00 00 00	 call	 _atl__Ebp
  02a90	eb 3e		 jmp	 SHORT $LN6@P_strint
$LN2@P_strint:

; 1179 :     is = strtoul((char *) S0, &eptr, 0);

  02a92	6a 00		 push	 0
  02a94	8d 55 f8	 lea	 edx, DWORD PTR _eptr$[ebp]
  02a97	52		 push	 edx
  02a98	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02a9d	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  02aa0	51		 push	 ecx
  02aa1	e8 00 00 00 00	 call	 _strtoul
  02aa6	83 c4 0c	 add	 esp, 12			; 0000000cH
  02aa9	89 45 fc	 mov	 DWORD PTR _is$[ebp], eax

; 1180 :     S0 = (stackitem) eptr;

  02aac	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  02ab2	8b 45 f8	 mov	 eax, DWORD PTR _eptr$[ebp]
  02ab5	89 42 fc	 mov	 DWORD PTR [edx-4], eax

; 1181 :     Push = is;

  02ab8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02abe	8b 55 fc	 mov	 edx, DWORD PTR _is$[ebp]
  02ac1	89 11		 mov	 DWORD PTR [ecx], edx
  02ac3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02ac8	83 c0 04	 add	 eax, 4
  02acb	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN6@P_strint:

; 1182 : }

  02ad0	8b e5		 mov	 esp, ebp
  02ad2	5d		 pop	 ebp
  02ad3	c3		 ret	 0
_P_strint ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_strtod:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_eptr$ = -20						; size = 4
_fsu$ = -16						; size = 8
__$ArrayPad$ = -8					; size = 4
_i$ = -4						; size = 4
_P_strreal PROC

; 1186 : {				      /* str -- endptr value */

  02ae0	55		 push	 ebp
  02ae1	8b ec		 mov	 ebp, esp
  02ae3	83 ec 14	 sub	 esp, 20			; 00000014H
  02ae6	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  02aeb	33 c5		 xor	 eax, ebp
  02aed	89 45 f8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1187 :     int i;
; 1188 :     union {
; 1189 :     	atl_real fs;
; 1190 : 	stackitem fss[Realsize];
; 1191 :     } fsu;
; 1192 :     char *eptr;
; 1193 : 
; 1194 :     Sl(1);

  02af0	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02af5	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  02afb	c1 f8 02	 sar	 eax, 2
  02afe	83 f8 01	 cmp	 eax, 1
  02b01	7d 0a		 jge	 SHORT $LN8@P_strreal
  02b03	e8 00 00 00 00	 call	 _atl__Esu
  02b08	e9 be 00 00 00	 jmp	 $LN1@P_strreal
$LN8@P_strreal:

; 1195 :     So(2);

  02b0d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02b13	83 c1 08	 add	 ecx, 8
  02b16	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__sx
  02b1c	76 0f		 jbe	 SHORT $LN7@P_strreal
  02b1e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  02b24	83 c2 08	 add	 edx, 8
  02b27	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sx, edx
$LN7@P_strreal:
  02b2d	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02b32	83 c0 08	 add	 eax, 8
  02b35	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__st
  02b3b	76 0a		 jbe	 SHORT $LN6@P_strreal
  02b3d	e8 00 00 00 00	 call	 _atl__Eso
  02b42	e9 84 00 00 00	 jmp	 $LN1@P_strreal
$LN6@P_strreal:

; 1196 :     Hpc(S0);

  02b47	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02b4d	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  02b50	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  02b56	72 10		 jb	 SHORT $LN4@P_strreal
  02b58	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02b5d	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  02b60	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  02b66	72 07		 jb	 SHORT $LN5@P_strreal
$LN4@P_strreal:
  02b68	e8 00 00 00 00	 call	 _atl__Ebp
  02b6d	eb 5c		 jmp	 SHORT $LN1@P_strreal
$LN5@P_strreal:

; 1197 :     fsu.fs = strtod((char *) S0, &eptr);

  02b6f	8d 55 ec	 lea	 edx, DWORD PTR _eptr$[ebp]
  02b72	52		 push	 edx
  02b73	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02b78	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  02b7b	51		 push	 ecx
  02b7c	e8 00 00 00 00	 call	 _strtod
  02b81	83 c4 08	 add	 esp, 8
  02b84	dd 5d f0	 fstp	 QWORD PTR _fsu$[ebp]

; 1198 :     S0 = (stackitem) eptr;

  02b87	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  02b8d	8b 45 ec	 mov	 eax, DWORD PTR _eptr$[ebp]
  02b90	89 42 fc	 mov	 DWORD PTR [edx-4], eax

; 1199 :     for (i = 0; i < Realsize; i++) {

  02b93	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  02b9a	eb 09		 jmp	 SHORT $LN3@P_strreal
$LN2@P_strreal:
  02b9c	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  02b9f	83 c1 01	 add	 ecx, 1
  02ba2	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN3@P_strreal:
  02ba5	83 7d fc 02	 cmp	 DWORD PTR _i$[ebp], 2
  02ba9	73 20		 jae	 SHORT $LN1@P_strreal

; 1200 :     	Push = fsu.fss[i];

  02bab	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  02bb1	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  02bb4	8b 4c 85 f0	 mov	 ecx, DWORD PTR _fsu$[ebp+eax*4]
  02bb8	89 0a		 mov	 DWORD PTR [edx], ecx
  02bba	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  02bc0	83 c2 04	 add	 edx, 4
  02bc3	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx

; 1201 :     }

  02bc9	eb d1		 jmp	 SHORT $LN2@P_strreal
$LN1@P_strreal:

; 1202 : }

  02bcb	8b 4d f8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02bce	33 cd		 xor	 ecx, ebp
  02bd0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02bd5	8b e5		 mov	 esp, ebp
  02bd7	5d		 pop	 ebp
  02bd8	c3		 ret	 0
_P_strreal ENDP
_TEXT	ENDS
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_tr$83513 = -16						; size = 8
_i$ = -4						; size = 4
_P_flit	PROC

; 1211 : {

  02be0	55		 push	 ebp
  02be1	8b ec		 mov	 ebp, esp
  02be3	83 ec 10	 sub	 esp, 16			; 00000010H

; 1212 :     int i;
; 1213 : 
; 1214 :     So(Realsize);

  02be6	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02beb	83 c0 08	 add	 eax, 8
  02bee	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__sx
  02bf4	76 0f		 jbe	 SHORT $LN6@P_flit
  02bf6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02bfc	83 c1 08	 add	 ecx, 8
  02bff	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sx, ecx
$LN6@P_flit:
  02c05	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  02c0b	83 c2 08	 add	 edx, 8
  02c0e	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__st
  02c14	76 07		 jbe	 SHORT $LN5@P_flit
  02c16	e8 00 00 00 00	 call	 _atl__Eso
  02c1b	eb 75		 jmp	 SHORT $LN1@P_flit
$LN5@P_flit:

; 1215 : #ifdef TRACE
; 1216 :     if (atl_trace) {

  02c1d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _atl_trace, 0
  02c24	74 27		 je	 SHORT $LN4@P_flit

; 1217 : 	atl_real tr;
; 1218 : 
; 1219 : 	V memcpy((char *) &tr, (char *) ip, sizeof(atl_real));

  02c26	6a 08		 push	 8
  02c28	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__ip
  02c2d	50		 push	 eax
  02c2e	8d 4d f0	 lea	 ecx, DWORD PTR _tr$83513[ebp]
  02c31	51		 push	 ecx
  02c32	e8 00 00 00 00	 call	 _memcpy

; 1220 :         V printf("%g ", tr);

  02c37	83 c4 04	 add	 esp, 4
  02c3a	dd 45 f0	 fld	 QWORD PTR _tr$83513[ebp]
  02c3d	dd 1c 24	 fstp	 QWORD PTR [esp]
  02c40	68 00 00 00 00	 push	 OFFSET $SG83519
  02c45	e8 00 00 00 00	 call	 _printf
  02c4a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@P_flit:

; 1221 :     }
; 1222 : #endif /* TRACE */
; 1223 :     for (i = 0; i < Realsize; i++) {

  02c4d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  02c54	eb 09		 jmp	 SHORT $LN3@P_flit
$LN2@P_flit:
  02c56	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  02c59	83 c2 01	 add	 edx, 1
  02c5c	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN3@P_flit:
  02c5f	83 7d fc 02	 cmp	 DWORD PTR _i$[ebp], 2
  02c63	73 2d		 jae	 SHORT $LN1@P_flit

; 1224 : 	Push = (stackitem) *ip++;

  02c65	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02c6a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__ip
  02c70	8b 11		 mov	 edx, DWORD PTR [ecx]
  02c72	89 10		 mov	 DWORD PTR [eax], edx
  02c74	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02c79	83 c0 04	 add	 eax, 4
  02c7c	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
  02c81	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__ip
  02c87	83 c1 04	 add	 ecx, 4
  02c8a	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__ip, ecx

; 1225 :     }

  02c90	eb c4		 jmp	 SHORT $LN2@P_flit
$LN1@P_flit:

; 1226 : }

  02c92	8b e5		 mov	 esp, ebp
  02c94	5d		 pop	 ebp
  02c95	c3		 ret	 0
_P_flit	ENDP
; Function compile flags: /Odtp
_P_fplus PROC

; 1229 : {

  02ca0	55		 push	 ebp
  02ca1	8b ec		 mov	 ebp, esp

; 1230 :     Sl(2 * Realsize);

  02ca3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02ca8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  02cae	c1 f8 02	 sar	 eax, 2
  02cb1	83 f8 04	 cmp	 eax, 4
  02cb4	73 07		 jae	 SHORT $LN1@P_fplus
  02cb6	e8 00 00 00 00	 call	 _atl__Esu
  02cbb	eb 29		 jmp	 SHORT $LN2@P_fplus
$LN1@P_fplus:

; 1231 :     SREAL1(REAL1 + REAL0);

  02cbd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02cc3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  02cc9	dd 41 f0	 fld	 QWORD PTR [ecx-16]
  02ccc	dc 42 f8	 fadd	 QWORD PTR [edx-8]
  02ccf	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02cd4	dd 58 f0	 fstp	 QWORD PTR [eax-16]

; 1232 :     Realpop;

  02cd7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02cdd	83 e9 08	 sub	 ecx, 8
  02ce0	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN2@P_fplus:

; 1233 : }

  02ce6	5d		 pop	 ebp
  02ce7	c3		 ret	 0
_P_fplus ENDP
; Function compile flags: /Odtp
_P_fminus PROC

; 1236 : {

  02cf0	55		 push	 ebp
  02cf1	8b ec		 mov	 ebp, esp

; 1237 :     Sl(2 * Realsize);

  02cf3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02cf8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  02cfe	c1 f8 02	 sar	 eax, 2
  02d01	83 f8 04	 cmp	 eax, 4
  02d04	73 07		 jae	 SHORT $LN1@P_fminus
  02d06	e8 00 00 00 00	 call	 _atl__Esu
  02d0b	eb 29		 jmp	 SHORT $LN2@P_fminus
$LN1@P_fminus:

; 1238 :     SREAL1(REAL1 - REAL0);

  02d0d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02d13	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  02d19	dd 41 f0	 fld	 QWORD PTR [ecx-16]
  02d1c	dc 62 f8	 fsub	 QWORD PTR [edx-8]
  02d1f	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02d24	dd 58 f0	 fstp	 QWORD PTR [eax-16]

; 1239 :     Realpop;

  02d27	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02d2d	83 e9 08	 sub	 ecx, 8
  02d30	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN2@P_fminus:

; 1240 : }

  02d36	5d		 pop	 ebp
  02d37	c3		 ret	 0
_P_fminus ENDP
; Function compile flags: /Odtp
_P_ftimes PROC

; 1243 : {

  02d40	55		 push	 ebp
  02d41	8b ec		 mov	 ebp, esp

; 1244 :     Sl(2 * Realsize);

  02d43	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02d48	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  02d4e	c1 f8 02	 sar	 eax, 2
  02d51	83 f8 04	 cmp	 eax, 4
  02d54	73 07		 jae	 SHORT $LN1@P_ftimes
  02d56	e8 00 00 00 00	 call	 _atl__Esu
  02d5b	eb 29		 jmp	 SHORT $LN2@P_ftimes
$LN1@P_ftimes:

; 1245 :     SREAL1(REAL1 * REAL0);

  02d5d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02d63	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  02d69	dd 41 f0	 fld	 QWORD PTR [ecx-16]
  02d6c	dc 4a f8	 fmul	 QWORD PTR [edx-8]
  02d6f	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02d74	dd 58 f0	 fstp	 QWORD PTR [eax-16]

; 1246 :     Realpop;

  02d77	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02d7d	83 e9 08	 sub	 ecx, 8
  02d80	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN2@P_ftimes:

; 1247 : }

  02d86	5d		 pop	 ebp
  02d87	c3		 ret	 0
_P_ftimes ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Odtp
CONST	ENDS
_TEXT	SEGMENT
_P_fdiv	PROC

; 1250 : {

  02d90	55		 push	 ebp
  02d91	8b ec		 mov	 ebp, esp

; 1251 :     Sl(2 * Realsize);

  02d93	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02d98	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  02d9e	c1 f8 02	 sar	 eax, 2
  02da1	83 f8 04	 cmp	 eax, 4
  02da4	73 07		 jae	 SHORT $LN2@P_fdiv
  02da6	e8 00 00 00 00	 call	 _atl__Esu
  02dab	eb 44		 jmp	 SHORT $LN3@P_fdiv
$LN2@P_fdiv:

; 1252 : #ifndef NOMEMCHECK
; 1253 :     if (REAL0 == 0.0) {

  02dad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02db3	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  02db6	d9 ee		 fldz
  02db8	da e9		 fucompp
  02dba	df e0		 fnstsw	 ax
  02dbc	f6 c4 44	 test	 ah, 68			; 00000044H
  02dbf	7a 07		 jp	 SHORT $LN1@P_fdiv

; 1254 : 	divzero();

  02dc1	e8 00 00 00 00	 call	 _divzero

; 1255 : 	return;

  02dc6	eb 29		 jmp	 SHORT $LN3@P_fdiv
$LN1@P_fdiv:

; 1256 :     }
; 1257 : #endif /* NOMEMCHECK */
; 1258 :     SREAL1(REAL1 / REAL0);

  02dc8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  02dce	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02dd3	dd 42 f0	 fld	 QWORD PTR [edx-16]
  02dd6	dc 70 f8	 fdiv	 QWORD PTR [eax-8]
  02dd9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02ddf	dd 59 f0	 fstp	 QWORD PTR [ecx-16]

; 1259 :     Realpop;

  02de2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  02de8	83 ea 08	 sub	 edx, 8
  02deb	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN3@P_fdiv:

; 1260 : }

  02df1	5d		 pop	 ebp
  02df2	c3		 ret	 0
_P_fdiv	ENDP
; Function compile flags: /Odtp
tv77 = -8						; size = 8
_P_fmin	PROC

; 1263 : {

  02e00	55		 push	 ebp
  02e01	8b ec		 mov	 ebp, esp
  02e03	83 ec 08	 sub	 esp, 8

; 1264 :     Sl(2 * Realsize);

  02e06	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02e0b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  02e11	c1 f8 02	 sar	 eax, 2
  02e14	83 f8 04	 cmp	 eax, 4
  02e17	73 07		 jae	 SHORT $LN1@P_fmin
  02e19	e8 00 00 00 00	 call	 _atl__Esu
  02e1e	eb 4b		 jmp	 SHORT $LN2@P_fmin
$LN1@P_fmin:

; 1265 :     SREAL1(min(REAL1, REAL0));

  02e20	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02e26	dd 41 f0	 fld	 QWORD PTR [ecx-16]
  02e29	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  02e2f	dc 5a f8	 fcomp	 QWORD PTR [edx-8]
  02e32	df e0		 fnstsw	 ax
  02e34	f6 c4 41	 test	 ah, 65			; 00000041H
  02e37	7a 0d		 jp	 SHORT $LN4@P_fmin
  02e39	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02e3e	dd 40 f0	 fld	 QWORD PTR [eax-16]
  02e41	dd 5d f8	 fstp	 QWORD PTR tv77[ebp]
  02e44	eb 0c		 jmp	 SHORT $LN5@P_fmin
$LN4@P_fmin:
  02e46	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02e4c	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  02e4f	dd 5d f8	 fstp	 QWORD PTR tv77[ebp]
$LN5@P_fmin:
  02e52	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  02e58	dd 45 f8	 fld	 QWORD PTR tv77[ebp]
  02e5b	dd 5a f0	 fstp	 QWORD PTR [edx-16]

; 1266 :     Realpop;

  02e5e	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02e63	83 e8 08	 sub	 eax, 8
  02e66	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN2@P_fmin:

; 1267 : }

  02e6b	8b e5		 mov	 esp, ebp
  02e6d	5d		 pop	 ebp
  02e6e	c3		 ret	 0
_P_fmin	ENDP
; Function compile flags: /Odtp
tv77 = -8						; size = 8
_P_fmax	PROC

; 1270 : {

  02e70	55		 push	 ebp
  02e71	8b ec		 mov	 ebp, esp
  02e73	83 ec 08	 sub	 esp, 8

; 1271 :     Sl(2 * Realsize);

  02e76	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02e7b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  02e81	c1 f8 02	 sar	 eax, 2
  02e84	83 f8 04	 cmp	 eax, 4
  02e87	73 07		 jae	 SHORT $LN1@P_fmax
  02e89	e8 00 00 00 00	 call	 _atl__Esu
  02e8e	eb 4b		 jmp	 SHORT $LN2@P_fmax
$LN1@P_fmax:

; 1272 :     SREAL1(max(REAL1, REAL0));

  02e90	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02e96	dd 41 f0	 fld	 QWORD PTR [ecx-16]
  02e99	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  02e9f	dc 5a f8	 fcomp	 QWORD PTR [edx-8]
  02ea2	df e0		 fnstsw	 ax
  02ea4	f6 c4 41	 test	 ah, 65			; 00000041H
  02ea7	75 0d		 jne	 SHORT $LN4@P_fmax
  02ea9	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02eae	dd 40 f0	 fld	 QWORD PTR [eax-16]
  02eb1	dd 5d f8	 fstp	 QWORD PTR tv77[ebp]
  02eb4	eb 0c		 jmp	 SHORT $LN5@P_fmax
$LN4@P_fmax:
  02eb6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02ebc	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  02ebf	dd 5d f8	 fstp	 QWORD PTR tv77[ebp]
$LN5@P_fmax:
  02ec2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  02ec8	dd 45 f8	 fld	 QWORD PTR tv77[ebp]
  02ecb	dd 5a f0	 fstp	 QWORD PTR [edx-16]

; 1273 :     Realpop;

  02ece	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02ed3	83 e8 08	 sub	 eax, 8
  02ed6	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN2@P_fmax:

; 1274 : }

  02edb	8b e5		 mov	 esp, ebp
  02edd	5d		 pop	 ebp
  02ede	c3		 ret	 0
_P_fmax	ENDP
; Function compile flags: /Odtp
_P_fneg PROC

; 1277 : {

  02ee0	55		 push	 ebp
  02ee1	8b ec		 mov	 ebp, esp

; 1278 :     Sl(Realsize);

  02ee3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02ee8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  02eee	c1 f8 02	 sar	 eax, 2
  02ef1	83 f8 02	 cmp	 eax, 2
  02ef4	73 07		 jae	 SHORT $LN1@P_fneg
  02ef6	e8 00 00 00 00	 call	 _atl__Esu
  02efb	eb 14		 jmp	 SHORT $LN2@P_fneg
$LN1@P_fneg:

; 1279 :     SREAL0(- REAL0);

  02efd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02f03	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  02f06	d9 e0		 fchs
  02f08	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  02f0e	dd 5a f8	 fstp	 QWORD PTR [edx-8]
$LN2@P_fneg:

; 1280 : }

  02f11	5d		 pop	 ebp
  02f12	c3		 ret	 0
_P_fneg	ENDP
; Function compile flags: /Odtp
tv76 = -8						; size = 8
_P_fabs	PROC

; 1283 : {

  02f20	55		 push	 ebp
  02f21	8b ec		 mov	 ebp, esp
  02f23	83 ec 08	 sub	 esp, 8

; 1284 :     Sl(Realsize);

  02f26	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02f2b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  02f31	c1 f8 02	 sar	 eax, 2
  02f34	83 f8 02	 cmp	 eax, 2
  02f37	73 07		 jae	 SHORT $LN1@P_fabs
  02f39	e8 00 00 00 00	 call	 _atl__Esu
  02f3e	eb 3d		 jmp	 SHORT $LN2@P_fabs
$LN1@P_fabs:

; 1285 :     SREAL0(abs(REAL0));

  02f40	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02f46	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  02f49	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@0000000000000000
  02f4f	df e0		 fnstsw	 ax
  02f51	f6 c4 05	 test	 ah, 5
  02f54	7a 10		 jp	 SHORT $LN4@P_fabs
  02f56	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  02f5c	dd 42 f8	 fld	 QWORD PTR [edx-8]
  02f5f	d9 e0		 fchs
  02f61	dd 5d f8	 fstp	 QWORD PTR tv76[ebp]
  02f64	eb 0b		 jmp	 SHORT $LN5@P_fabs
$LN4@P_fabs:
  02f66	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02f6b	dd 40 f8	 fld	 QWORD PTR [eax-8]
  02f6e	dd 5d f8	 fstp	 QWORD PTR tv76[ebp]
$LN5@P_fabs:
  02f71	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02f77	dd 45 f8	 fld	 QWORD PTR tv76[ebp]
  02f7a	dd 59 f8	 fstp	 QWORD PTR [ecx-8]
$LN2@P_fabs:

; 1286 : }

  02f7d	8b e5		 mov	 esp, ebp
  02f7f	5d		 pop	 ebp
  02f80	c3		 ret	 0
_P_fabs	ENDP
; Function compile flags: /Odtp
tv70 = -8						; size = 4
_t$ = -4						; size = 4
_P_fequal PROC

; 1289 : {

  02f90	55		 push	 ebp
  02f91	8b ec		 mov	 ebp, esp
  02f93	83 ec 08	 sub	 esp, 8

; 1290 :     stackitem t;
; 1291 : 
; 1292 :     Sl(2 * Realsize);

  02f96	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  02f9b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  02fa1	c1 f8 02	 sar	 eax, 2
  02fa4	83 f8 04	 cmp	 eax, 4
  02fa7	73 07		 jae	 SHORT $LN1@P_fequal
  02fa9	e8 00 00 00 00	 call	 _atl__Esu
  02fae	eb 5a		 jmp	 SHORT $LN2@P_fequal
$LN1@P_fequal:

; 1293 :     t = (REAL1 == REAL0) ? Truth : Falsity;

  02fb0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02fb6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  02fbc	dd 41 f0	 fld	 QWORD PTR [ecx-16]
  02fbf	dd 42 f8	 fld	 QWORD PTR [edx-8]
  02fc2	da e9		 fucompp
  02fc4	df e0		 fnstsw	 ax
  02fc6	f6 c4 44	 test	 ah, 68			; 00000044H
  02fc9	7a 09		 jp	 SHORT $LN4@P_fequal
  02fcb	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv70[ebp], -1
  02fd2	eb 07		 jmp	 SHORT $LN5@P_fequal
$LN4@P_fequal:
  02fd4	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN5@P_fequal:
  02fdb	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]
  02fde	89 45 fc	 mov	 DWORD PTR _t$[ebp], eax

; 1294 :     Realpop2;

  02fe1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  02fe7	83 e9 10	 sub	 ecx, 16			; 00000010H
  02fea	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx

; 1295 :     Push = t;

  02ff0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  02ff6	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp]
  02ff9	89 02		 mov	 DWORD PTR [edx], eax
  02ffb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03001	83 c1 04	 add	 ecx, 4
  03004	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN2@P_fequal:

; 1296 : }

  0300a	8b e5		 mov	 esp, ebp
  0300c	5d		 pop	 ebp
  0300d	c3		 ret	 0
_P_fequal ENDP
; Function compile flags: /Odtp
tv70 = -8						; size = 4
_t$ = -4						; size = 4
_P_funequal PROC

; 1299 : {

  03010	55		 push	 ebp
  03011	8b ec		 mov	 ebp, esp
  03013	83 ec 08	 sub	 esp, 8

; 1300 :     stackitem t;
; 1301 : 
; 1302 :     Sl(2 * Realsize);

  03016	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0301b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  03021	c1 f8 02	 sar	 eax, 2
  03024	83 f8 04	 cmp	 eax, 4
  03027	73 07		 jae	 SHORT $LN1@P_funequal
  03029	e8 00 00 00 00	 call	 _atl__Esu
  0302e	eb 5a		 jmp	 SHORT $LN2@P_funequal
$LN1@P_funequal:

; 1303 :     t = (REAL1 != REAL0) ? Truth : Falsity;

  03030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03036	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0303c	dd 41 f0	 fld	 QWORD PTR [ecx-16]
  0303f	dd 42 f8	 fld	 QWORD PTR [edx-8]
  03042	da e9		 fucompp
  03044	df e0		 fnstsw	 ax
  03046	f6 c4 44	 test	 ah, 68			; 00000044H
  03049	7b 09		 jnp	 SHORT $LN4@P_funequal
  0304b	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv70[ebp], -1
  03052	eb 07		 jmp	 SHORT $LN5@P_funequal
$LN4@P_funequal:
  03054	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN5@P_funequal:
  0305b	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]
  0305e	89 45 fc	 mov	 DWORD PTR _t$[ebp], eax

; 1304 :     Realpop2;

  03061	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03067	83 e9 10	 sub	 ecx, 16			; 00000010H
  0306a	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx

; 1305 :     Push = t;

  03070	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  03076	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp]
  03079	89 02		 mov	 DWORD PTR [edx], eax
  0307b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03081	83 c1 04	 add	 ecx, 4
  03084	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN2@P_funequal:

; 1306 : }

  0308a	8b e5		 mov	 esp, ebp
  0308c	5d		 pop	 ebp
  0308d	c3		 ret	 0
_P_funequal ENDP
; Function compile flags: /Odtp
tv70 = -8						; size = 4
_t$ = -4						; size = 4
_P_fgtr	PROC

; 1309 : {

  03090	55		 push	 ebp
  03091	8b ec		 mov	 ebp, esp
  03093	83 ec 08	 sub	 esp, 8

; 1310 :     stackitem t;
; 1311 : 
; 1312 :     Sl(2 * Realsize);

  03096	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0309b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  030a1	c1 f8 02	 sar	 eax, 2
  030a4	83 f8 04	 cmp	 eax, 4
  030a7	73 07		 jae	 SHORT $LN1@P_fgtr
  030a9	e8 00 00 00 00	 call	 _atl__Esu
  030ae	eb 58		 jmp	 SHORT $LN2@P_fgtr
$LN1@P_fgtr:

; 1313 :     t = (REAL1 > REAL0) ? Truth : Falsity;

  030b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  030b6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  030bc	dd 42 f8	 fld	 QWORD PTR [edx-8]
  030bf	dc 59 f0	 fcomp	 QWORD PTR [ecx-16]
  030c2	df e0		 fnstsw	 ax
  030c4	f6 c4 05	 test	 ah, 5
  030c7	7a 09		 jp	 SHORT $LN4@P_fgtr
  030c9	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv70[ebp], -1
  030d0	eb 07		 jmp	 SHORT $LN5@P_fgtr
$LN4@P_fgtr:
  030d2	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN5@P_fgtr:
  030d9	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]
  030dc	89 45 fc	 mov	 DWORD PTR _t$[ebp], eax

; 1314 :     Realpop2;

  030df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  030e5	83 e9 10	 sub	 ecx, 16			; 00000010H
  030e8	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx

; 1315 :     Push = t;

  030ee	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  030f4	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp]
  030f7	89 02		 mov	 DWORD PTR [edx], eax
  030f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  030ff	83 c1 04	 add	 ecx, 4
  03102	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN2@P_fgtr:

; 1316 : }

  03108	8b e5		 mov	 esp, ebp
  0310a	5d		 pop	 ebp
  0310b	c3		 ret	 0
_P_fgtr	ENDP
; Function compile flags: /Odtp
tv70 = -8						; size = 4
_t$ = -4						; size = 4
_P_flss	PROC

; 1319 : {

  03110	55		 push	 ebp
  03111	8b ec		 mov	 ebp, esp
  03113	83 ec 08	 sub	 esp, 8

; 1320 :     stackitem t;
; 1321 : 
; 1322 :     Sl(2 * Realsize);

  03116	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0311b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  03121	c1 f8 02	 sar	 eax, 2
  03124	83 f8 04	 cmp	 eax, 4
  03127	73 07		 jae	 SHORT $LN1@P_flss
  03129	e8 00 00 00 00	 call	 _atl__Esu
  0312e	eb 58		 jmp	 SHORT $LN2@P_flss
$LN1@P_flss:

; 1323 :     t = (REAL1 < REAL0) ? Truth : Falsity;

  03130	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03136	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0313c	dd 42 f8	 fld	 QWORD PTR [edx-8]
  0313f	dc 59 f0	 fcomp	 QWORD PTR [ecx-16]
  03142	df e0		 fnstsw	 ax
  03144	f6 c4 41	 test	 ah, 65			; 00000041H
  03147	75 09		 jne	 SHORT $LN4@P_flss
  03149	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv70[ebp], -1
  03150	eb 07		 jmp	 SHORT $LN5@P_flss
$LN4@P_flss:
  03152	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN5@P_flss:
  03159	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]
  0315c	89 45 fc	 mov	 DWORD PTR _t$[ebp], eax

; 1324 :     Realpop2;

  0315f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03165	83 e9 10	 sub	 ecx, 16			; 00000010H
  03168	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx

; 1325 :     Push = t;

  0316e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  03174	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp]
  03177	89 02		 mov	 DWORD PTR [edx], eax
  03179	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0317f	83 c1 04	 add	 ecx, 4
  03182	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN2@P_flss:

; 1326 : }

  03188	8b e5		 mov	 esp, ebp
  0318a	5d		 pop	 ebp
  0318b	c3		 ret	 0
_P_flss	ENDP
; Function compile flags: /Odtp
tv70 = -8						; size = 4
_t$ = -4						; size = 4
_P_fgeq	PROC

; 1329 : {

  03190	55		 push	 ebp
  03191	8b ec		 mov	 ebp, esp
  03193	83 ec 08	 sub	 esp, 8

; 1330 :     stackitem t;
; 1331 : 
; 1332 :     Sl(2 * Realsize);

  03196	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0319b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  031a1	c1 f8 02	 sar	 eax, 2
  031a4	83 f8 04	 cmp	 eax, 4
  031a7	73 07		 jae	 SHORT $LN1@P_fgeq
  031a9	e8 00 00 00 00	 call	 _atl__Esu
  031ae	eb 58		 jmp	 SHORT $LN2@P_fgeq
$LN1@P_fgeq:

; 1333 :     t = (REAL1 >= REAL0) ? Truth : Falsity;

  031b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  031b6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  031bc	dd 42 f8	 fld	 QWORD PTR [edx-8]
  031bf	dc 59 f0	 fcomp	 QWORD PTR [ecx-16]
  031c2	df e0		 fnstsw	 ax
  031c4	f6 c4 41	 test	 ah, 65			; 00000041H
  031c7	7a 09		 jp	 SHORT $LN4@P_fgeq
  031c9	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv70[ebp], -1
  031d0	eb 07		 jmp	 SHORT $LN5@P_fgeq
$LN4@P_fgeq:
  031d2	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN5@P_fgeq:
  031d9	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]
  031dc	89 45 fc	 mov	 DWORD PTR _t$[ebp], eax

; 1334 :     Realpop2;

  031df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  031e5	83 e9 10	 sub	 ecx, 16			; 00000010H
  031e8	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx

; 1335 :     Push = t;

  031ee	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  031f4	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp]
  031f7	89 02		 mov	 DWORD PTR [edx], eax
  031f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  031ff	83 c1 04	 add	 ecx, 4
  03202	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN2@P_fgeq:

; 1336 : }

  03208	8b e5		 mov	 esp, ebp
  0320a	5d		 pop	 ebp
  0320b	c3		 ret	 0
_P_fgeq	ENDP
; Function compile flags: /Odtp
tv70 = -8						; size = 4
_t$ = -4						; size = 4
_P_fleq	PROC

; 1339 : {

  03210	55		 push	 ebp
  03211	8b ec		 mov	 ebp, esp
  03213	83 ec 08	 sub	 esp, 8

; 1340 :     stackitem t;
; 1341 : 
; 1342 :     Sl(2 * Realsize);

  03216	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0321b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  03221	c1 f8 02	 sar	 eax, 2
  03224	83 f8 04	 cmp	 eax, 4
  03227	73 07		 jae	 SHORT $LN1@P_fleq
  03229	e8 00 00 00 00	 call	 _atl__Esu
  0322e	eb 58		 jmp	 SHORT $LN2@P_fleq
$LN1@P_fleq:

; 1343 :     t = (REAL1 <= REAL0) ? Truth : Falsity;

  03230	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03236	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0323c	dd 42 f8	 fld	 QWORD PTR [edx-8]
  0323f	dc 59 f0	 fcomp	 QWORD PTR [ecx-16]
  03242	df e0		 fnstsw	 ax
  03244	f6 c4 01	 test	 ah, 1
  03247	75 09		 jne	 SHORT $LN4@P_fleq
  03249	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv70[ebp], -1
  03250	eb 07		 jmp	 SHORT $LN5@P_fleq
$LN4@P_fleq:
  03252	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN5@P_fleq:
  03259	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]
  0325c	89 45 fc	 mov	 DWORD PTR _t$[ebp], eax

; 1344 :     Realpop2;

  0325f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03265	83 e9 10	 sub	 ecx, 16			; 00000010H
  03268	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx

; 1345 :     Push = t;

  0326e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  03274	8b 45 fc	 mov	 eax, DWORD PTR _t$[ebp]
  03277	89 02		 mov	 DWORD PTR [edx], eax
  03279	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0327f	83 c1 04	 add	 ecx, 4
  03282	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN2@P_fleq:

; 1346 : }

  03288	8b e5		 mov	 esp, ebp
  0328a	5d		 pop	 ebp
  0328b	c3		 ret	 0
_P_fleq	ENDP
; Function compile flags: /Odtp
_P_fdot PROC

; 1349 : {

  03290	55		 push	 ebp
  03291	8b ec		 mov	 ebp, esp

; 1350 :     Sl(Realsize);

  03293	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03298	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0329e	c1 f8 02	 sar	 eax, 2
  032a1	83 f8 02	 cmp	 eax, 2
  032a4	73 07		 jae	 SHORT $LN1@P_fdot
  032a6	e8 00 00 00 00	 call	 _atl__Esu
  032ab	eb 2b		 jmp	 SHORT $LN2@P_fdot
$LN1@P_fdot:

; 1351 :     /* V printf("%g ", REAL0); */
; 1352 : 	V printf("%.16f ", REAL0); /* precision 16 */

  032ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  032b3	83 ec 08	 sub	 esp, 8
  032b6	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  032b9	dd 1c 24	 fstp	 QWORD PTR [esp]
  032bc	68 00 00 00 00	 push	 OFFSET $SG83675
  032c1	e8 00 00 00 00	 call	 _printf
  032c6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1353 : 	
; 1354 : 	
; 1355 :     Realpop;

  032c9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  032cf	83 ea 08	 sub	 edx, 8
  032d2	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN2@P_fdot:

; 1356 : }

  032d8	5d		 pop	 ebp
  032d9	c3		 ret	 0
_P_fdot	ENDP
; Function compile flags: /Odtp
_r$ = -8						; size = 8
_P_float PROC

; 1359 : {

  032e0	55		 push	 ebp
  032e1	8b ec		 mov	 ebp, esp
  032e3	83 ec 08	 sub	 esp, 8

; 1360 :     atl_real r;
; 1361 : 
; 1362 :     Sl(1)

  032e6	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  032eb	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  032f1	c1 f8 02	 sar	 eax, 2
  032f4	83 f8 01	 cmp	 eax, 1
  032f7	7d 07		 jge	 SHORT $LN3@P_float
  032f9	e8 00 00 00 00	 call	 _atl__Esu
  032fe	eb 5d		 jmp	 SHORT $LN4@P_float
$LN3@P_float:

; 1363 :     So(Realsize - 1);

  03300	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03306	83 c1 04	 add	 ecx, 4
  03309	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__sx
  0330f	76 0f		 jbe	 SHORT $LN2@P_float
  03311	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  03317	83 c2 04	 add	 edx, 4
  0331a	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sx, edx
$LN2@P_float:
  03320	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03325	83 c0 04	 add	 eax, 4
  03328	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__st
  0332e	76 07		 jbe	 SHORT $LN1@P_float
  03330	e8 00 00 00 00	 call	 _atl__Eso
  03335	eb 26		 jmp	 SHORT $LN4@P_float
$LN1@P_float:

; 1364 :     r = S0;

  03337	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0333d	db 41 fc	 fild	 DWORD PTR [ecx-4]
  03340	dd 5d f8	 fstp	 QWORD PTR _r$[ebp]

; 1365 :     stk += Realsize - 1;

  03343	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  03349	83 c2 04	 add	 edx, 4
  0334c	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx

; 1366 :     SREAL0(r);

  03352	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03357	dd 45 f8	 fld	 QWORD PTR _r$[ebp]
  0335a	dd 58 f8	 fstp	 QWORD PTR [eax-8]
$LN4@P_float:

; 1367 : }

  0335d	8b e5		 mov	 esp, ebp
  0335f	5d		 pop	 ebp
  03360	c3		 ret	 0
_P_float ENDP
_TEXT	ENDS
EXTRN	__ftol2_sse:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_i$ = -4						; size = 4
_P_fix	PROC

; 1370 : {

  03370	55		 push	 ebp
  03371	8b ec		 mov	 ebp, esp
  03373	51		 push	 ecx

; 1371 :     stackitem i;
; 1372 : 
; 1373 :     Sl(Realsize);

  03374	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03379	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0337f	c1 f8 02	 sar	 eax, 2
  03382	83 f8 02	 cmp	 eax, 2
  03385	73 07		 jae	 SHORT $LN1@P_fix
  03387	e8 00 00 00 00	 call	 _atl__Esu
  0338c	eb 39		 jmp	 SHORT $LN2@P_fix
$LN1@P_fix:

; 1374 :     i = (int) REAL0;

  0338e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03394	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  03397	e8 00 00 00 00	 call	 __ftol2_sse
  0339c	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 1375 :     Realpop;

  0339f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  033a5	83 ea 08	 sub	 edx, 8
  033a8	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx

; 1376 :     Push = i;

  033ae	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  033b3	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  033b6	89 08		 mov	 DWORD PTR [eax], ecx
  033b8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  033be	83 c2 04	 add	 edx, 4
  033c1	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN2@P_fix:

; 1377 : }

  033c7	8b e5		 mov	 esp, ebp
  033c9	5d		 pop	 ebp
  033ca	c3		 ret	 0
_P_fix	ENDP
_TEXT	ENDS
EXTRN	_acos:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_acos	PROC

; 1384 : {

  033d0	55		 push	 ebp
  033d1	8b ec		 mov	 ebp, esp

; 1385 :     Mathfunc(acos);

  033d3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  033d8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  033de	c1 f8 02	 sar	 eax, 2
  033e1	83 f8 02	 cmp	 eax, 2
  033e4	73 07		 jae	 SHORT $LN1@P_acos
  033e6	e8 00 00 00 00	 call	 _atl__Esu
  033eb	eb 20		 jmp	 SHORT $LN2@P_acos
$LN1@P_acos:
  033ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  033f3	83 ec 08	 sub	 esp, 8
  033f6	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  033f9	dd 1c 24	 fstp	 QWORD PTR [esp]
  033fc	e8 00 00 00 00	 call	 _acos
  03401	83 c4 08	 add	 esp, 8
  03404	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0340a	dd 5a f8	 fstp	 QWORD PTR [edx-8]
$LN2@P_acos:

; 1386 : }

  0340d	5d		 pop	 ebp
  0340e	c3		 ret	 0
_P_acos	ENDP
_TEXT	ENDS
EXTRN	_asin:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_asin	PROC

; 1389 : {

  03410	55		 push	 ebp
  03411	8b ec		 mov	 ebp, esp

; 1390 :     Mathfunc(asin);

  03413	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03418	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0341e	c1 f8 02	 sar	 eax, 2
  03421	83 f8 02	 cmp	 eax, 2
  03424	73 07		 jae	 SHORT $LN1@P_asin
  03426	e8 00 00 00 00	 call	 _atl__Esu
  0342b	eb 20		 jmp	 SHORT $LN2@P_asin
$LN1@P_asin:
  0342d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03433	83 ec 08	 sub	 esp, 8
  03436	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  03439	dd 1c 24	 fstp	 QWORD PTR [esp]
  0343c	e8 00 00 00 00	 call	 _asin
  03441	83 c4 08	 add	 esp, 8
  03444	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0344a	dd 5a f8	 fstp	 QWORD PTR [edx-8]
$LN2@P_asin:

; 1391 : }

  0344d	5d		 pop	 ebp
  0344e	c3		 ret	 0
_P_asin	ENDP
_TEXT	ENDS
EXTRN	_atan:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_atan	PROC

; 1394 : {

  03450	55		 push	 ebp
  03451	8b ec		 mov	 ebp, esp

; 1395 :     Mathfunc(atan);

  03453	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03458	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0345e	c1 f8 02	 sar	 eax, 2
  03461	83 f8 02	 cmp	 eax, 2
  03464	73 07		 jae	 SHORT $LN1@P_atan
  03466	e8 00 00 00 00	 call	 _atl__Esu
  0346b	eb 20		 jmp	 SHORT $LN2@P_atan
$LN1@P_atan:
  0346d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03473	83 ec 08	 sub	 esp, 8
  03476	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  03479	dd 1c 24	 fstp	 QWORD PTR [esp]
  0347c	e8 00 00 00 00	 call	 _atan
  03481	83 c4 08	 add	 esp, 8
  03484	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0348a	dd 5a f8	 fstp	 QWORD PTR [edx-8]
$LN2@P_atan:

; 1396 : }

  0348d	5d		 pop	 ebp
  0348e	c3		 ret	 0
_P_atan	ENDP
_TEXT	ENDS
EXTRN	_atan2:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_atan2 PROC

; 1399 : {

  03490	55		 push	 ebp
  03491	8b ec		 mov	 ebp, esp

; 1400 :     Sl(2 * Realsize);

  03493	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03498	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0349e	c1 f8 02	 sar	 eax, 2
  034a1	83 f8 04	 cmp	 eax, 4
  034a4	73 07		 jae	 SHORT $LN1@P_atan2@2
  034a6	e8 00 00 00 00	 call	 _atl__Esu
  034ab	eb 3d		 jmp	 SHORT $LN2@P_atan2@2
$LN1@P_atan2@2:

; 1401 :     SREAL1(atan2(REAL1, REAL0));

  034ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  034b3	83 ec 08	 sub	 esp, 8
  034b6	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  034b9	dd 1c 24	 fstp	 QWORD PTR [esp]
  034bc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  034c2	83 ec 08	 sub	 esp, 8
  034c5	dd 42 f0	 fld	 QWORD PTR [edx-16]
  034c8	dd 1c 24	 fstp	 QWORD PTR [esp]
  034cb	e8 00 00 00 00	 call	 _atan2
  034d0	83 c4 10	 add	 esp, 16			; 00000010H
  034d3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  034d8	dd 58 f0	 fstp	 QWORD PTR [eax-16]

; 1402 :     Realpop;

  034db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  034e1	83 e9 08	 sub	 ecx, 8
  034e4	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN2@P_atan2@2:

; 1403 : }

  034ea	5d		 pop	 ebp
  034eb	c3		 ret	 0
_P_atan2 ENDP
_TEXT	ENDS
EXTRN	_cos:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_cos	PROC

; 1406 : {

  034f0	55		 push	 ebp
  034f1	8b ec		 mov	 ebp, esp

; 1407 :     Mathfunc(cos);

  034f3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  034f8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  034fe	c1 f8 02	 sar	 eax, 2
  03501	83 f8 02	 cmp	 eax, 2
  03504	73 07		 jae	 SHORT $LN1@P_cos
  03506	e8 00 00 00 00	 call	 _atl__Esu
  0350b	eb 20		 jmp	 SHORT $LN2@P_cos
$LN1@P_cos:
  0350d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03513	83 ec 08	 sub	 esp, 8
  03516	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  03519	dd 1c 24	 fstp	 QWORD PTR [esp]
  0351c	e8 00 00 00 00	 call	 _cos
  03521	83 c4 08	 add	 esp, 8
  03524	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0352a	dd 5a f8	 fstp	 QWORD PTR [edx-8]
$LN2@P_cos:

; 1408 : }

  0352d	5d		 pop	 ebp
  0352e	c3		 ret	 0
_P_cos	ENDP
_TEXT	ENDS
EXTRN	_exp:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_exp	PROC

; 1411 : {

  03530	55		 push	 ebp
  03531	8b ec		 mov	 ebp, esp

; 1412 :     Mathfunc(exp);

  03533	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03538	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0353e	c1 f8 02	 sar	 eax, 2
  03541	83 f8 02	 cmp	 eax, 2
  03544	73 07		 jae	 SHORT $LN1@P_exp
  03546	e8 00 00 00 00	 call	 _atl__Esu
  0354b	eb 20		 jmp	 SHORT $LN2@P_exp
$LN1@P_exp:
  0354d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03553	83 ec 08	 sub	 esp, 8
  03556	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  03559	dd 1c 24	 fstp	 QWORD PTR [esp]
  0355c	e8 00 00 00 00	 call	 _exp
  03561	83 c4 08	 add	 esp, 8
  03564	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0356a	dd 5a f8	 fstp	 QWORD PTR [edx-8]
$LN2@P_exp:

; 1413 : }

  0356d	5d		 pop	 ebp
  0356e	c3		 ret	 0
_P_exp	ENDP
_TEXT	ENDS
EXTRN	_log:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_log	PROC

; 1416 : {

  03570	55		 push	 ebp
  03571	8b ec		 mov	 ebp, esp

; 1417 :     Mathfunc(log);

  03573	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03578	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0357e	c1 f8 02	 sar	 eax, 2
  03581	83 f8 02	 cmp	 eax, 2
  03584	73 07		 jae	 SHORT $LN1@P_log
  03586	e8 00 00 00 00	 call	 _atl__Esu
  0358b	eb 20		 jmp	 SHORT $LN2@P_log
$LN1@P_log:
  0358d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03593	83 ec 08	 sub	 esp, 8
  03596	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  03599	dd 1c 24	 fstp	 QWORD PTR [esp]
  0359c	e8 00 00 00 00	 call	 _log
  035a1	83 c4 08	 add	 esp, 8
  035a4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  035aa	dd 5a f8	 fstp	 QWORD PTR [edx-8]
$LN2@P_log:

; 1418 : }

  035ad	5d		 pop	 ebp
  035ae	c3		 ret	 0
_P_log	ENDP
_TEXT	ENDS
EXTRN	_pow:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_pow	PROC

; 1421 : {

  035b0	55		 push	 ebp
  035b1	8b ec		 mov	 ebp, esp

; 1422 :     Sl(2 * Realsize);

  035b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  035b8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  035be	c1 f8 02	 sar	 eax, 2
  035c1	83 f8 04	 cmp	 eax, 4
  035c4	73 07		 jae	 SHORT $LN1@P_pow
  035c6	e8 00 00 00 00	 call	 _atl__Esu
  035cb	eb 3d		 jmp	 SHORT $LN2@P_pow
$LN1@P_pow:

; 1423 :     SREAL1(pow(REAL1, REAL0));

  035cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  035d3	83 ec 08	 sub	 esp, 8
  035d6	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  035d9	dd 1c 24	 fstp	 QWORD PTR [esp]
  035dc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  035e2	83 ec 08	 sub	 esp, 8
  035e5	dd 42 f0	 fld	 QWORD PTR [edx-16]
  035e8	dd 1c 24	 fstp	 QWORD PTR [esp]
  035eb	e8 00 00 00 00	 call	 _pow
  035f0	83 c4 10	 add	 esp, 16			; 00000010H
  035f3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  035f8	dd 58 f0	 fstp	 QWORD PTR [eax-16]

; 1424 :     Realpop;

  035fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03601	83 e9 08	 sub	 ecx, 8
  03604	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN2@P_pow:

; 1425 : }

  0360a	5d		 pop	 ebp
  0360b	c3		 ret	 0
_P_pow	ENDP
_TEXT	ENDS
EXTRN	_sin:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_sin	PROC

; 1428 : {

  03610	55		 push	 ebp
  03611	8b ec		 mov	 ebp, esp

; 1429 :     Mathfunc(sin);

  03613	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03618	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0361e	c1 f8 02	 sar	 eax, 2
  03621	83 f8 02	 cmp	 eax, 2
  03624	73 07		 jae	 SHORT $LN1@P_sin
  03626	e8 00 00 00 00	 call	 _atl__Esu
  0362b	eb 20		 jmp	 SHORT $LN2@P_sin
$LN1@P_sin:
  0362d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03633	83 ec 08	 sub	 esp, 8
  03636	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  03639	dd 1c 24	 fstp	 QWORD PTR [esp]
  0363c	e8 00 00 00 00	 call	 _sin
  03641	83 c4 08	 add	 esp, 8
  03644	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0364a	dd 5a f8	 fstp	 QWORD PTR [edx-8]
$LN2@P_sin:

; 1430 : }

  0364d	5d		 pop	 ebp
  0364e	c3		 ret	 0
_P_sin	ENDP
_TEXT	ENDS
EXTRN	_sqrt:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_sqrt	PROC

; 1433 : {

  03650	55		 push	 ebp
  03651	8b ec		 mov	 ebp, esp

; 1434 :     Mathfunc(sqrt);

  03653	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03658	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0365e	c1 f8 02	 sar	 eax, 2
  03661	83 f8 02	 cmp	 eax, 2
  03664	73 07		 jae	 SHORT $LN1@P_sqrt
  03666	e8 00 00 00 00	 call	 _atl__Esu
  0366b	eb 20		 jmp	 SHORT $LN2@P_sqrt
$LN1@P_sqrt:
  0366d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03673	83 ec 08	 sub	 esp, 8
  03676	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  03679	dd 1c 24	 fstp	 QWORD PTR [esp]
  0367c	e8 00 00 00 00	 call	 _sqrt
  03681	83 c4 08	 add	 esp, 8
  03684	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0368a	dd 5a f8	 fstp	 QWORD PTR [edx-8]
$LN2@P_sqrt:

; 1435 : }

  0368d	5d		 pop	 ebp
  0368e	c3		 ret	 0
_P_sqrt	ENDP
_TEXT	ENDS
EXTRN	_tan:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_tan	PROC

; 1438 : {

  03690	55		 push	 ebp
  03691	8b ec		 mov	 ebp, esp

; 1439 :     Mathfunc(tan);

  03693	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03698	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0369e	c1 f8 02	 sar	 eax, 2
  036a1	83 f8 02	 cmp	 eax, 2
  036a4	73 07		 jae	 SHORT $LN1@P_tan
  036a6	e8 00 00 00 00	 call	 _atl__Esu
  036ab	eb 20		 jmp	 SHORT $LN2@P_tan
$LN1@P_tan:
  036ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  036b3	83 ec 08	 sub	 esp, 8
  036b6	dd 41 f8	 fld	 QWORD PTR [ecx-8]
  036b9	dd 1c 24	 fstp	 QWORD PTR [esp]
  036bc	e8 00 00 00 00	 call	 _tan
  036c1	83 c4 08	 add	 esp, 8
  036c4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  036ca	dd 5a f8	 fstp	 QWORD PTR [edx-8]
$LN2@P_tan:

; 1440 : }

  036cd	5d		 pop	 ebp
  036ce	c3		 ret	 0
_P_tan	ENDP
; Function compile flags: /Odtp
tv71 = -4						; size = 4
_P_dot	PROC

; 1450 : {

  036d0	55		 push	 ebp
  036d1	8b ec		 mov	 ebp, esp
  036d3	51		 push	 ecx

; 1451 :     Sl(1);

  036d4	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  036d9	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  036df	c1 f8 02	 sar	 eax, 2
  036e2	83 f8 01	 cmp	 eax, 1
  036e5	7d 07		 jge	 SHORT $LN1@P_dot
  036e7	e8 00 00 00 00	 call	 _atl__Esu
  036ec	eb 3e		 jmp	 SHORT $LN2@P_dot
$LN1@P_dot:

; 1452 :     V printf(base == 16 ? "%lX" : "%ld ", S0);

  036ee	83 3d 00 00 00
	00 10		 cmp	 DWORD PTR _base, 16	; 00000010H
  036f5	75 09		 jne	 SHORT $LN4@P_dot
  036f7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], OFFSET $SG83790
  036fe	eb 07		 jmp	 SHORT $LN5@P_dot
$LN4@P_dot:
  03700	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], OFFSET $SG83791
$LN5@P_dot:
  03707	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0370d	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  03710	52		 push	 edx
  03711	8b 45 fc	 mov	 eax, DWORD PTR tv71[ebp]
  03714	50		 push	 eax
  03715	e8 00 00 00 00	 call	 _printf
  0371a	83 c4 08	 add	 esp, 8

; 1453 :     Pop;

  0371d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03723	83 e9 04	 sub	 ecx, 4
  03726	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN2@P_dot:

; 1454 : }

  0372c	8b e5		 mov	 esp, ebp
  0372e	5d		 pop	 ebp
  0372f	c3		 ret	 0
_P_dot	ENDP
; Function compile flags: /Odtp
tv76 = -4						; size = 4
_P_question PROC

; 1457 : {

  03730	55		 push	 ebp
  03731	8b ec		 mov	 ebp, esp
  03733	51		 push	 ecx

; 1458 :     Sl(1);

  03734	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03739	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0373f	c1 f8 02	 sar	 eax, 2
  03742	83 f8 01	 cmp	 eax, 1
  03745	7d 07		 jge	 SHORT $LN3@P_question
  03747	e8 00 00 00 00	 call	 _atl__Esu
  0374c	eb 66		 jmp	 SHORT $LN4@P_question
$LN3@P_question:

; 1459 :     Hpc(S0);

  0374e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03754	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  03757	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  0375d	72 10		 jb	 SHORT $LN1@P_question
  0375f	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03764	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  03767	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  0376d	72 07		 jb	 SHORT $LN2@P_question
$LN1@P_question:
  0376f	e8 00 00 00 00	 call	 _atl__Ebp
  03774	eb 3e		 jmp	 SHORT $LN4@P_question
$LN2@P_question:

; 1460 :     V printf(base == 16 ? "%lX" : "%ld ", *((stackitem *) S0));

  03776	83 3d 00 00 00
	00 10		 cmp	 DWORD PTR _base, 16	; 00000010H
  0377d	75 09		 jne	 SHORT $LN6@P_question
  0377f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], OFFSET $SG83801
  03786	eb 07		 jmp	 SHORT $LN7@P_question
$LN6@P_question:
  03788	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], OFFSET $SG83802
$LN7@P_question:
  0378f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  03795	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  03798	8b 08		 mov	 ecx, DWORD PTR [eax]
  0379a	51		 push	 ecx
  0379b	8b 55 fc	 mov	 edx, DWORD PTR tv76[ebp]
  0379e	52		 push	 edx
  0379f	e8 00 00 00 00	 call	 _printf
  037a4	83 c4 08	 add	 esp, 8

; 1461 :     Pop;

  037a7	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  037ac	83 e8 04	 sub	 eax, 4
  037af	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN4@P_question:

; 1462 : }

  037b4	8b e5		 mov	 esp, ebp
  037b6	5d		 pop	 ebp
  037b7	c3		 ret	 0
_P_question ENDP
; Function compile flags: /Odtp
_P_cr	PROC

; 1465 : {

  037c0	55		 push	 ebp
  037c1	8b ec		 mov	 ebp, esp

; 1466 :     V printf("\n");

  037c3	68 00 00 00 00	 push	 OFFSET $SG83806
  037c8	e8 00 00 00 00	 call	 _printf
  037cd	83 c4 04	 add	 esp, 4

; 1467 : }

  037d0	5d		 pop	 ebp
  037d1	c3		 ret	 0
_P_cr	ENDP
; Function compile flags: /Odtp
tv72 = -8						; size = 4
_tsp$ = -4						; size = 4
_P_dots	PROC

; 1470 : {

  037e0	55		 push	 ebp
  037e1	8b ec		 mov	 ebp, esp
  037e3	83 ec 08	 sub	 esp, 8

; 1471 :     stackitem *tsp;
; 1472 : 
; 1473 :     V printf("Stack: ");

  037e6	68 00 00 00 00	 push	 OFFSET $SG83811
  037eb	e8 00 00 00 00	 call	 _printf
  037f0	83 c4 04	 add	 esp, 4

; 1474 :     if (stk == stackbot)

  037f3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  037f8	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__sb
  037fe	75 0f		 jne	 SHORT $LN5@P_dots

; 1475 :         V printf("Empty.");

  03800	68 00 00 00 00	 push	 OFFSET $SG83814
  03805	e8 00 00 00 00	 call	 _printf
  0380a	83 c4 04	 add	 esp, 4

; 1476 :     else {

  0380d	eb 4c		 jmp	 SHORT $LN6@P_dots
$LN5@P_dots:

; 1477 : 	for (tsp = stack; tsp < stk; tsp++) {

  0380f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sk
  03815	89 4d fc	 mov	 DWORD PTR _tsp$[ebp], ecx
  03818	eb 09		 jmp	 SHORT $LN3@P_dots
$LN2@P_dots:
  0381a	8b 55 fc	 mov	 edx, DWORD PTR _tsp$[ebp]
  0381d	83 c2 04	 add	 edx, 4
  03820	89 55 fc	 mov	 DWORD PTR _tsp$[ebp], edx
$LN3@P_dots:
  03823	8b 45 fc	 mov	 eax, DWORD PTR _tsp$[ebp]
  03826	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__sp
  0382c	73 2d		 jae	 SHORT $LN6@P_dots

; 1478 :             V printf(base == 16 ? "%lX" : "%ld ", *tsp);

  0382e	83 3d 00 00 00
	00 10		 cmp	 DWORD PTR _base, 16	; 00000010H
  03835	75 09		 jne	 SHORT $LN8@P_dots
  03837	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], OFFSET $SG83820
  0383e	eb 07		 jmp	 SHORT $LN9@P_dots
$LN8@P_dots:
  03840	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], OFFSET $SG83821
$LN9@P_dots:
  03847	8b 4d fc	 mov	 ecx, DWORD PTR _tsp$[ebp]
  0384a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0384c	52		 push	 edx
  0384d	8b 45 f8	 mov	 eax, DWORD PTR tv72[ebp]
  03850	50		 push	 eax
  03851	e8 00 00 00 00	 call	 _printf
  03856	83 c4 08	 add	 esp, 8

; 1479 : 	}

  03859	eb bf		 jmp	 SHORT $LN2@P_dots
$LN6@P_dots:

; 1480 :     }
; 1481 : }

  0385b	8b e5		 mov	 esp, ebp
  0385d	5d		 pop	 ebp
  0385e	c3		 ret	 0
_P_dots	ENDP
_TEXT	ENDS
_BSS	SEGMENT
_s_dotparen DD	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
_P_dotquote PROC

; 1484 : {

  03860	55		 push	 ebp
  03861	8b ec		 mov	 ebp, esp

; 1485 :     Compiling;

  03863	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hb
  03868	83 38 00	 cmp	 DWORD PTR [eax], 0
  0386b	75 07		 jne	 SHORT $LN3@P_dotquote
  0386d	e8 00 00 00 00	 call	 _notcomp
  03872	eb 5c		 jmp	 SHORT $LN4@P_dotquote
$LN3@P_dotquote:

; 1486 :     stringlit = True;		      /* Set string literal expected */

  03874	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _stringlit, 1

; 1487 :     Compconst(s_dotparen);	      /* Compile .( word */

  0387e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  03884	83 c1 04	 add	 ecx, 4
  03887	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__hx
  0388d	76 0f		 jbe	 SHORT $LN2@P_dotquote
  0388f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  03895	83 c2 04	 add	 edx, 4
  03898	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hx, edx
$LN2@P_dotquote:
  0389e	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  038a3	83 c0 04	 add	 eax, 4
  038a6	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__ht
  038ac	76 07		 jbe	 SHORT $LN1@P_dotquote
  038ae	e8 00 00 00 00	 call	 _atl__Eho
  038b3	eb 1b		 jmp	 SHORT $LN4@P_dotquote
$LN1@P_dotquote:
  038b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  038bb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _s_dotparen
  038c1	89 11		 mov	 DWORD PTR [ecx], edx
  038c3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  038c8	83 c0 04	 add	 eax, 4
  038cb	a3 00 00 00 00	 mov	 DWORD PTR _atl__hp, eax
$LN4@P_dotquote:

; 1488 : }

  038d0	5d		 pop	 ebp
  038d1	c3		 ret	 0
_P_dotquote ENDP
; Function compile flags: /Odtp
_P_dotparen PROC

; 1491 : {

  038e0	55		 push	 ebp
  038e1	8b ec		 mov	 ebp, esp

; 1492 :     if (ip == NULL) {		      /* If interpreting */

  038e3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _atl__ip, 0
  038ea	75 0c		 jne	 SHORT $LN2@P_dotparen

; 1493 : 	stringlit = True;	      /* Set to print next string constant */

  038ec	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _stringlit, 1

; 1494 :     } else {			      /* Otherwise, */

  038f6	eb 2d		 jmp	 SHORT $LN3@P_dotparen
$LN2@P_dotparen:

; 1495 :         V printf("%s", ((char *) ip) + 1); /* print string literal

  038f8	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__ip
  038fd	83 c0 01	 add	 eax, 1
  03900	50		 push	 eax
  03901	68 00 00 00 00	 push	 OFFSET $SG83835
  03906	e8 00 00 00 00	 call	 _printf
  0390b	83 c4 08	 add	 esp, 8

; 1496 : 					 in in-line code. */
; 1497 : 	Skipstring;		      /* And advance IP past it */

  0390e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__ip
  03914	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  03917	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__ip
  0391c	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  0391f	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__ip, ecx
$LN3@P_dotparen:

; 1498 :     }
; 1499 : }

  03925	5d		 pop	 ebp
  03926	c3		 ret	 0
_P_dotparen ENDP
; Function compile flags: /Odtp
_P_type PROC

; 1502 : {

  03930	55		 push	 ebp
  03931	8b ec		 mov	 ebp, esp

; 1503 :     Sl(1);

  03933	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03938	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0393e	c1 f8 02	 sar	 eax, 2
  03941	83 f8 01	 cmp	 eax, 1
  03944	7d 07		 jge	 SHORT $LN3@P_type
  03946	e8 00 00 00 00	 call	 _atl__Esu
  0394b	eb 4e		 jmp	 SHORT $LN4@P_type
$LN3@P_type:

; 1504 :     Hpc(S0);

  0394d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03953	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  03956	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  0395c	72 10		 jb	 SHORT $LN1@P_type
  0395e	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03963	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  03966	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  0396c	72 07		 jb	 SHORT $LN2@P_type
$LN1@P_type:
  0396e	e8 00 00 00 00	 call	 _atl__Ebp
  03973	eb 26		 jmp	 SHORT $LN4@P_type
$LN2@P_type:

; 1505 :     V printf("%s", (char *) S0);

  03975	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0397b	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  0397e	50		 push	 eax
  0397f	68 00 00 00 00	 push	 OFFSET $SG83846
  03984	e8 00 00 00 00	 call	 _printf
  03989	83 c4 08	 add	 esp, 8

; 1506 :     Pop;

  0398c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03992	83 e9 04	 sub	 ecx, 4
  03995	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN4@P_type:

; 1507 : }

  0399b	5d		 pop	 ebp
  0399c	c3		 ret	 0
_P_type	ENDP
; Function compile flags: /Odtp
_dw$ = -8						; size = 4
_key$ = -4						; size = 4
_P_words PROC

; 1510 : {

  039a0	55		 push	 ebp
  039a1	8b ec		 mov	 ebp, esp
  039a3	83 ec 08	 sub	 esp, 8

; 1511 : #ifndef Keyhit
; 1512 :     int key = 0;

  039a6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _key$[ebp], 0

; 1513 : #endif
; 1514 :     dictword *dw = dict;

  039ad	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__dh
  039b2	89 45 f8	 mov	 DWORD PTR _dw$[ebp], eax
$LN3@P_words:

; 1515 : 
; 1516 :     while (dw != NULL) {

  039b5	83 7d f8 00	 cmp	 DWORD PTR _dw$[ebp], 0
  039b9	74 32		 je	 SHORT $LN2@P_words

; 1517 : 
; 1518 :         V printf("\n%s", dw->wname + 1);

  039bb	8b 4d f8	 mov	 ecx, DWORD PTR _dw$[ebp]
  039be	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  039c1	83 c2 01	 add	 edx, 1
  039c4	52		 push	 edx
  039c5	68 00 00 00 00	 push	 OFFSET $SG83856
  039ca	e8 00 00 00 00	 call	 _printf
  039cf	83 c4 08	 add	 esp, 8

; 1519 : 	dw = dw->wnext;

  039d2	8b 45 f8	 mov	 eax, DWORD PTR _dw$[ebp]
  039d5	8b 08		 mov	 ecx, DWORD PTR [eax]
  039d7	89 4d f8	 mov	 DWORD PTR _dw$[ebp], ecx

; 1520 : #ifdef Keyhit
; 1521 : 	if (kbquit()) {
; 1522 : 	    break;
; 1523 : 	}
; 1524 : #else
; 1525 :         /* If this system can't trap keystrokes, just stop the WORDS
; 1526 : 	   listing after 20 words. */
; 1527 : 	if (++key >= 20)

  039da	8b 55 fc	 mov	 edx, DWORD PTR _key$[ebp]
  039dd	83 c2 01	 add	 edx, 1
  039e0	89 55 fc	 mov	 DWORD PTR _key$[ebp], edx
  039e3	83 7d fc 14	 cmp	 DWORD PTR _key$[ebp], 20 ; 00000014H
  039e7	7c 02		 jl	 SHORT $LN1@P_words

; 1528 : 	    break;

  039e9	eb 02		 jmp	 SHORT $LN2@P_words
$LN1@P_words:

; 1529 : #endif
; 1530 :     }

  039eb	eb c8		 jmp	 SHORT $LN3@P_words
$LN2@P_words:

; 1531 :     V printf("\n");

  039ed	68 00 00 00 00	 push	 OFFSET $SG83859
  039f2	e8 00 00 00 00	 call	 _printf
  039f7	83 c4 04	 add	 esp, 4

; 1532 : }

  039fa	8b e5		 mov	 esp, ebp
  039fc	5d		 pop	 ebp
  039fd	c3		 ret	 0
_P_words ENDP
; Function compile flags: /Odtp
_P_file PROC

; 1538 : {

  03a00	55		 push	 ebp
  03a01	8b ec		 mov	 ebp, esp

; 1539 :     Ho(2);

  03a03	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  03a08	83 c0 08	 add	 eax, 8
  03a0b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hx
  03a11	76 0f		 jbe	 SHORT $LN2@P_file
  03a13	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  03a19	83 c1 08	 add	 ecx, 8
  03a1c	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hx, ecx
$LN2@P_file:
  03a22	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  03a28	83 c2 08	 add	 edx, 8
  03a2b	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__ht
  03a31	76 07		 jbe	 SHORT $LN1@P_file
  03a33	e8 00 00 00 00	 call	 _atl__Eho
  03a38	eb 38		 jmp	 SHORT $LN3@P_file
$LN1@P_file:

; 1540 :     P_create(); 		      /* Create variable */

  03a3a	e8 00 00 00 00	 call	 _atl__Pcr

; 1541 :     Hstore = FileSent;		      /* Store file sentinel */

  03a3f	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  03a44	c7 00 9d df 1f
	83		 mov	 DWORD PTR [eax], -2095063139 ; 831fdf9dH
  03a4a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  03a50	83 c1 04	 add	 ecx, 4
  03a53	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hp, ecx

; 1542 :     Hstore = 0; 		      /* Mark file not open */

  03a59	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  03a5f	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  03a65	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  03a6a	83 c0 04	 add	 eax, 4
  03a6d	a3 00 00 00 00	 mov	 DWORD PTR _atl__hp, eax
$LN3@P_file:

; 1543 : }

  03a72	5d		 pop	 ebp
  03a73	c3		 ret	 0
_P_file	ENDP
_TEXT	ENDS
EXTRN	_fopen:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_fd$ = -8						; size = 4
_stat$ = -4						; size = 4
_P_fopen PROC

; 1546 : {

  03a80	55		 push	 ebp
  03a81	8b ec		 mov	 ebp, esp
  03a83	83 ec 08	 sub	 esp, 8

; 1547 :     FILE *fd;
; 1548 :     stackitem stat;
; 1549 : 
; 1550 :     Sl(3);

  03a86	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03a8b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  03a91	c1 f8 02	 sar	 eax, 2
  03a94	83 f8 03	 cmp	 eax, 3
  03a97	7d 0a		 jge	 SHORT $LN10@P_fopen
  03a99	e8 00 00 00 00	 call	 _atl__Esu
  03a9e	e9 05 01 00 00	 jmp	 $LN11@P_fopen
$LN10@P_fopen:

; 1551 :     Hpc(S2);

  03aa3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03aa9	8b 51 f4	 mov	 edx, DWORD PTR [ecx-12]
  03aac	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  03ab2	72 10		 jb	 SHORT $LN8@P_fopen
  03ab4	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03ab9	8b 48 f4	 mov	 ecx, DWORD PTR [eax-12]
  03abc	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  03ac2	72 0a		 jb	 SHORT $LN9@P_fopen
$LN8@P_fopen:
  03ac4	e8 00 00 00 00	 call	 _atl__Ebp
  03ac9	e9 da 00 00 00	 jmp	 $LN11@P_fopen
$LN9@P_fopen:

; 1552 :     Hpc(S0);

  03ace	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  03ad4	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  03ad7	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hs
  03add	72 11		 jb	 SHORT $LN6@P_fopen
  03adf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03ae5	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  03ae8	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__ht
  03aee	72 0a		 jb	 SHORT $LN7@P_fopen
$LN6@P_fopen:
  03af0	e8 00 00 00 00	 call	 _atl__Ebp
  03af5	e9 ae 00 00 00	 jmp	 $LN11@P_fopen
$LN7@P_fopen:

; 1553 :     Isfile(S0);

  03afa	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03aff	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  03b02	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__hs
  03b08	72 11		 jb	 SHORT $LN4@P_fopen
  03b0a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  03b10	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  03b13	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__ht
  03b19	72 0a		 jb	 SHORT $LN5@P_fopen
$LN4@P_fopen:
  03b1b	e8 00 00 00 00	 call	 _atl__Ebp
  03b20	e9 83 00 00 00	 jmp	 $LN11@P_fopen
$LN5@P_fopen:
  03b25	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03b2b	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  03b2e	81 3a 9d df 1f
	83		 cmp	 DWORD PTR [edx], -2095063139 ; 831fdf9dH
  03b34	74 0f		 je	 SHORT $LN3@P_fopen
  03b36	68 00 00 00 00	 push	 OFFSET $SG83884
  03b3b	e8 00 00 00 00	 call	 _printf
  03b40	83 c4 04	 add	 esp, 4
  03b43	eb 63		 jmp	 SHORT $LN11@P_fopen
$LN3@P_fopen:

; 1554 :     fd = fopen((char *) S2, fopenmodes[S1]);

  03b45	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03b4a	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  03b4d	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _fopenmodes[ecx*4]
  03b54	52		 push	 edx
  03b55	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03b5a	8b 48 f4	 mov	 ecx, DWORD PTR [eax-12]
  03b5d	51		 push	 ecx
  03b5e	e8 00 00 00 00	 call	 _fopen
  03b63	83 c4 08	 add	 esp, 8
  03b66	89 45 f8	 mov	 DWORD PTR _fd$[ebp], eax

; 1555 :     if (fd == NULL) {

  03b69	83 7d f8 00	 cmp	 DWORD PTR _fd$[ebp], 0
  03b6d	75 09		 jne	 SHORT $LN2@P_fopen

; 1556 : 	stat = Falsity;

  03b6f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _stat$[ebp], 0

; 1557 :     } else {

  03b76	eb 16		 jmp	 SHORT $LN1@P_fopen
$LN2@P_fopen:

; 1558 : 	*(((stackitem *) S0) + 1) = (stackitem) fd;

  03b78	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  03b7e	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  03b81	8b 4d f8	 mov	 ecx, DWORD PTR _fd$[ebp]
  03b84	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1559 : 	stat = Truth;

  03b87	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _stat$[ebp], -1
$LN1@P_fopen:

; 1560 :     }
; 1561 :     Pop2;

  03b8e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  03b94	83 ea 08	 sub	 edx, 8
  03b97	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx

; 1562 :     S0 = stat;

  03b9d	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03ba2	8b 4d fc	 mov	 ecx, DWORD PTR _stat$[ebp]
  03ba5	89 48 fc	 mov	 DWORD PTR [eax-4], ecx
$LN11@P_fopen:

; 1563 : }

  03ba8	8b e5		 mov	 esp, ebp
  03baa	5d		 pop	 ebp
  03bab	c3		 ret	 0
_P_fopen ENDP
_TEXT	ENDS
EXTRN	_fclose:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_fclose PROC

; 1566 : {

  03bb0	55		 push	 ebp
  03bb1	8b ec		 mov	 ebp, esp

; 1567 :     Sl(1);

  03bb3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03bb8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  03bbe	c1 f8 02	 sar	 eax, 2
  03bc1	83 f8 01	 cmp	 eax, 1
  03bc4	7d 0a		 jge	 SHORT $LN7@P_fclose
  03bc6	e8 00 00 00 00	 call	 _atl__Esu
  03bcb	e9 c3 00 00 00	 jmp	 $LN8@P_fclose
$LN7@P_fclose:

; 1568 :     Hpc(S0);

  03bd0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03bd6	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  03bd9	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  03bdf	72 10		 jb	 SHORT $LN5@P_fclose
  03be1	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03be6	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  03be9	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  03bef	72 0a		 jb	 SHORT $LN6@P_fclose
$LN5@P_fclose:
  03bf1	e8 00 00 00 00	 call	 _atl__Ebp
  03bf6	e9 98 00 00 00	 jmp	 $LN8@P_fclose
$LN6@P_fclose:

; 1569 :     Isfile(S0);

  03bfb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  03c01	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  03c04	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hs
  03c0a	72 11		 jb	 SHORT $LN3@P_fclose
  03c0c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03c12	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  03c15	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__ht
  03c1b	72 07		 jb	 SHORT $LN4@P_fclose
$LN3@P_fclose:
  03c1d	e8 00 00 00 00	 call	 _atl__Ebp
  03c22	eb 6f		 jmp	 SHORT $LN8@P_fclose
$LN4@P_fclose:
  03c24	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03c29	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  03c2c	81 39 9d df 1f
	83		 cmp	 DWORD PTR [ecx], -2095063139 ; 831fdf9dH
  03c32	74 0f		 je	 SHORT $LN2@P_fclose
  03c34	68 00 00 00 00	 push	 OFFSET $SG83905
  03c39	e8 00 00 00 00	 call	 _printf
  03c3e	83 c4 04	 add	 esp, 4
  03c41	eb 50		 jmp	 SHORT $LN8@P_fclose
$LN2@P_fclose:

; 1570 :     Isopen(S0);

  03c43	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  03c49	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  03c4c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  03c50	75 0f		 jne	 SHORT $LN1@P_fclose
  03c52	68 00 00 00 00	 push	 OFFSET $SG83911
  03c57	e8 00 00 00 00	 call	 _printf
  03c5c	83 c4 04	 add	 esp, 4
  03c5f	eb 32		 jmp	 SHORT $LN8@P_fclose
$LN1@P_fclose:

; 1571 :     V fclose(FileD(S0));

  03c61	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03c67	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  03c6a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  03c6d	50		 push	 eax
  03c6e	e8 00 00 00 00	 call	 _fclose
  03c73	83 c4 04	 add	 esp, 4

; 1572 :     *(((stackitem *) S0) + 1) = (stackitem) NULL;

  03c76	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03c7c	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  03c7f	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 1573 :     Pop;

  03c86	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03c8b	83 e8 04	 sub	 eax, 4
  03c8e	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN8@P_fclose:

; 1574 : }

  03c93	5d		 pop	 ebp
  03c94	c3		 ret	 0
_P_fclose ENDP
_TEXT	ENDS
EXTRN	__unlink:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_fdelete PROC

; 1577 : {

  03ca0	55		 push	 ebp
  03ca1	8b ec		 mov	 ebp, esp

; 1578 :     Sl(1);

  03ca3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03ca8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  03cae	c1 f8 02	 sar	 eax, 2
  03cb1	83 f8 01	 cmp	 eax, 1
  03cb4	7d 07		 jge	 SHORT $LN3@P_fdelete
  03cb6	e8 00 00 00 00	 call	 _atl__Esu
  03cbb	eb 4c		 jmp	 SHORT $LN4@P_fdelete
$LN3@P_fdelete:

; 1579 :     Hpc(S0);

  03cbd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03cc3	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  03cc6	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  03ccc	72 10		 jb	 SHORT $LN1@P_fdelete
  03cce	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03cd3	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  03cd6	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  03cdc	72 07		 jb	 SHORT $LN2@P_fdelete
$LN1@P_fdelete:
  03cde	e8 00 00 00 00	 call	 _atl__Ebp
  03ce3	eb 24		 jmp	 SHORT $LN4@P_fdelete
$LN2@P_fdelete:

; 1580 :     S0 = (unlink((char *) S0) == 0) ? Truth : Falsity;

  03ce5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  03ceb	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  03cee	50		 push	 eax
  03cef	e8 00 00 00 00	 call	 __unlink
  03cf4	83 c4 04	 add	 esp, 4
  03cf7	f7 d8		 neg	 eax
  03cf9	1b c0		 sbb	 eax, eax
  03cfb	f7 d8		 neg	 eax
  03cfd	83 e8 01	 sub	 eax, 1
  03d00	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03d06	89 41 fc	 mov	 DWORD PTR [ecx-4], eax
$LN4@P_fdelete:

; 1581 : }

  03d09	5d		 pop	 ebp
  03d0a	c3		 ret	 0
_P_fdelete ENDP
; Function compile flags: /Odtp
_P_fgetline PROC

; 1584 : {

  03d10	55		 push	 ebp
  03d11	8b ec		 mov	 ebp, esp

; 1585 :     Sl(2);

  03d13	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03d18	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  03d1e	c1 f8 02	 sar	 eax, 2
  03d21	83 f8 02	 cmp	 eax, 2
  03d24	7d 0a		 jge	 SHORT $LN9@P_fgetline
  03d26	e8 00 00 00 00	 call	 _atl__Esu
  03d2b	e9 e6 00 00 00	 jmp	 $LN10@P_fgetline
$LN9@P_fgetline:

; 1586 :     Hpc(S0);

  03d30	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03d36	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  03d39	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  03d3f	72 10		 jb	 SHORT $LN7@P_fgetline
  03d41	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03d46	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  03d49	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  03d4f	72 0a		 jb	 SHORT $LN8@P_fgetline
$LN7@P_fgetline:
  03d51	e8 00 00 00 00	 call	 _atl__Ebp
  03d56	e9 bb 00 00 00	 jmp	 $LN10@P_fgetline
$LN8@P_fgetline:

; 1587 :     Isfile(S1);

  03d5b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  03d61	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  03d64	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hs
  03d6a	72 11		 jb	 SHORT $LN5@P_fgetline
  03d6c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03d72	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  03d75	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__ht
  03d7b	72 0a		 jb	 SHORT $LN6@P_fgetline
$LN5@P_fgetline:
  03d7d	e8 00 00 00 00	 call	 _atl__Ebp
  03d82	e9 8f 00 00 00	 jmp	 $LN10@P_fgetline
$LN6@P_fgetline:
  03d87	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03d8c	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  03d8f	81 39 9d df 1f
	83		 cmp	 DWORD PTR [ecx], -2095063139 ; 831fdf9dH
  03d95	74 0f		 je	 SHORT $LN4@P_fgetline
  03d97	68 00 00 00 00	 push	 OFFSET $SG83940
  03d9c	e8 00 00 00 00	 call	 _printf
  03da1	83 c4 04	 add	 esp, 4
  03da4	eb 70		 jmp	 SHORT $LN10@P_fgetline
$LN4@P_fgetline:

; 1588 :     Isopen(S1);

  03da6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  03dac	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  03daf	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  03db3	75 0f		 jne	 SHORT $LN3@P_fgetline
  03db5	68 00 00 00 00	 push	 OFFSET $SG83946
  03dba	e8 00 00 00 00	 call	 _printf
  03dbf	83 c4 04	 add	 esp, 4
  03dc2	eb 52		 jmp	 SHORT $LN10@P_fgetline
$LN3@P_fgetline:

; 1589 :     if (atl_fgetsp((char *) S0, 132, FileD(S1)) == NULL) {

  03dc4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03dca	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  03dcd	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  03dd0	50		 push	 eax
  03dd1	68 84 00 00 00	 push	 132			; 00000084H
  03dd6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03ddc	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  03ddf	52		 push	 edx
  03de0	e8 00 00 00 00	 call	 _atl_fgetsp
  03de5	83 c4 0c	 add	 esp, 12			; 0000000cH
  03de8	85 c0		 test	 eax, eax
  03dea	75 0e		 jne	 SHORT $LN2@P_fgetline

; 1590 : 	S1 = Falsity;

  03dec	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03df1	c7 40 f8 00 00
	00 00		 mov	 DWORD PTR [eax-8], 0

; 1591 :     } else {

  03df8	eb 0d		 jmp	 SHORT $LN1@P_fgetline
$LN2@P_fgetline:

; 1592 : 	S1 = Truth;

  03dfa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03e00	c7 41 f8 ff ff
	ff ff		 mov	 DWORD PTR [ecx-8], -1
$LN1@P_fgetline:

; 1593 :     }
; 1594 :     Pop;

  03e07	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  03e0d	83 ea 04	 sub	 edx, 4
  03e10	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN10@P_fgetline:

; 1595 : }

  03e16	5d		 pop	 ebp
  03e17	c3		 ret	 0
_P_fgetline ENDP
_TEXT	ENDS
EXTRN	_putc:PROC
EXTRN	_fputs:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_fputline PROC

; 1598 : {

  03e20	55		 push	 ebp
  03e21	8b ec		 mov	 ebp, esp

; 1599 :     Sl(2);

  03e23	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03e28	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  03e2e	c1 f8 02	 sar	 eax, 2
  03e31	83 f8 02	 cmp	 eax, 2
  03e34	7d 0a		 jge	 SHORT $LN9@P_fputline
  03e36	e8 00 00 00 00	 call	 _atl__Esu
  03e3b	e9 ff 00 00 00	 jmp	 $LN10@P_fputline
$LN9@P_fputline:

; 1600 :     Hpc(S1);

  03e40	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03e46	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  03e49	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  03e4f	72 10		 jb	 SHORT $LN7@P_fputline
  03e51	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03e56	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  03e59	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  03e5f	72 0a		 jb	 SHORT $LN8@P_fputline
$LN7@P_fputline:
  03e61	e8 00 00 00 00	 call	 _atl__Ebp
  03e66	e9 d4 00 00 00	 jmp	 $LN10@P_fputline
$LN8@P_fputline:

; 1601 :     Isfile(S0);

  03e6b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  03e71	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  03e74	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hs
  03e7a	72 11		 jb	 SHORT $LN5@P_fputline
  03e7c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03e82	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  03e85	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__ht
  03e8b	72 0a		 jb	 SHORT $LN6@P_fputline
$LN5@P_fputline:
  03e8d	e8 00 00 00 00	 call	 _atl__Ebp
  03e92	e9 a8 00 00 00	 jmp	 $LN10@P_fputline
$LN6@P_fputline:
  03e97	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03e9c	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  03e9f	81 39 9d df 1f
	83		 cmp	 DWORD PTR [ecx], -2095063139 ; 831fdf9dH
  03ea5	74 12		 je	 SHORT $LN4@P_fputline
  03ea7	68 00 00 00 00	 push	 OFFSET $SG83967
  03eac	e8 00 00 00 00	 call	 _printf
  03eb1	83 c4 04	 add	 esp, 4
  03eb4	e9 86 00 00 00	 jmp	 $LN10@P_fputline
$LN4@P_fputline:

; 1602 :     Isopen(S0);

  03eb9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  03ebf	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  03ec2	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  03ec6	75 0f		 jne	 SHORT $LN3@P_fputline
  03ec8	68 00 00 00 00	 push	 OFFSET $SG83973
  03ecd	e8 00 00 00 00	 call	 _printf
  03ed2	83 c4 04	 add	 esp, 4
  03ed5	eb 68		 jmp	 SHORT $LN10@P_fputline
$LN3@P_fputline:

; 1603 :     if (fputs((char *) S1, FileD(S0)) == EOF) {

  03ed7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03edd	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  03ee0	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  03ee3	50		 push	 eax
  03ee4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03eea	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  03eed	52		 push	 edx
  03eee	e8 00 00 00 00	 call	 _fputs
  03ef3	83 c4 08	 add	 esp, 8
  03ef6	83 f8 ff	 cmp	 eax, -1
  03ef9	75 0e		 jne	 SHORT $LN2@P_fputline

; 1604 : 	S1 = Falsity;

  03efb	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03f00	c7 40 f8 00 00
	00 00		 mov	 DWORD PTR [eax-8], 0

; 1605 :     } else {

  03f07	eb 27		 jmp	 SHORT $LN1@P_fputline
$LN2@P_fputline:

; 1606 :         S1 = putc('\n', FileD(S0)) == EOF ? Falsity : Truth;

  03f09	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03f0f	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  03f12	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  03f15	50		 push	 eax
  03f16	6a 0a		 push	 10			; 0000000aH
  03f18	e8 00 00 00 00	 call	 _putc
  03f1d	83 c4 08	 add	 esp, 8
  03f20	83 e8 ff	 sub	 eax, -1
  03f23	f7 d8		 neg	 eax
  03f25	1b c0		 sbb	 eax, eax
  03f27	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03f2d	89 41 f8	 mov	 DWORD PTR [ecx-8], eax
$LN1@P_fputline:

; 1607 :     }
; 1608 :     Pop;

  03f30	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  03f36	83 ea 04	 sub	 edx, 4
  03f39	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN10@P_fputline:

; 1609 : }

  03f3f	5d		 pop	 ebp
  03f40	c3		 ret	 0
_P_fputline ENDP
_TEXT	ENDS
EXTRN	_fread:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_fread PROC

; 1612 : {

  03f50	55		 push	 ebp
  03f51	8b ec		 mov	 ebp, esp

; 1613 :     Sl(3);

  03f53	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03f58	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  03f5e	c1 f8 02	 sar	 eax, 2
  03f61	83 f8 03	 cmp	 eax, 3
  03f64	7d 0a		 jge	 SHORT $LN7@P_fread
  03f66	e8 00 00 00 00	 call	 _atl__Esu
  03f6b	e9 d1 00 00 00	 jmp	 $LN8@P_fread
$LN7@P_fread:

; 1614 :     Hpc(S0);

  03f70	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03f76	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  03f79	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  03f7f	72 10		 jb	 SHORT $LN5@P_fread
  03f81	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03f86	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  03f89	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  03f8f	72 0a		 jb	 SHORT $LN6@P_fread
$LN5@P_fread:
  03f91	e8 00 00 00 00	 call	 _atl__Ebp
  03f96	e9 a6 00 00 00	 jmp	 $LN8@P_fread
$LN6@P_fread:

; 1615 :     Isfile(S2);

  03f9b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  03fa1	8b 42 f4	 mov	 eax, DWORD PTR [edx-12]
  03fa4	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hs
  03faa	72 11		 jb	 SHORT $LN3@P_fread
  03fac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  03fb2	8b 51 f4	 mov	 edx, DWORD PTR [ecx-12]
  03fb5	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__ht
  03fbb	72 07		 jb	 SHORT $LN4@P_fread
$LN3@P_fread:
  03fbd	e8 00 00 00 00	 call	 _atl__Ebp
  03fc2	eb 7d		 jmp	 SHORT $LN8@P_fread
$LN4@P_fread:
  03fc4	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  03fc9	8b 48 f4	 mov	 ecx, DWORD PTR [eax-12]
  03fcc	81 39 9d df 1f
	83		 cmp	 DWORD PTR [ecx], -2095063139 ; 831fdf9dH
  03fd2	74 0f		 je	 SHORT $LN2@P_fread
  03fd4	68 00 00 00 00	 push	 OFFSET $SG83995
  03fd9	e8 00 00 00 00	 call	 _printf
  03fde	83 c4 04	 add	 esp, 4
  03fe1	eb 5e		 jmp	 SHORT $LN8@P_fread
$LN2@P_fread:

; 1616 :     Isopen(S2);

  03fe3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  03fe9	8b 42 f4	 mov	 eax, DWORD PTR [edx-12]
  03fec	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  03ff0	75 0f		 jne	 SHORT $LN1@P_fread
  03ff2	68 00 00 00 00	 push	 OFFSET $SG84001
  03ff7	e8 00 00 00 00	 call	 _printf
  03ffc	83 c4 04	 add	 esp, 4
  03fff	eb 40		 jmp	 SHORT $LN8@P_fread
$LN1@P_fread:

; 1617 :     S2 = fread((char *) S0, 1, ((int) S1), FileD(S2));

  04001	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04007	8b 51 f4	 mov	 edx, DWORD PTR [ecx-12]
  0400a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0400d	50		 push	 eax
  0400e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04014	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  04017	52		 push	 edx
  04018	6a 01		 push	 1
  0401a	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0401f	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  04022	51		 push	 ecx
  04023	e8 00 00 00 00	 call	 _fread
  04028	83 c4 10	 add	 esp, 16			; 00000010H
  0402b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  04031	89 42 f4	 mov	 DWORD PTR [edx-12], eax

; 1618 :     Pop2;

  04034	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04039	83 e8 08	 sub	 eax, 8
  0403c	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN8@P_fread:

; 1619 : }

  04041	5d		 pop	 ebp
  04042	c3		 ret	 0
_P_fread ENDP
_TEXT	ENDS
EXTRN	_fwrite:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_fwrite PROC

; 1622 : {

  04050	55		 push	 ebp
  04051	8b ec		 mov	 ebp, esp

; 1623 :     Sl(3);

  04053	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04058	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0405e	c1 f8 02	 sar	 eax, 2
  04061	83 f8 03	 cmp	 eax, 3
  04064	7d 0a		 jge	 SHORT $LN7@P_fwrite
  04066	e8 00 00 00 00	 call	 _atl__Esu
  0406b	e9 d1 00 00 00	 jmp	 $LN8@P_fwrite
$LN7@P_fwrite:

; 1624 :     Hpc(S1);

  04070	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04076	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  04079	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  0407f	72 10		 jb	 SHORT $LN5@P_fwrite
  04081	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04086	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  04089	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  0408f	72 0a		 jb	 SHORT $LN6@P_fwrite
$LN5@P_fwrite:
  04091	e8 00 00 00 00	 call	 _atl__Ebp
  04096	e9 a6 00 00 00	 jmp	 $LN8@P_fwrite
$LN6@P_fwrite:

; 1625 :     Isfile(S0);

  0409b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  040a1	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  040a4	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hs
  040aa	72 11		 jb	 SHORT $LN3@P_fwrite
  040ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  040b2	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  040b5	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__ht
  040bb	72 07		 jb	 SHORT $LN4@P_fwrite
$LN3@P_fwrite:
  040bd	e8 00 00 00 00	 call	 _atl__Ebp
  040c2	eb 7d		 jmp	 SHORT $LN8@P_fwrite
$LN4@P_fwrite:
  040c4	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  040c9	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  040cc	81 39 9d df 1f
	83		 cmp	 DWORD PTR [ecx], -2095063139 ; 831fdf9dH
  040d2	74 0f		 je	 SHORT $LN2@P_fwrite
  040d4	68 00 00 00 00	 push	 OFFSET $SG84020
  040d9	e8 00 00 00 00	 call	 _printf
  040de	83 c4 04	 add	 esp, 4
  040e1	eb 5e		 jmp	 SHORT $LN8@P_fwrite
$LN2@P_fwrite:

; 1626 :     Isopen(S0);

  040e3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  040e9	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  040ec	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  040f0	75 0f		 jne	 SHORT $LN1@P_fwrite
  040f2	68 00 00 00 00	 push	 OFFSET $SG84026
  040f7	e8 00 00 00 00	 call	 _printf
  040fc	83 c4 04	 add	 esp, 4
  040ff	eb 40		 jmp	 SHORT $LN8@P_fwrite
$LN1@P_fwrite:

; 1627 :     S2 = fwrite((char *) S1, 1, ((int) S2), FileD(S0));

  04101	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04107	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  0410a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0410d	50		 push	 eax
  0410e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04114	8b 51 f4	 mov	 edx, DWORD PTR [ecx-12]
  04117	52		 push	 edx
  04118	6a 01		 push	 1
  0411a	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0411f	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  04122	51		 push	 ecx
  04123	e8 00 00 00 00	 call	 _fwrite
  04128	83 c4 10	 add	 esp, 16			; 00000010H
  0412b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  04131	89 42 f4	 mov	 DWORD PTR [edx-12], eax

; 1628 :     Pop2;

  04134	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04139	83 e8 08	 sub	 eax, 8
  0413c	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN8@P_fwrite:

; 1629 : }

  04141	5d		 pop	 ebp
  04142	c3		 ret	 0
_P_fwrite ENDP
; Function compile flags: /Odtp
_P_fgetc PROC

; 1632 : {

  04150	55		 push	 ebp
  04151	8b ec		 mov	 ebp, esp

; 1633 :     Sl(1);

  04153	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04158	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0415e	c1 f8 02	 sar	 eax, 2
  04161	83 f8 01	 cmp	 eax, 1
  04164	7d 0a		 jge	 SHORT $LN5@P_fgetc
  04166	e8 00 00 00 00	 call	 _atl__Esu
  0416b	e9 83 00 00 00	 jmp	 $LN6@P_fgetc
$LN5@P_fgetc:

; 1634 :     Isfile(S0);

  04170	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04176	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  04179	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  0417f	72 10		 jb	 SHORT $LN3@P_fgetc
  04181	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04186	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  04189	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  0418f	72 07		 jb	 SHORT $LN4@P_fgetc
$LN3@P_fgetc:
  04191	e8 00 00 00 00	 call	 _atl__Ebp
  04196	eb 5b		 jmp	 SHORT $LN6@P_fgetc
$LN4@P_fgetc:
  04198	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0419e	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  041a1	81 38 9d df 1f
	83		 cmp	 DWORD PTR [eax], -2095063139 ; 831fdf9dH
  041a7	74 0f		 je	 SHORT $LN2@P_fgetc
  041a9	68 00 00 00 00	 push	 OFFSET $SG84041
  041ae	e8 00 00 00 00	 call	 _printf
  041b3	83 c4 04	 add	 esp, 4
  041b6	eb 3b		 jmp	 SHORT $LN6@P_fgetc
$LN2@P_fgetc:

; 1635 :     Isopen(S0);

  041b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  041be	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  041c1	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  041c5	75 0f		 jne	 SHORT $LN1@P_fgetc
  041c7	68 00 00 00 00	 push	 OFFSET $SG84047
  041cc	e8 00 00 00 00	 call	 _printf
  041d1	83 c4 04	 add	 esp, 4
  041d4	eb 1d		 jmp	 SHORT $LN6@P_fgetc
$LN1@P_fgetc:

; 1636 :     S0 = getc(FileD(S0));	      /* Returns -1 if EOF hit */

  041d6	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  041db	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  041de	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  041e1	52		 push	 edx
  041e2	e8 00 00 00 00	 call	 _getc
  041e7	83 c4 04	 add	 esp, 4
  041ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  041f0	89 41 fc	 mov	 DWORD PTR [ecx-4], eax
$LN6@P_fgetc:

; 1637 : }

  041f3	5d		 pop	 ebp
  041f4	c3		 ret	 0
_P_fgetc ENDP
; Function compile flags: /Odtp
_P_fputc PROC

; 1640 : {

  04200	55		 push	 ebp
  04201	8b ec		 mov	 ebp, esp

; 1641 :     Sl(2);

  04203	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04208	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0420e	c1 f8 02	 sar	 eax, 2
  04211	83 f8 02	 cmp	 eax, 2
  04214	7d 0a		 jge	 SHORT $LN5@P_fputc
  04216	e8 00 00 00 00	 call	 _atl__Esu
  0421b	e9 9a 00 00 00	 jmp	 $LN6@P_fputc
$LN5@P_fputc:

; 1642 :     Isfile(S0);

  04220	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04226	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  04229	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  0422f	72 10		 jb	 SHORT $LN3@P_fputc
  04231	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04236	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  04239	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  0423f	72 07		 jb	 SHORT $LN4@P_fputc
$LN3@P_fputc:
  04241	e8 00 00 00 00	 call	 _atl__Ebp
  04246	eb 72		 jmp	 SHORT $LN6@P_fputc
$LN4@P_fputc:
  04248	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0424e	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  04251	81 38 9d df 1f
	83		 cmp	 DWORD PTR [eax], -2095063139 ; 831fdf9dH
  04257	74 0f		 je	 SHORT $LN2@P_fputc
  04259	68 00 00 00 00	 push	 OFFSET $SG84060
  0425e	e8 00 00 00 00	 call	 _printf
  04263	83 c4 04	 add	 esp, 4
  04266	eb 52		 jmp	 SHORT $LN6@P_fputc
$LN2@P_fputc:

; 1643 :     Isopen(S0);

  04268	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0426e	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  04271	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  04275	75 0f		 jne	 SHORT $LN1@P_fputc
  04277	68 00 00 00 00	 push	 OFFSET $SG84066
  0427c	e8 00 00 00 00	 call	 _printf
  04281	83 c4 04	 add	 esp, 4
  04284	eb 34		 jmp	 SHORT $LN6@P_fputc
$LN1@P_fputc:

; 1644 :     S1 = putc((char) S1, FileD(S0));

  04286	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0428b	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0428e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  04291	52		 push	 edx
  04292	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04297	0f be 48 f8	 movsx	 ecx, BYTE PTR [eax-8]
  0429b	51		 push	 ecx
  0429c	e8 00 00 00 00	 call	 _putc
  042a1	83 c4 08	 add	 esp, 8
  042a4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  042aa	89 42 f8	 mov	 DWORD PTR [edx-8], eax

; 1645 :     Pop;

  042ad	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  042b2	83 e8 04	 sub	 eax, 4
  042b5	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN6@P_fputc:

; 1646 : }

  042ba	5d		 pop	 ebp
  042bb	c3		 ret	 0
_P_fputc ENDP
_TEXT	ENDS
EXTRN	_ftell:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_ftell PROC

; 1649 : {

  042c0	55		 push	 ebp
  042c1	8b ec		 mov	 ebp, esp

; 1650 :     Sl(1);

  042c3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  042c8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  042ce	c1 f8 02	 sar	 eax, 2
  042d1	83 f8 01	 cmp	 eax, 1
  042d4	7d 0a		 jge	 SHORT $LN5@P_ftell
  042d6	e8 00 00 00 00	 call	 _atl__Esu
  042db	e9 83 00 00 00	 jmp	 $LN6@P_ftell
$LN5@P_ftell:

; 1651 :     Isfile(S0);

  042e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  042e6	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  042e9	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  042ef	72 10		 jb	 SHORT $LN3@P_ftell
  042f1	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  042f6	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  042f9	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  042ff	72 07		 jb	 SHORT $LN4@P_ftell
$LN3@P_ftell:
  04301	e8 00 00 00 00	 call	 _atl__Ebp
  04306	eb 5b		 jmp	 SHORT $LN6@P_ftell
$LN4@P_ftell:
  04308	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0430e	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  04311	81 38 9d df 1f
	83		 cmp	 DWORD PTR [eax], -2095063139 ; 831fdf9dH
  04317	74 0f		 je	 SHORT $LN2@P_ftell
  04319	68 00 00 00 00	 push	 OFFSET $SG84080
  0431e	e8 00 00 00 00	 call	 _printf
  04323	83 c4 04	 add	 esp, 4
  04326	eb 3b		 jmp	 SHORT $LN6@P_ftell
$LN2@P_ftell:

; 1652 :     Isopen(S0);

  04328	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0432e	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  04331	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  04335	75 0f		 jne	 SHORT $LN1@P_ftell
  04337	68 00 00 00 00	 push	 OFFSET $SG84086
  0433c	e8 00 00 00 00	 call	 _printf
  04341	83 c4 04	 add	 esp, 4
  04344	eb 1d		 jmp	 SHORT $LN6@P_ftell
$LN1@P_ftell:

; 1653 :     S0 = (stackitem) ftell(FileD(S0));

  04346	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0434b	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0434e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  04351	52		 push	 edx
  04352	e8 00 00 00 00	 call	 _ftell
  04357	83 c4 04	 add	 esp, 4
  0435a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04360	89 41 fc	 mov	 DWORD PTR [ecx-4], eax
$LN6@P_ftell:

; 1654 : }

  04363	5d		 pop	 ebp
  04364	c3		 ret	 0
_P_ftell ENDP
_TEXT	ENDS
EXTRN	_fseek:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_fseek PROC

; 1657 : {

  04370	55		 push	 ebp
  04371	8b ec		 mov	 ebp, esp

; 1658 :     Sl(3);

  04373	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04378	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0437e	c1 f8 02	 sar	 eax, 2
  04381	83 f8 03	 cmp	 eax, 3
  04384	7d 0a		 jge	 SHORT $LN5@P_fseek
  04386	e8 00 00 00 00	 call	 _atl__Esu
  0438b	e9 9d 00 00 00	 jmp	 $LN6@P_fseek
$LN5@P_fseek:

; 1659 :     Isfile(S0);

  04390	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04396	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  04399	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  0439f	72 10		 jb	 SHORT $LN3@P_fseek
  043a1	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  043a6	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  043a9	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  043af	72 07		 jb	 SHORT $LN4@P_fseek
$LN3@P_fseek:
  043b1	e8 00 00 00 00	 call	 _atl__Ebp
  043b6	eb 75		 jmp	 SHORT $LN6@P_fseek
$LN4@P_fseek:
  043b8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  043be	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  043c1	81 38 9d df 1f
	83		 cmp	 DWORD PTR [eax], -2095063139 ; 831fdf9dH
  043c7	74 0f		 je	 SHORT $LN2@P_fseek
  043c9	68 00 00 00 00	 push	 OFFSET $SG84100
  043ce	e8 00 00 00 00	 call	 _printf
  043d3	83 c4 04	 add	 esp, 4
  043d6	eb 55		 jmp	 SHORT $LN6@P_fseek
$LN2@P_fseek:

; 1660 :     Isopen(S0);

  043d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  043de	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  043e1	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  043e5	75 0f		 jne	 SHORT $LN1@P_fseek
  043e7	68 00 00 00 00	 push	 OFFSET $SG84106
  043ec	e8 00 00 00 00	 call	 _printf
  043f1	83 c4 04	 add	 esp, 4
  043f4	eb 37		 jmp	 SHORT $LN6@P_fseek
$LN1@P_fseek:

; 1661 :     V fseek(FileD(S0), (long) S2, (int) S1);

  043f6	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  043fb	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  043fe	51		 push	 ecx
  043ff	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  04405	8b 42 f4	 mov	 eax, DWORD PTR [edx-12]
  04408	50		 push	 eax
  04409	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0440f	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  04412	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  04415	50		 push	 eax
  04416	e8 00 00 00 00	 call	 _fseek
  0441b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1662 :     Npop(3);

  0441e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04424	83 e9 0c	 sub	 ecx, 12			; 0000000cH
  04427	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN6@P_fseek:

; 1663 : }

  0442d	5d		 pop	 ebp
  0442e	c3		 ret	 0
_P_fseek ENDP
_TEXT	ENDS
PUBLIC	_atl_load
; Function compile flags: /Odtp
_TEXT	SEGMENT
_fd$ = -8						; size = 4
_estat$ = -4						; size = 4
_P_fload PROC

; 1666 : {

  04430	55		 push	 ebp
  04431	8b ec		 mov	 ebp, esp
  04433	83 ec 08	 sub	 esp, 8

; 1667 :     int estat;
; 1668 :     FILE *fd;
; 1669 : 
; 1670 :     Sl(1);

  04436	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0443b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  04441	c1 f8 02	 sar	 eax, 2
  04444	83 f8 01	 cmp	 eax, 1
  04447	7d 0a		 jge	 SHORT $LN7@P_fload
  04449	e8 00 00 00 00	 call	 _atl__Esu
  0444e	e9 e6 00 00 00	 jmp	 $LN8@P_fload
$LN7@P_fload:

; 1671 :     Isfile(S0);

  04453	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04459	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  0445c	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  04462	72 10		 jb	 SHORT $LN5@P_fload
  04464	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04469	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0446c	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  04472	72 0a		 jb	 SHORT $LN6@P_fload
$LN5@P_fload:
  04474	e8 00 00 00 00	 call	 _atl__Ebp
  04479	e9 bb 00 00 00	 jmp	 $LN8@P_fload
$LN6@P_fload:
  0447e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  04484	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  04487	81 38 9d df 1f
	83		 cmp	 DWORD PTR [eax], -2095063139 ; 831fdf9dH
  0448d	74 12		 je	 SHORT $LN4@P_fload
  0448f	68 00 00 00 00	 push	 OFFSET $SG84124
  04494	e8 00 00 00 00	 call	 _printf
  04499	83 c4 04	 add	 esp, 4
  0449c	e9 98 00 00 00	 jmp	 $LN8@P_fload
$LN4@P_fload:

; 1672 :     Isopen(S0);

  044a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  044a7	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  044aa	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  044ae	75 0f		 jne	 SHORT $LN3@P_fload
  044b0	68 00 00 00 00	 push	 OFFSET $SG84130
  044b5	e8 00 00 00 00	 call	 _printf
  044ba	83 c4 04	 add	 esp, 4
  044bd	eb 7a		 jmp	 SHORT $LN8@P_fload
$LN3@P_fload:

; 1673 :     fd = FileD(S0);

  044bf	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  044c4	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  044c7	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  044ca	89 55 f8	 mov	 DWORD PTR _fd$[ebp], edx

; 1674 :     Pop;

  044cd	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  044d2	83 e8 04	 sub	 eax, 4
  044d5	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax

; 1675 :     estat = atl_load(fd);

  044da	8b 4d f8	 mov	 ecx, DWORD PTR _fd$[ebp]
  044dd	51		 push	 ecx
  044de	e8 00 00 00 00	 call	 _atl_load
  044e3	83 c4 04	 add	 esp, 4
  044e6	89 45 fc	 mov	 DWORD PTR _estat$[ebp], eax

; 1676 :     So(1);

  044e9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  044ef	83 c2 04	 add	 edx, 4
  044f2	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__sx
  044f8	76 0d		 jbe	 SHORT $LN2@P_fload
  044fa	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  044ff	83 c0 04	 add	 eax, 4
  04502	a3 00 00 00 00	 mov	 DWORD PTR _atl__sx, eax
$LN2@P_fload:
  04507	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0450d	83 c1 04	 add	 ecx, 4
  04510	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__st
  04516	76 07		 jbe	 SHORT $LN1@P_fload
  04518	e8 00 00 00 00	 call	 _atl__Eso
  0451d	eb 1a		 jmp	 SHORT $LN8@P_fload
$LN1@P_fload:

; 1677 :     Push = estat;

  0451f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  04525	8b 45 fc	 mov	 eax, DWORD PTR _estat$[ebp]
  04528	89 02		 mov	 DWORD PTR [edx], eax
  0452a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04530	83 c1 04	 add	 ecx, 4
  04533	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN8@P_fload:

; 1678 : }

  04539	8b e5		 mov	 esp, ebp
  0453b	5d		 pop	 ebp
  0453c	c3		 ret	 0
_P_fload ENDP
_TEXT	ENDS
PUBLIC	_atl_unwind
PUBLIC	_atl_eval
PUBLIC	_atl_mark
; Function compile flags: /Odtp
_TEXT	SEGMENT
_scomm$ = -36						; size = 4
_estring$ = -32						; size = 4
_es$ = -28						; size = 4
_sinstr$ = -24						; size = 4
_sip$ = -20						; size = 4
_mk$ = -16						; size = 16
_P_evaluate PROC

; 1684 : {				      /* string -- status */

  04540	55		 push	 ebp
  04541	8b ec		 mov	 ebp, esp
  04543	83 ec 24	 sub	 esp, 36			; 00000024H

; 1685 :     int es = ATL_SNORM;

  04546	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _es$[ebp], 0

; 1686 :     atl_statemark mk;
; 1687 :     atl_int scomm = atl_comment;      /* Stack comment pending state */

  0454d	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_comment
  04552	89 45 dc	 mov	 DWORD PTR _scomm$[ebp], eax

; 1688 :     dictword **sip = ip;	      /* Stack instruction pointer */

  04555	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__ip
  0455b	89 4d ec	 mov	 DWORD PTR _sip$[ebp], ecx

; 1689 :     char *sinstr = instream;	      /* Stack input stream */

  0455e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _instream
  04564	89 55 e8	 mov	 DWORD PTR _sinstr$[ebp], edx

; 1690 :     char *estring;
; 1691 : 
; 1692 :     Sl(1);

  04567	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0456c	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  04572	c1 f8 02	 sar	 eax, 2
  04575	83 f8 01	 cmp	 eax, 1
  04578	7d 0a		 jge	 SHORT $LN7@P_evaluate
  0457a	e8 00 00 00 00	 call	 _atl__Esu
  0457f	e9 09 01 00 00	 jmp	 $LN8@P_evaluate
$LN7@P_evaluate:

; 1693 :     Hpc(S0);

  04584	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0458a	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  0458d	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  04593	72 10		 jb	 SHORT $LN5@P_evaluate
  04595	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0459a	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0459d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  045a3	72 0a		 jb	 SHORT $LN6@P_evaluate
$LN5@P_evaluate:
  045a5	e8 00 00 00 00	 call	 _atl__Ebp
  045aa	e9 de 00 00 00	 jmp	 $LN8@P_evaluate
$LN6@P_evaluate:

; 1694 :     estring = (char *) S0;	      /* Get string to evaluate */

  045af	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  045b5	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  045b8	89 45 e0	 mov	 DWORD PTR _estring$[ebp], eax

; 1695 :     Pop;			      /* Pop so it sees arguments below it */

  045bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  045c1	83 e9 04	 sub	 ecx, 4
  045c4	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx

; 1696 :     atl_mark(&mk);		      /* Mark in case of error */

  045ca	8d 55 f0	 lea	 edx, DWORD PTR _mk$[ebp]
  045cd	52		 push	 edx
  045ce	e8 00 00 00 00	 call	 _atl_mark
  045d3	83 c4 04	 add	 esp, 4

; 1697 :     ip = NULL;			      /* Fool atl_eval into interp state */

  045d6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _atl__ip, 0

; 1698 :     if ((es = atl_eval(estring)) != ATL_SNORM) {

  045e0	8b 45 e0	 mov	 eax, DWORD PTR _estring$[ebp]
  045e3	50		 push	 eax
  045e4	e8 00 00 00 00	 call	 _atl_eval
  045e9	83 c4 04	 add	 esp, 4
  045ec	89 45 e4	 mov	 DWORD PTR _es$[ebp], eax
  045ef	83 7d e4 00	 cmp	 DWORD PTR _es$[ebp], 0
  045f3	74 0c		 je	 SHORT $LN4@P_evaluate

; 1699 : 	atl_unwind(&mk);

  045f5	8d 4d f0	 lea	 ecx, DWORD PTR _mk$[ebp]
  045f8	51		 push	 ecx
  045f9	e8 00 00 00 00	 call	 _atl_unwind
  045fe	83 c4 04	 add	 esp, 4
$LN4@P_evaluate:

; 1700 :     }
; 1701 :     /* If there were no other errors, check for a runaway comment.  If
; 1702 :        we ended the file in comment-ignore mode, set the runaway comment
; 1703 :        error status and unwind the file.  */
; 1704 :     if ((es == ATL_SNORM) && (atl_comment != 0)) {

  04601	83 7d e4 00	 cmp	 DWORD PTR _es$[ebp], 0
  04605	75 1c		 jne	 SHORT $LN3@P_evaluate
  04607	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _atl_comment, 0
  0460e	74 13		 je	 SHORT $LN3@P_evaluate

; 1705 : 	es = ATL_RUNCOMM;

  04610	c7 45 e4 f5 ff
	ff ff		 mov	 DWORD PTR _es$[ebp], -11 ; fffffff5H

; 1706 : 	atl_unwind(&mk);

  04617	8d 55 f0	 lea	 edx, DWORD PTR _mk$[ebp]
  0461a	52		 push	 edx
  0461b	e8 00 00 00 00	 call	 _atl_unwind
  04620	83 c4 04	 add	 esp, 4
$LN3@P_evaluate:

; 1707 :     }
; 1708 :     atl_comment = scomm;	      /* Unstack comment pending status */

  04623	8b 45 dc	 mov	 eax, DWORD PTR _scomm$[ebp]
  04626	a3 00 00 00 00	 mov	 DWORD PTR _atl_comment, eax

; 1709 :     ip = sip;			      /* Unstack instruction pointer */

  0462b	8b 4d ec	 mov	 ecx, DWORD PTR _sip$[ebp]
  0462e	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__ip, ecx

; 1710 :     instream = sinstr;		      /* Unstack input stream */

  04634	8b 55 e8	 mov	 edx, DWORD PTR _sinstr$[ebp]
  04637	89 15 00 00 00
	00		 mov	 DWORD PTR _instream, edx

; 1711 :     So(1);

  0463d	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04642	83 c0 04	 add	 eax, 4
  04645	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__sx
  0464b	76 0f		 jbe	 SHORT $LN2@P_evaluate
  0464d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04653	83 c1 04	 add	 ecx, 4
  04656	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sx, ecx
$LN2@P_evaluate:
  0465c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  04662	83 c2 04	 add	 edx, 4
  04665	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__st
  0466b	76 07		 jbe	 SHORT $LN1@P_evaluate
  0466d	e8 00 00 00 00	 call	 _atl__Eso
  04672	eb 19		 jmp	 SHORT $LN8@P_evaluate
$LN1@P_evaluate:

; 1712 :     Push = es;			      /* Return eval status on top of stack */

  04674	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04679	8b 4d e4	 mov	 ecx, DWORD PTR _es$[ebp]
  0467c	89 08		 mov	 DWORD PTR [eax], ecx
  0467e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  04684	83 c2 04	 add	 edx, 4
  04687	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN8@P_evaluate:

; 1713 : }

  0468d	8b e5		 mov	 esp, ebp
  0468f	5d		 pop	 ebp
  04690	c3		 ret	 0
_P_evaluate ENDP
; Function compile flags: /Odtp
_s$ = -4						; size = 4
_P_depth PROC

; 1719 : {

  046a0	55		 push	 ebp
  046a1	8b ec		 mov	 ebp, esp
  046a3	51		 push	 ecx

; 1720 :     stackitem s = stk - stack;

  046a4	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  046a9	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  046af	c1 f8 02	 sar	 eax, 2
  046b2	89 45 fc	 mov	 DWORD PTR _s$[ebp], eax

; 1721 : 
; 1722 :     So(1);

  046b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  046bb	83 c1 04	 add	 ecx, 4
  046be	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__sx
  046c4	76 0f		 jbe	 SHORT $LN2@P_depth
  046c6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  046cc	83 c2 04	 add	 edx, 4
  046cf	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sx, edx
$LN2@P_depth:
  046d5	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  046da	83 c0 04	 add	 eax, 4
  046dd	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__st
  046e3	76 07		 jbe	 SHORT $LN1@P_depth
  046e5	e8 00 00 00 00	 call	 _atl__Eso
  046ea	eb 18		 jmp	 SHORT $LN3@P_depth
$LN1@P_depth:

; 1723 :     Push = s;

  046ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  046f2	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  046f5	89 11		 mov	 DWORD PTR [ecx], edx
  046f7	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  046fc	83 c0 04	 add	 eax, 4
  046ff	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN3@P_depth:

; 1724 : }

  04704	8b e5		 mov	 esp, ebp
  04706	5d		 pop	 ebp
  04707	c3		 ret	 0
_P_depth ENDP
; Function compile flags: /Odtp
_P_clear PROC

; 1727 : {

  04710	55		 push	 ebp
  04711	8b ec		 mov	 ebp, esp

; 1728 :     stk = stack;

  04713	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sk
  04718	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax

; 1729 : }

  0471d	5d		 pop	 ebp
  0471e	c3		 ret	 0
_P_clear ENDP
; Function compile flags: /Odtp
_s$ = -4						; size = 4
_P_dup	PROC

; 1732 : {

  04720	55		 push	 ebp
  04721	8b ec		 mov	 ebp, esp
  04723	51		 push	 ecx

; 1733 :     stackitem s;
; 1734 : 
; 1735 :     Sl(1);

  04724	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04729	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0472f	c1 f8 02	 sar	 eax, 2
  04732	83 f8 01	 cmp	 eax, 1
  04735	7d 07		 jge	 SHORT $LN3@P_dup
  04737	e8 00 00 00 00	 call	 _atl__Esu
  0473c	eb 5c		 jmp	 SHORT $LN4@P_dup
$LN3@P_dup:

; 1736 :     So(1);

  0473e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04744	83 c1 04	 add	 ecx, 4
  04747	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__sx
  0474d	76 0f		 jbe	 SHORT $LN2@P_dup
  0474f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  04755	83 c2 04	 add	 edx, 4
  04758	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sx, edx
$LN2@P_dup:
  0475e	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04763	83 c0 04	 add	 eax, 4
  04766	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__st
  0476c	76 07		 jbe	 SHORT $LN1@P_dup
  0476e	e8 00 00 00 00	 call	 _atl__Eso
  04773	eb 25		 jmp	 SHORT $LN4@P_dup
$LN1@P_dup:

; 1737 :     s = S0;

  04775	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0477b	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  0477e	89 55 fc	 mov	 DWORD PTR _s$[ebp], edx

; 1738 :     Push = s;

  04781	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04786	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  04789	89 08		 mov	 DWORD PTR [eax], ecx
  0478b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  04791	83 c2 04	 add	 edx, 4
  04794	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN4@P_dup:

; 1739 : }

  0479a	8b e5		 mov	 esp, ebp
  0479c	5d		 pop	 ebp
  0479d	c3		 ret	 0
_P_dup	ENDP
; Function compile flags: /Odtp
_P_drop PROC

; 1742 : {

  047a0	55		 push	 ebp
  047a1	8b ec		 mov	 ebp, esp

; 1743 :     Sl(1);

  047a3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  047a8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  047ae	c1 f8 02	 sar	 eax, 2
  047b1	83 f8 01	 cmp	 eax, 1
  047b4	7d 07		 jge	 SHORT $LN1@P_drop
  047b6	e8 00 00 00 00	 call	 _atl__Esu
  047bb	eb 0f		 jmp	 SHORT $LN2@P_drop
$LN1@P_drop:

; 1744 :     Pop;

  047bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  047c3	83 e9 04	 sub	 ecx, 4
  047c6	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN2@P_drop:

; 1745 : }

  047cc	5d		 pop	 ebp
  047cd	c3		 ret	 0
_P_drop	ENDP
; Function compile flags: /Odtp
_t$ = -4						; size = 4
_P_swap	PROC

; 1748 : {

  047d0	55		 push	 ebp
  047d1	8b ec		 mov	 ebp, esp
  047d3	51		 push	 ecx

; 1749 :     stackitem t;
; 1750 : 
; 1751 :     Sl(2);

  047d4	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  047d9	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  047df	c1 f8 02	 sar	 eax, 2
  047e2	83 f8 02	 cmp	 eax, 2
  047e5	7d 07		 jge	 SHORT $LN1@P_swap
  047e7	e8 00 00 00 00	 call	 _atl__Esu
  047ec	eb 28		 jmp	 SHORT $LN2@P_swap
$LN1@P_swap:

; 1752 :     t = S1;

  047ee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  047f4	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  047f7	89 55 fc	 mov	 DWORD PTR _t$[ebp], edx

; 1753 :     S1 = S0;

  047fa	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  047ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04805	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  04808	89 50 f8	 mov	 DWORD PTR [eax-8], edx

; 1754 :     S0 = t;

  0480b	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04810	8b 4d fc	 mov	 ecx, DWORD PTR _t$[ebp]
  04813	89 48 fc	 mov	 DWORD PTR [eax-4], ecx
$LN2@P_swap:

; 1755 : }

  04816	8b e5		 mov	 esp, ebp
  04818	5d		 pop	 ebp
  04819	c3		 ret	 0
_P_swap	ENDP
; Function compile flags: /Odtp
_s$ = -4						; size = 4
_P_over	PROC

; 1758 : {

  04820	55		 push	 ebp
  04821	8b ec		 mov	 ebp, esp
  04823	51		 push	 ecx

; 1759 :     stackitem s;
; 1760 : 
; 1761 :     Sl(2);

  04824	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04829	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0482f	c1 f8 02	 sar	 eax, 2
  04832	83 f8 02	 cmp	 eax, 2
  04835	7d 07		 jge	 SHORT $LN3@P_over
  04837	e8 00 00 00 00	 call	 _atl__Esu
  0483c	eb 5c		 jmp	 SHORT $LN4@P_over
$LN3@P_over:

; 1762 :     So(1);

  0483e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04844	83 c1 04	 add	 ecx, 4
  04847	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__sx
  0484d	76 0f		 jbe	 SHORT $LN2@P_over
  0484f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  04855	83 c2 04	 add	 edx, 4
  04858	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sx, edx
$LN2@P_over:
  0485e	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04863	83 c0 04	 add	 eax, 4
  04866	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__st
  0486c	76 07		 jbe	 SHORT $LN1@P_over
  0486e	e8 00 00 00 00	 call	 _atl__Eso
  04873	eb 25		 jmp	 SHORT $LN4@P_over
$LN1@P_over:

; 1763 :     s = S1;

  04875	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0487b	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  0487e	89 55 fc	 mov	 DWORD PTR _s$[ebp], edx

; 1764 :     Push = s;

  04881	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04886	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  04889	89 08		 mov	 DWORD PTR [eax], ecx
  0488b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  04891	83 c2 04	 add	 edx, 4
  04894	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN4@P_over:

; 1765 : }

  0489a	8b e5		 mov	 esp, ebp
  0489c	5d		 pop	 ebp
  0489d	c3		 ret	 0
_P_over	ENDP
; Function compile flags: /Odtp
_P_pick PROC

; 1768 : {

  048a0	55		 push	 ebp
  048a1	8b ec		 mov	 ebp, esp

; 1769 :     Sl(2);

  048a3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  048a8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  048ae	c1 f8 02	 sar	 eax, 2
  048b1	83 f8 02	 cmp	 eax, 2
  048b4	7d 07		 jge	 SHORT $LN1@P_pick
  048b6	e8 00 00 00 00	 call	 _atl__Esu
  048bb	eb 1f		 jmp	 SHORT $LN2@P_pick
$LN1@P_pick:

; 1770 :     S0 = stk[-(2 + S0)];

  048bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  048c3	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  048c6	83 c2 02	 add	 edx, 2
  048c9	f7 da		 neg	 edx
  048cb	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  048d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  048d6	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  048d9	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN2@P_pick:

; 1771 : }

  048dc	5d		 pop	 ebp
  048dd	c3		 ret	 0
_P_pick	ENDP
; Function compile flags: /Odtp
_t$ = -4						; size = 4
_P_rot	PROC

; 1774 : {

  048e0	55		 push	 ebp
  048e1	8b ec		 mov	 ebp, esp
  048e3	51		 push	 ecx

; 1775 :     stackitem t;
; 1776 : 
; 1777 :     Sl(3);

  048e4	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  048e9	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  048ef	c1 f8 02	 sar	 eax, 2
  048f2	83 f8 03	 cmp	 eax, 3
  048f5	7d 07		 jge	 SHORT $LN1@P_rot
  048f7	e8 00 00 00 00	 call	 _atl__Esu
  048fc	eb 39		 jmp	 SHORT $LN2@P_rot
$LN1@P_rot:

; 1778 :     t = S0;

  048fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04904	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  04907	89 55 fc	 mov	 DWORD PTR _t$[ebp], edx

; 1779 :     S0 = S2;

  0490a	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0490f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04915	8b 51 f4	 mov	 edx, DWORD PTR [ecx-12]
  04918	89 50 fc	 mov	 DWORD PTR [eax-4], edx

; 1780 :     S2 = S1;

  0491b	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04920	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04926	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  04929	89 50 f4	 mov	 DWORD PTR [eax-12], edx

; 1781 :     S1 = t;

  0492c	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04931	8b 4d fc	 mov	 ecx, DWORD PTR _t$[ebp]
  04934	89 48 f8	 mov	 DWORD PTR [eax-8], ecx
$LN2@P_rot:

; 1782 : }

  04937	8b e5		 mov	 esp, ebp
  04939	5d		 pop	 ebp
  0493a	c3		 ret	 0
_P_rot	ENDP
; Function compile flags: /Odtp
_t$ = -4						; size = 4
_P_minusrot PROC

; 1785 : {

  04940	55		 push	 ebp
  04941	8b ec		 mov	 ebp, esp
  04943	51		 push	 ecx

; 1786 :     stackitem t;
; 1787 : 
; 1788 :     Sl(3);

  04944	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04949	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0494f	c1 f8 02	 sar	 eax, 2
  04952	83 f8 03	 cmp	 eax, 3
  04955	7d 07		 jge	 SHORT $LN1@P_minusrot
  04957	e8 00 00 00 00	 call	 _atl__Esu
  0495c	eb 39		 jmp	 SHORT $LN2@P_minusrot
$LN1@P_minusrot:

; 1789 :     t = S0;

  0495e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04964	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  04967	89 55 fc	 mov	 DWORD PTR _t$[ebp], edx

; 1790 :     S0 = S1;

  0496a	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0496f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04975	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  04978	89 50 fc	 mov	 DWORD PTR [eax-4], edx

; 1791 :     S1 = S2;

  0497b	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04980	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04986	8b 51 f4	 mov	 edx, DWORD PTR [ecx-12]
  04989	89 50 f8	 mov	 DWORD PTR [eax-8], edx

; 1792 :     S2 = t;

  0498c	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04991	8b 4d fc	 mov	 ecx, DWORD PTR _t$[ebp]
  04994	89 48 f4	 mov	 DWORD PTR [eax-12], ecx
$LN2@P_minusrot:

; 1793 : }

  04997	8b e5		 mov	 esp, ebp
  04999	5d		 pop	 ebp
  0499a	c3		 ret	 0
_P_minusrot ENDP
; Function compile flags: /Odtp
_j$ = -12						; size = 4
_t$ = -8						; size = 4
_i$ = -4						; size = 4
_P_roll	PROC

; 1796 : {

  049a0	55		 push	 ebp
  049a1	8b ec		 mov	 ebp, esp
  049a3	83 ec 0c	 sub	 esp, 12			; 0000000cH
  049a6	56		 push	 esi

; 1797 :     stackitem i, j, t;
; 1798 : 
; 1799 :     Sl(1);

  049a7	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  049ac	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  049b2	c1 f8 02	 sar	 eax, 2
  049b5	83 f8 01	 cmp	 eax, 1
  049b8	7d 0a		 jge	 SHORT $LN5@P_roll
  049ba	e8 00 00 00 00	 call	 _atl__Esu
  049bf	e9 8f 00 00 00	 jmp	 $LN6@P_roll
$LN5@P_roll:

; 1800 :     i = S0;

  049c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  049ca	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  049cd	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx

; 1801 :     Pop;

  049d0	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  049d5	83 e8 04	 sub	 eax, 4
  049d8	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax

; 1802 :     Sl(i + 1);

  049dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  049e3	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _atl__sk
  049e9	c1 f9 02	 sar	 ecx, 2
  049ec	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  049ef	83 c2 01	 add	 edx, 1
  049f2	3b ca		 cmp	 ecx, edx
  049f4	7d 07		 jge	 SHORT $LN4@P_roll
  049f6	e8 00 00 00 00	 call	 _atl__Esu
  049fb	eb 56		 jmp	 SHORT $LN6@P_roll
$LN4@P_roll:

; 1803 :     t = stk[-(i + 1)];

  049fd	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  04a00	83 c0 01	 add	 eax, 1
  04a03	f7 d8		 neg	 eax
  04a05	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04a0b	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  04a0e	89 55 f8	 mov	 DWORD PTR _t$[ebp], edx

; 1804 :     for (j = -(i + 1); j < -1; j++)

  04a11	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  04a14	83 c0 01	 add	 eax, 1
  04a17	f7 d8		 neg	 eax
  04a19	89 45 f4	 mov	 DWORD PTR _j$[ebp], eax
  04a1c	eb 09		 jmp	 SHORT $LN3@P_roll
$LN2@P_roll:
  04a1e	8b 4d f4	 mov	 ecx, DWORD PTR _j$[ebp]
  04a21	83 c1 01	 add	 ecx, 1
  04a24	89 4d f4	 mov	 DWORD PTR _j$[ebp], ecx
$LN3@P_roll:
  04a27	83 7d f4 ff	 cmp	 DWORD PTR _j$[ebp], -1
  04a2b	7d 1a		 jge	 SHORT $LN1@P_roll

; 1805 : 	stk[j] = stk[j + 1];

  04a2d	8b 55 f4	 mov	 edx, DWORD PTR _j$[ebp]
  04a30	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04a35	8b 4d f4	 mov	 ecx, DWORD PTR _j$[ebp]
  04a38	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _atl__sp
  04a3e	8b 4c 8e 04	 mov	 ecx, DWORD PTR [esi+ecx*4+4]
  04a42	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx
  04a45	eb d7		 jmp	 SHORT $LN2@P_roll
$LN1@P_roll:

; 1806 :     S0 = t;

  04a47	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  04a4d	8b 45 f8	 mov	 eax, DWORD PTR _t$[ebp]
  04a50	89 42 fc	 mov	 DWORD PTR [edx-4], eax
$LN6@P_roll:

; 1807 : }

  04a53	5e		 pop	 esi
  04a54	8b e5		 mov	 esp, ebp
  04a56	5d		 pop	 ebp
  04a57	c3		 ret	 0
_P_roll	ENDP
_TEXT	ENDS
PUBLIC	_atl__Erso
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_tor	PROC

; 1810 : {

  04a60	55		 push	 ebp
  04a61	8b ec		 mov	 ebp, esp

; 1811 :     Rso(1);

  04a63	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__rp
  04a68	83 c0 04	 add	 eax, 4
  04a6b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__rx
  04a71	76 0f		 jbe	 SHORT $LN3@P_tor@2
  04a73	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__rp
  04a79	83 c1 04	 add	 ecx, 4
  04a7c	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__rx, ecx
$LN3@P_tor@2:
  04a82	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__rp
  04a88	83 c2 04	 add	 edx, 4
  04a8b	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__rt
  04a91	76 07		 jbe	 SHORT $LN2@P_tor@2
  04a93	e8 00 00 00 00	 call	 _atl__Erso
  04a98	eb 49		 jmp	 SHORT $LN4@P_tor@2
$LN2@P_tor@2:

; 1812 :     Sl(1);

  04a9a	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04a9f	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  04aa5	c1 f8 02	 sar	 eax, 2
  04aa8	83 f8 01	 cmp	 eax, 1
  04aab	7d 07		 jge	 SHORT $LN1@P_tor@2
  04aad	e8 00 00 00 00	 call	 _atl__Esu
  04ab2	eb 2f		 jmp	 SHORT $LN4@P_tor@2
$LN1@P_tor@2:

; 1813 :     Rpush = (rstackitem) S0;

  04ab4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__rp
  04aba	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  04ac0	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  04ac3	89 01		 mov	 DWORD PTR [ecx], eax
  04ac5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__rp
  04acb	83 c1 04	 add	 ecx, 4
  04ace	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__rp, ecx

; 1814 :     Pop;

  04ad4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  04ada	83 ea 04	 sub	 edx, 4
  04add	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN4@P_tor@2:

; 1815 : }

  04ae3	5d		 pop	 ebp
  04ae4	c3		 ret	 0
_P_tor	ENDP
_TEXT	ENDS
PUBLIC	_atl__Ersu
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_rfrom PROC

; 1818 : {

  04af0	55		 push	 ebp
  04af1	8b ec		 mov	 ebp, esp

; 1819 :     Rsl(1);

  04af3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__rp
  04af8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__rk
  04afe	c1 f8 02	 sar	 eax, 2
  04b01	83 f8 01	 cmp	 eax, 1
  04b04	7d 07		 jge	 SHORT $LN3@P_rfrom
  04b06	e8 00 00 00 00	 call	 _atl__Ersu
  04b0b	eb 66		 jmp	 SHORT $LN4@P_rfrom
$LN3@P_rfrom:

; 1820 :     So(1);

  04b0d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04b13	83 c1 04	 add	 ecx, 4
  04b16	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__sx
  04b1c	76 0f		 jbe	 SHORT $LN2@P_rfrom
  04b1e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  04b24	83 c2 04	 add	 edx, 4
  04b27	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sx, edx
$LN2@P_rfrom:
  04b2d	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04b32	83 c0 04	 add	 eax, 4
  04b35	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__st
  04b3b	76 07		 jbe	 SHORT $LN1@P_rfrom
  04b3d	e8 00 00 00 00	 call	 _atl__Eso
  04b42	eb 2f		 jmp	 SHORT $LN4@P_rfrom
$LN1@P_rfrom:

; 1821 :     Push = (stackitem) R0;

  04b44	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04b4a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__rp
  04b50	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  04b53	89 01		 mov	 DWORD PTR [ecx], eax
  04b55	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04b5b	83 c1 04	 add	 ecx, 4
  04b5e	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx

; 1822 :     Rpop;

  04b64	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__rp
  04b6a	83 ea 04	 sub	 edx, 4
  04b6d	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__rp, edx
$LN4@P_rfrom:

; 1823 : }

  04b73	5d		 pop	 ebp
  04b74	c3		 ret	 0
_P_rfrom ENDP
; Function compile flags: /Odtp
_P_rfetch PROC

; 1826 : {

  04b80	55		 push	 ebp
  04b81	8b ec		 mov	 ebp, esp

; 1827 :     Rsl(1);

  04b83	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__rp
  04b88	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__rk
  04b8e	c1 f8 02	 sar	 eax, 2
  04b91	83 f8 01	 cmp	 eax, 1
  04b94	7d 07		 jge	 SHORT $LN3@P_rfetch
  04b96	e8 00 00 00 00	 call	 _atl__Ersu
  04b9b	eb 57		 jmp	 SHORT $LN4@P_rfetch
$LN3@P_rfetch:

; 1828 :     So(1);

  04b9d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04ba3	83 c1 04	 add	 ecx, 4
  04ba6	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__sx
  04bac	76 0f		 jbe	 SHORT $LN2@P_rfetch
  04bae	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  04bb4	83 c2 04	 add	 edx, 4
  04bb7	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sx, edx
$LN2@P_rfetch:
  04bbd	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04bc2	83 c0 04	 add	 eax, 4
  04bc5	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__st
  04bcb	76 07		 jbe	 SHORT $LN1@P_rfetch
  04bcd	e8 00 00 00 00	 call	 _atl__Eso
  04bd2	eb 20		 jmp	 SHORT $LN4@P_rfetch
$LN1@P_rfetch:

; 1829 :     Push = (stackitem) R0;

  04bd4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04bda	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__rp
  04be0	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  04be3	89 01		 mov	 DWORD PTR [ecx], eax
  04be5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04beb	83 c1 04	 add	 ecx, 4
  04bee	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN4@P_rfetch:

; 1830 : }

  04bf4	5d		 pop	 ebp
  04bf5	c3		 ret	 0
_P_rfetch ENDP
; Function compile flags: /Odtp
_s$ = -4						; size = 4
_P_2dup	PROC

; 1844 : {

  04c00	55		 push	 ebp
  04c01	8b ec		 mov	 ebp, esp
  04c03	51		 push	 ecx

; 1845 :     stackitem s;
; 1846 : 
; 1847 :     Sl(2);

  04c04	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04c09	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  04c0f	c1 f8 02	 sar	 eax, 2
  04c12	83 f8 02	 cmp	 eax, 2
  04c15	7d 0a		 jge	 SHORT $LN3@P_2dup
  04c17	e8 00 00 00 00	 call	 _atl__Esu
  04c1c	e9 81 00 00 00	 jmp	 $LN4@P_2dup
$LN3@P_2dup:

; 1848 :     So(2);

  04c21	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04c27	83 c1 08	 add	 ecx, 8
  04c2a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__sx
  04c30	76 0f		 jbe	 SHORT $LN2@P_2dup
  04c32	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  04c38	83 c2 08	 add	 edx, 8
  04c3b	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sx, edx
$LN2@P_2dup:
  04c41	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04c46	83 c0 08	 add	 eax, 8
  04c49	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__st
  04c4f	76 07		 jbe	 SHORT $LN1@P_2dup
  04c51	e8 00 00 00 00	 call	 _atl__Eso
  04c56	eb 4a		 jmp	 SHORT $LN4@P_2dup
$LN1@P_2dup:

; 1849 :     s = S1;

  04c58	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04c5e	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  04c61	89 55 fc	 mov	 DWORD PTR _s$[ebp], edx

; 1850 :     Push = s;

  04c64	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04c69	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  04c6c	89 08		 mov	 DWORD PTR [eax], ecx
  04c6e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  04c74	83 c2 04	 add	 edx, 4
  04c77	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx

; 1851 :     s = S1;

  04c7d	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04c82	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  04c85	89 4d fc	 mov	 DWORD PTR _s$[ebp], ecx

; 1852 :     Push = s;

  04c88	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  04c8e	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  04c91	89 02		 mov	 DWORD PTR [edx], eax
  04c93	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04c99	83 c1 04	 add	 ecx, 4
  04c9c	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN4@P_2dup:

; 1853 : }

  04ca2	8b e5		 mov	 esp, ebp
  04ca4	5d		 pop	 ebp
  04ca5	c3		 ret	 0
_P_2dup	ENDP
; Function compile flags: /Odtp
_P_2drop PROC

; 1856 : {

  04cb0	55		 push	 ebp
  04cb1	8b ec		 mov	 ebp, esp

; 1857 :     Sl(2);

  04cb3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04cb8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  04cbe	c1 f8 02	 sar	 eax, 2
  04cc1	83 f8 02	 cmp	 eax, 2
  04cc4	7d 07		 jge	 SHORT $LN1@P_2drop
  04cc6	e8 00 00 00 00	 call	 _atl__Esu
  04ccb	eb 0f		 jmp	 SHORT $LN2@P_2drop
$LN1@P_2drop:

; 1858 :     stk -= 2;

  04ccd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04cd3	83 e9 08	 sub	 ecx, 8
  04cd6	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN2@P_2drop:

; 1859 : }

  04cdc	5d		 pop	 ebp
  04cdd	c3		 ret	 0
_P_2drop ENDP
; Function compile flags: /Odtp
_t$ = -4						; size = 4
_P_2swap PROC

; 1862 : {

  04ce0	55		 push	 ebp
  04ce1	8b ec		 mov	 ebp, esp
  04ce3	51		 push	 ecx

; 1863 :     stackitem t;
; 1864 : 
; 1865 :     Sl(4);

  04ce4	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04ce9	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  04cef	c1 f8 02	 sar	 eax, 2
  04cf2	83 f8 04	 cmp	 eax, 4
  04cf5	7d 07		 jge	 SHORT $LN1@P_2swap
  04cf7	e8 00 00 00 00	 call	 _atl__Esu
  04cfc	eb 52		 jmp	 SHORT $LN2@P_2swap
$LN1@P_2swap:

; 1866 :     t = S2;

  04cfe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04d04	8b 51 f4	 mov	 edx, DWORD PTR [ecx-12]
  04d07	89 55 fc	 mov	 DWORD PTR _t$[ebp], edx

; 1867 :     S2 = S0;

  04d0a	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04d0f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04d15	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  04d18	89 50 f4	 mov	 DWORD PTR [eax-12], edx

; 1868 :     S0 = t;

  04d1b	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04d20	8b 4d fc	 mov	 ecx, DWORD PTR _t$[ebp]
  04d23	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 1869 :     t = S3;

  04d26	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  04d2c	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  04d2f	89 45 fc	 mov	 DWORD PTR _t$[ebp], eax

; 1870 :     S3 = S1;

  04d32	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04d38	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  04d3e	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  04d41	89 41 f0	 mov	 DWORD PTR [ecx-16], eax

; 1871 :     S1 = t;

  04d44	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04d4a	8b 55 fc	 mov	 edx, DWORD PTR _t$[ebp]
  04d4d	89 51 f8	 mov	 DWORD PTR [ecx-8], edx
$LN2@P_2swap:

; 1872 : }

  04d50	8b e5		 mov	 esp, ebp
  04d52	5d		 pop	 ebp
  04d53	c3		 ret	 0
_P_2swap ENDP
; Function compile flags: /Odtp
_s$ = -4						; size = 4
_P_2over PROC

; 1875 : {

  04d60	55		 push	 ebp
  04d61	8b ec		 mov	 ebp, esp
  04d63	51		 push	 ecx

; 1876 :     stackitem s;
; 1877 : 
; 1878 :     Sl(4);

  04d64	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04d69	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  04d6f	c1 f8 02	 sar	 eax, 2
  04d72	83 f8 04	 cmp	 eax, 4
  04d75	7d 0a		 jge	 SHORT $LN3@P_2over
  04d77	e8 00 00 00 00	 call	 _atl__Esu
  04d7c	e9 81 00 00 00	 jmp	 $LN4@P_2over
$LN3@P_2over:

; 1879 :     So(2);

  04d81	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04d87	83 c1 08	 add	 ecx, 8
  04d8a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__sx
  04d90	76 0f		 jbe	 SHORT $LN2@P_2over
  04d92	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  04d98	83 c2 08	 add	 edx, 8
  04d9b	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sx, edx
$LN2@P_2over:
  04da1	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04da6	83 c0 08	 add	 eax, 8
  04da9	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__st
  04daf	76 07		 jbe	 SHORT $LN1@P_2over
  04db1	e8 00 00 00 00	 call	 _atl__Eso
  04db6	eb 4a		 jmp	 SHORT $LN4@P_2over
$LN1@P_2over:

; 1880 :     s = S3;

  04db8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04dbe	8b 51 f0	 mov	 edx, DWORD PTR [ecx-16]
  04dc1	89 55 fc	 mov	 DWORD PTR _s$[ebp], edx

; 1881 :     Push = s;

  04dc4	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04dc9	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  04dcc	89 08		 mov	 DWORD PTR [eax], ecx
  04dce	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  04dd4	83 c2 04	 add	 edx, 4
  04dd7	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx

; 1882 :     s = S3;

  04ddd	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04de2	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  04de5	89 4d fc	 mov	 DWORD PTR _s$[ebp], ecx

; 1883 :     Push = s;

  04de8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  04dee	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  04df1	89 02		 mov	 DWORD PTR [edx], eax
  04df3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04df9	83 c1 04	 add	 ecx, 4
  04dfc	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN4@P_2over:

; 1884 : }

  04e02	8b e5		 mov	 esp, ebp
  04e04	5d		 pop	 ebp
  04e05	c3		 ret	 0
_P_2over ENDP
; Function compile flags: /Odtp
_t1$ = -8						; size = 4
_t2$ = -4						; size = 4
_P_2rot	PROC

; 1887 : {

  04e10	55		 push	 ebp
  04e11	8b ec		 mov	 ebp, esp
  04e13	83 ec 08	 sub	 esp, 8

; 1888 :     stackitem t1, t2;
; 1889 : 
; 1890 :     Sl(6);

  04e16	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04e1b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  04e21	c1 f8 02	 sar	 eax, 2
  04e24	83 f8 06	 cmp	 eax, 6
  04e27	7d 07		 jge	 SHORT $LN1@P_2rot
  04e29	e8 00 00 00 00	 call	 _atl__Esu
  04e2e	eb 73		 jmp	 SHORT $LN2@P_2rot
$LN1@P_2rot:

; 1891 :     t2 = S5;

  04e30	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04e36	8b 51 e8	 mov	 edx, DWORD PTR [ecx-24]
  04e39	89 55 fc	 mov	 DWORD PTR _t2$[ebp], edx

; 1892 :     t1 = S4;

  04e3c	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04e41	8b 48 ec	 mov	 ecx, DWORD PTR [eax-20]
  04e44	89 4d f8	 mov	 DWORD PTR _t1$[ebp], ecx

; 1893 :     S5 = S3;

  04e47	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  04e4d	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04e52	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  04e55	89 4a e8	 mov	 DWORD PTR [edx-24], ecx

; 1894 :     S4 = S2;

  04e58	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  04e5e	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04e63	8b 48 f4	 mov	 ecx, DWORD PTR [eax-12]
  04e66	89 4a ec	 mov	 DWORD PTR [edx-20], ecx

; 1895 :     S3 = S1;

  04e69	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  04e6f	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04e74	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  04e77	89 4a f0	 mov	 DWORD PTR [edx-16], ecx

; 1896 :     S2 = S0;

  04e7a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  04e80	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04e85	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  04e88	89 4a f4	 mov	 DWORD PTR [edx-12], ecx

; 1897 :     S1 = t2;

  04e8b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  04e91	8b 45 fc	 mov	 eax, DWORD PTR _t2$[ebp]
  04e94	89 42 f8	 mov	 DWORD PTR [edx-8], eax

; 1898 :     S0 = t1;

  04e97	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04e9d	8b 55 f8	 mov	 edx, DWORD PTR _t1$[ebp]
  04ea0	89 51 fc	 mov	 DWORD PTR [ecx-4], edx
$LN2@P_2rot:

; 1899 : }

  04ea3	8b e5		 mov	 esp, ebp
  04ea5	5d		 pop	 ebp
  04ea6	c3		 ret	 0
_P_2rot	ENDP
; Function compile flags: /Odtp
_P_2variable PROC

; 1902 : {

  04eb0	55		 push	 ebp
  04eb1	8b ec		 mov	 ebp, esp

; 1903 :     P_create(); 		      /* Create dictionary item */

  04eb3	e8 00 00 00 00	 call	 _atl__Pcr

; 1904 :     Ho(2);

  04eb8	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  04ebd	83 c0 08	 add	 eax, 8
  04ec0	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hx
  04ec6	76 0f		 jbe	 SHORT $LN2@P_2variabl
  04ec8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  04ece	83 c1 08	 add	 ecx, 8
  04ed1	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hx, ecx
$LN2@P_2variabl:
  04ed7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  04edd	83 c2 08	 add	 edx, 8
  04ee0	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__ht
  04ee6	76 07		 jbe	 SHORT $LN1@P_2variabl
  04ee8	e8 00 00 00 00	 call	 _atl__Eho
  04eed	eb 33		 jmp	 SHORT $LN3@P_2variabl
$LN1@P_2variabl:

; 1905 :     Hstore = 0; 		      /* Initial value = 0... */

  04eef	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  04ef4	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  04efa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  04f00	83 c1 04	 add	 ecx, 4
  04f03	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hp, ecx

; 1906 :     Hstore = 0; 		      /* ...in both words */

  04f09	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  04f0f	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  04f15	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  04f1a	83 c0 04	 add	 eax, 4
  04f1d	a3 00 00 00 00	 mov	 DWORD PTR _atl__hp, eax
$LN3@P_2variabl:

; 1907 : }

  04f22	5d		 pop	 ebp
  04f23	c3		 ret	 0
_P_2variable ENDP
; Function compile flags: /Odtp
_P_2constant PROC

; 1917 : {

  04f30	55		 push	 ebp
  04f31	8b ec		 mov	 ebp, esp

; 1918 :     Sl(1);

  04f33	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04f38	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  04f3e	c1 f8 02	 sar	 eax, 2
  04f41	83 f8 01	 cmp	 eax, 1
  04f44	7d 0a		 jge	 SHORT $LN3@P_2constan
  04f46	e8 00 00 00 00	 call	 _atl__Esu
  04f4b	e9 93 00 00 00	 jmp	 $LN4@P_2constan
$LN3@P_2constan:

; 1919 :     P_create(); 		      /* Create dictionary item */

  04f50	e8 00 00 00 00	 call	 _atl__Pcr

; 1920 :     createword->wcode = P_2con;       /* Set code to constant push */

  04f55	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__wd
  04f5b	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], OFFSET _P_2con

; 1921 :     Ho(2);

  04f62	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  04f68	83 c2 08	 add	 edx, 8
  04f6b	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hx
  04f71	76 0d		 jbe	 SHORT $LN2@P_2constan
  04f73	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  04f78	83 c0 08	 add	 eax, 8
  04f7b	a3 00 00 00 00	 mov	 DWORD PTR _atl__hx, eax
$LN2@P_2constan:
  04f80	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  04f86	83 c1 08	 add	 ecx, 8
  04f89	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  04f8f	76 07		 jbe	 SHORT $LN1@P_2constan
  04f91	e8 00 00 00 00	 call	 _atl__Eho
  04f96	eb 4b		 jmp	 SHORT $LN4@P_2constan
$LN1@P_2constan:

; 1922 :     Hstore = S1;		      /* Store double word constant value */

  04f98	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  04f9e	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04fa3	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  04fa6	89 0a		 mov	 DWORD PTR [edx], ecx
  04fa8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  04fae	83 c2 04	 add	 edx, 4
  04fb1	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hp, edx

; 1923 :     Hstore = S0;		      /* in the two words of body */

  04fb7	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  04fbc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04fc2	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  04fc5	89 10		 mov	 DWORD PTR [eax], edx
  04fc7	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  04fcc	83 c0 04	 add	 eax, 4
  04fcf	a3 00 00 00 00	 mov	 DWORD PTR _atl__hp, eax

; 1924 :     Pop2;

  04fd4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  04fda	83 e9 08	 sub	 ecx, 8
  04fdd	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN4@P_2constan:

; 1925 : }

  04fe3	5d		 pop	 ebp
  04fe4	c3		 ret	 0
_P_2constant ENDP
; Function compile flags: /Odtp
_P_2con PROC

; 1910 : {

  04ff0	55		 push	 ebp
  04ff1	8b ec		 mov	 ebp, esp

; 1911 :     So(2);

  04ff3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  04ff8	83 c0 08	 add	 eax, 8
  04ffb	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__sx
  05001	76 0f		 jbe	 SHORT $LN2@P_2con
  05003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  05009	83 c1 08	 add	 ecx, 8
  0500c	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sx, ecx
$LN2@P_2con:
  05012	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  05018	83 c2 08	 add	 edx, 8
  0501b	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__st
  05021	76 07		 jbe	 SHORT $LN1@P_2con
  05023	e8 00 00 00 00	 call	 _atl__Eso
  05028	eb 3d		 jmp	 SHORT $LN3@P_2con
$LN1@P_2con:

; 1912 :     Push = *(((stackitem *) curword) + Dictwordl);

  0502a	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0502f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__cw
  05035	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  05038	89 10		 mov	 DWORD PTR [eax], edx
  0503a	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0503f	83 c0 04	 add	 eax, 4
  05042	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax

; 1913 :     Push = *(((stackitem *) curword) + Dictwordl + 1);

  05047	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0504d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__cw
  05053	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  05056	89 01		 mov	 DWORD PTR [ecx], eax
  05058	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0505e	83 c1 04	 add	 ecx, 4
  05061	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN3@P_2con:

; 1914 : }

  05067	5d		 pop	 ebp
  05068	c3		 ret	 0
_P_2con	ENDP
; Function compile flags: /Odtp
_sp$ = -4						; size = 4
_P_2bang PROC

; 1928 : {

  05070	55		 push	 ebp
  05071	8b ec		 mov	 ebp, esp
  05073	51		 push	 ecx

; 1929 :     stackitem *sp;
; 1930 : 
; 1931 :     Sl(2);

  05074	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  05079	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0507f	c1 f8 02	 sar	 eax, 2
  05082	83 f8 02	 cmp	 eax, 2
  05085	7d 07		 jge	 SHORT $LN3@P_2bang
  05087	e8 00 00 00 00	 call	 _atl__Esu
  0508c	eb 67		 jmp	 SHORT $LN4@P_2bang
$LN3@P_2bang:

; 1932 :     Hpc(S0);

  0508e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  05094	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  05097	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  0509d	72 10		 jb	 SHORT $LN1@P_2bang
  0509f	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  050a4	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  050a7	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  050ad	72 07		 jb	 SHORT $LN2@P_2bang
$LN1@P_2bang:
  050af	e8 00 00 00 00	 call	 _atl__Ebp
  050b4	eb 3f		 jmp	 SHORT $LN4@P_2bang
$LN2@P_2bang:

; 1933 :     sp = (stackitem *) S0;

  050b6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  050bc	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  050bf	89 45 fc	 mov	 DWORD PTR _sp$[ebp], eax

; 1934 :     *sp++ = S2;

  050c2	8b 4d fc	 mov	 ecx, DWORD PTR _sp$[ebp]
  050c5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  050cb	8b 42 f4	 mov	 eax, DWORD PTR [edx-12]
  050ce	89 01		 mov	 DWORD PTR [ecx], eax
  050d0	8b 4d fc	 mov	 ecx, DWORD PTR _sp$[ebp]
  050d3	83 c1 04	 add	 ecx, 4
  050d6	89 4d fc	 mov	 DWORD PTR _sp$[ebp], ecx

; 1935 :     *sp = S1;

  050d9	8b 55 fc	 mov	 edx, DWORD PTR _sp$[ebp]
  050dc	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  050e1	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  050e4	89 0a		 mov	 DWORD PTR [edx], ecx

; 1936 :     Npop(3);

  050e6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  050ec	83 ea 0c	 sub	 edx, 12			; 0000000cH
  050ef	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN4@P_2bang:

; 1937 : }

  050f5	8b e5		 mov	 esp, ebp
  050f7	5d		 pop	 ebp
  050f8	c3		 ret	 0
_P_2bang ENDP
; Function compile flags: /Odtp
_sp$ = -4						; size = 4
_P_2at	PROC

; 1940 : {

  05100	55		 push	 ebp
  05101	8b ec		 mov	 ebp, esp
  05103	51		 push	 ecx

; 1941 :     stackitem *sp;
; 1942 : 
; 1943 :     Sl(1);

  05104	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  05109	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0510f	c1 f8 02	 sar	 eax, 2
  05112	83 f8 01	 cmp	 eax, 1
  05115	7d 0a		 jge	 SHORT $LN5@P_2at
  05117	e8 00 00 00 00	 call	 _atl__Esu
  0511c	e9 9e 00 00 00	 jmp	 $LN6@P_2at
$LN5@P_2at:

; 1944 :     So(1);

  05121	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  05127	83 c1 04	 add	 ecx, 4
  0512a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__sx
  05130	76 0f		 jbe	 SHORT $LN4@P_2at
  05132	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  05138	83 c2 04	 add	 edx, 4
  0513b	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sx, edx
$LN4@P_2at:
  05141	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  05146	83 c0 04	 add	 eax, 4
  05149	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__st
  0514f	76 07		 jbe	 SHORT $LN3@P_2at
  05151	e8 00 00 00 00	 call	 _atl__Eso
  05156	eb 67		 jmp	 SHORT $LN6@P_2at
$LN3@P_2at:

; 1945 :     Hpc(S0);

  05158	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0515e	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  05161	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  05167	72 10		 jb	 SHORT $LN1@P_2at
  05169	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0516e	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  05171	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  05177	72 07		 jb	 SHORT $LN2@P_2at
$LN1@P_2at:
  05179	e8 00 00 00 00	 call	 _atl__Ebp
  0517e	eb 3f		 jmp	 SHORT $LN6@P_2at
$LN2@P_2at:

; 1946 :     sp = (stackitem *) S0;

  05180	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  05186	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  05189	89 45 fc	 mov	 DWORD PTR _sp$[ebp], eax

; 1947 :     S0 = *sp++;

  0518c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  05192	8b 55 fc	 mov	 edx, DWORD PTR _sp$[ebp]
  05195	8b 02		 mov	 eax, DWORD PTR [edx]
  05197	89 41 fc	 mov	 DWORD PTR [ecx-4], eax
  0519a	8b 4d fc	 mov	 ecx, DWORD PTR _sp$[ebp]
  0519d	83 c1 04	 add	 ecx, 4
  051a0	89 4d fc	 mov	 DWORD PTR _sp$[ebp], ecx

; 1948 :     Push = *sp;

  051a3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  051a9	8b 45 fc	 mov	 eax, DWORD PTR _sp$[ebp]
  051ac	8b 08		 mov	 ecx, DWORD PTR [eax]
  051ae	89 0a		 mov	 DWORD PTR [edx], ecx
  051b0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  051b6	83 c2 04	 add	 edx, 4
  051b9	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN6@P_2at:

; 1949 : }

  051bf	8b e5		 mov	 esp, ebp
  051c1	5d		 pop	 ebp
  051c2	c3		 ret	 0
_P_2at	ENDP
; Function compile flags: /Odtp
_P_dolit PROC

; 1955 : {

  051d0	55		 push	 ebp
  051d1	8b ec		 mov	 ebp, esp

; 1956 :     So(1);

  051d3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  051d8	83 c0 04	 add	 eax, 4
  051db	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__sx
  051e1	76 0f		 jbe	 SHORT $LN3@P_dolit
  051e3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  051e9	83 c1 04	 add	 ecx, 4
  051ec	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sx, ecx
$LN3@P_dolit:
  051f2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  051f8	83 c2 04	 add	 edx, 4
  051fb	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__st
  05201	76 07		 jbe	 SHORT $LN2@P_dolit
  05203	e8 00 00 00 00	 call	 _atl__Eso
  05208	eb 49		 jmp	 SHORT $LN4@P_dolit
$LN2@P_dolit:

; 1957 : #ifdef TRACE
; 1958 :     if (atl_trace) {

  0520a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _atl_trace, 0
  05211	74 15		 je	 SHORT $LN1@P_dolit

; 1959 :         V printf("%ld ", (long) *ip);

  05213	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__ip
  05218	8b 08		 mov	 ecx, DWORD PTR [eax]
  0521a	51		 push	 ecx
  0521b	68 00 00 00 00	 push	 OFFSET $SG84291
  05220	e8 00 00 00 00	 call	 _printf
  05225	83 c4 08	 add	 esp, 8
$LN1@P_dolit:

; 1960 :     }
; 1961 : #endif
; 1962 :     Push = (stackitem) *ip++;	      /* Push the next datum from the

  05228	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0522e	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__ip
  05233	8b 08		 mov	 ecx, DWORD PTR [eax]
  05235	89 0a		 mov	 DWORD PTR [edx], ecx
  05237	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0523d	83 c2 04	 add	 edx, 4
  05240	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
  05246	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__ip
  0524b	83 c0 04	 add	 eax, 4
  0524e	a3 00 00 00 00	 mov	 DWORD PTR _atl__ip, eax
$LN4@P_dolit:

; 1963 : 					 instruction stream. */
; 1964 : }

  05253	5d		 pop	 ebp
  05254	c3		 ret	 0
_P_dolit ENDP
_TEXT	ENDS
_BSS	SEGMENT
_wbptr	DD	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
_P_nest	PROC

; 1969 : {

  05260	55		 push	 ebp
  05261	8b ec		 mov	 ebp, esp

; 1970 :     Rso(1);

  05263	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__rp
  05268	83 c0 04	 add	 eax, 4
  0526b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__rx
  05271	76 0f		 jbe	 SHORT $LN2@P_nest
  05273	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__rp
  05279	83 c1 04	 add	 ecx, 4
  0527c	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__rx, ecx
$LN2@P_nest:
  05282	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__rp
  05288	83 c2 04	 add	 edx, 4
  0528b	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__rt
  05291	76 07		 jbe	 SHORT $LN1@P_nest
  05293	e8 00 00 00 00	 call	 _atl__Erso
  05298	eb 45		 jmp	 SHORT $LN3@P_nest
$LN1@P_nest:

; 1971 : #ifdef WALKBACK
; 1972 :     *wbptr++ = curword; 	      /* Place word on walkback stack */

  0529a	a1 00 00 00 00	 mov	 eax, DWORD PTR _wbptr
  0529f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__cw
  052a5	89 08		 mov	 DWORD PTR [eax], ecx
  052a7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _wbptr
  052ad	83 c2 04	 add	 edx, 4
  052b0	89 15 00 00 00
	00		 mov	 DWORD PTR _wbptr, edx

; 1973 : #endif
; 1974 :     Rpush = ip; 		      /* Push instruction pointer */

  052b6	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__rp
  052bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__ip
  052c1	89 08		 mov	 DWORD PTR [eax], ecx
  052c3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__rp
  052c9	83 c2 04	 add	 edx, 4
  052cc	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__rp, edx

; 1975 :     ip = (((dictword **) curword) + Dictwordl);

  052d2	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__cw
  052d7	83 c0 0c	 add	 eax, 12			; 0000000cH
  052da	a3 00 00 00 00	 mov	 DWORD PTR _atl__ip, eax
$LN3@P_nest:

; 1976 : }

  052df	5d		 pop	 ebp
  052e0	c3		 ret	 0
_P_nest	ENDP
; Function compile flags: /Odtp
tv69 = -4						; size = 4
_P_exit	PROC

; 1979 : {

  052f0	55		 push	 ebp
  052f1	8b ec		 mov	 ebp, esp
  052f3	51		 push	 ecx

; 1980 :     Rsl(1);

  052f4	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__rp
  052f9	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__rk
  052ff	c1 f8 02	 sar	 eax, 2
  05302	83 f8 01	 cmp	 eax, 1
  05305	7d 07		 jge	 SHORT $LN1@P_exit
  05307	e8 00 00 00 00	 call	 _atl__Ersu
  0530c	eb 4a		 jmp	 SHORT $LN2@P_exit
$LN1@P_exit:

; 1981 : #ifdef WALKBACK
; 1982 :     wbptr = (wbptr > wback) ? wbptr - 1 : wback;

  0530e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _wbptr
  05314	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _wback
  0531a	76 0e		 jbe	 SHORT $LN4@P_exit
  0531c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _wbptr
  05322	83 ea 04	 sub	 edx, 4
  05325	89 55 fc	 mov	 DWORD PTR tv69[ebp], edx
  05328	eb 08		 jmp	 SHORT $LN5@P_exit
$LN4@P_exit:
  0532a	a1 00 00 00 00	 mov	 eax, DWORD PTR _wback
  0532f	89 45 fc	 mov	 DWORD PTR tv69[ebp], eax
$LN5@P_exit:
  05332	8b 4d fc	 mov	 ecx, DWORD PTR tv69[ebp]
  05335	89 0d 00 00 00
	00		 mov	 DWORD PTR _wbptr, ecx

; 1983 : #endif
; 1984 :     ip = R0;			      /* Set IP to top of return stack */

  0533b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__rp
  05341	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  05344	a3 00 00 00 00	 mov	 DWORD PTR _atl__ip, eax

; 1985 :     Rpop;

  05349	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__rp
  0534f	83 e9 04	 sub	 ecx, 4
  05352	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__rp, ecx
$LN2@P_exit:

; 1986 : }

  05358	8b e5		 mov	 esp, ebp
  0535a	5d		 pop	 ebp
  0535b	c3		 ret	 0
_P_exit	ENDP
; Function compile flags: /Odtp
_P_branch PROC

; 1989 : {

  05360	55		 push	 ebp
  05361	8b ec		 mov	 ebp, esp

; 1990 :     ip += (stackitem) *ip;	      /* Jump addresses are IP-relative */

  05363	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__ip
  05368	8b 08		 mov	 ecx, DWORD PTR [eax]
  0536a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__ip
  05370	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  05373	a3 00 00 00 00	 mov	 DWORD PTR _atl__ip, eax

; 1991 : }

  05378	5d		 pop	 ebp
  05379	c3		 ret	 0
_P_branch ENDP
; Function compile flags: /Odtp
_P_qbranch PROC

; 1994 : {

  05380	55		 push	 ebp
  05381	8b ec		 mov	 ebp, esp

; 1995 :     Sl(1);

  05383	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  05388	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0538e	c1 f8 02	 sar	 eax, 2
  05391	83 f8 01	 cmp	 eax, 1
  05394	7d 07		 jge	 SHORT $LN3@P_qbranch
  05396	e8 00 00 00 00	 call	 _atl__Esu
  0539b	eb 41		 jmp	 SHORT $LN4@P_qbranch
$LN3@P_qbranch:

; 1996 :     if (S0 == 0)		      /* If flag is false */

  0539d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  053a3	83 79 fc 00	 cmp	 DWORD PTR [ecx-4], 0
  053a7	75 19		 jne	 SHORT $LN2@P_qbranch

; 1997 : 	ip += (stackitem) *ip;	      /* then branch. */

  053a9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__ip
  053af	8b 02		 mov	 eax, DWORD PTR [edx]
  053b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__ip
  053b7	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  053ba	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__ip, edx

; 1998 :     else			      /* Otherwise */

  053c0	eb 0d		 jmp	 SHORT $LN1@P_qbranch
$LN2@P_qbranch:

; 1999 : 	ip++;			      /* skip the in-line address. */

  053c2	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__ip
  053c7	83 c0 04	 add	 eax, 4
  053ca	a3 00 00 00 00	 mov	 DWORD PTR _atl__ip, eax
$LN1@P_qbranch:

; 2000 :     Pop;

  053cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  053d5	83 e9 04	 sub	 ecx, 4
  053d8	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN4@P_qbranch:

; 2001 : }

  053de	5d		 pop	 ebp
  053df	c3		 ret	 0
_P_qbranch ENDP
_TEXT	ENDS
_BSS	SEGMENT
_s_qbranch DD	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
_P_if	PROC

; 2004 : {

  053e0	55		 push	 ebp
  053e1	8b ec		 mov	 ebp, esp

; 2005 :     Compiling;

  053e3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hb
  053e8	83 38 00	 cmp	 DWORD PTR [eax], 0
  053eb	75 0a		 jne	 SHORT $LN7@P_if
  053ed	e8 00 00 00 00	 call	 _notcomp
  053f2	e9 f9 00 00 00	 jmp	 $LN8@P_if
$LN7@P_if:

; 2006 :     Compconst(s_qbranch);	      /* Compile question branch */

  053f7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  053fd	83 c1 04	 add	 ecx, 4
  05400	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__hx
  05406	76 0f		 jbe	 SHORT $LN6@P_if
  05408	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  0540e	83 c2 04	 add	 edx, 4
  05411	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hx, edx
$LN6@P_if:
  05417	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  0541c	83 c0 04	 add	 eax, 4
  0541f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__ht
  05425	76 0a		 jbe	 SHORT $LN5@P_if
  05427	e8 00 00 00 00	 call	 _atl__Eho
  0542c	e9 bf 00 00 00	 jmp	 $LN8@P_if
$LN5@P_if:
  05431	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  05437	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _s_qbranch
  0543d	89 11		 mov	 DWORD PTR [ecx], edx
  0543f	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  05444	83 c0 04	 add	 eax, 4
  05447	a3 00 00 00 00	 mov	 DWORD PTR _atl__hp, eax

; 2007 :     So(1);

  0544c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  05452	83 c1 04	 add	 ecx, 4
  05455	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__sx
  0545b	76 0f		 jbe	 SHORT $LN4@P_if
  0545d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  05463	83 c2 04	 add	 edx, 4
  05466	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sx, edx
$LN4@P_if:
  0546c	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  05471	83 c0 04	 add	 eax, 4
  05474	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__st
  0547a	76 07		 jbe	 SHORT $LN3@P_if
  0547c	e8 00 00 00 00	 call	 _atl__Eso
  05481	eb 6d		 jmp	 SHORT $LN8@P_if
$LN3@P_if:

; 2008 :     Push = (stackitem) hptr;	      /* Save backpatch address on stack */

  05483	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  05489	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  0548f	89 11		 mov	 DWORD PTR [ecx], edx
  05491	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  05496	83 c0 04	 add	 eax, 4
  05499	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax

; 2009 :     Compconst(0);		      /* Compile place-holder address cell */

  0549e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  054a4	83 c1 04	 add	 ecx, 4
  054a7	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__hx
  054ad	76 0f		 jbe	 SHORT $LN2@P_if
  054af	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  054b5	83 c2 04	 add	 edx, 4
  054b8	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hx, edx
$LN2@P_if:
  054be	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  054c3	83 c0 04	 add	 eax, 4
  054c6	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__ht
  054cc	76 07		 jbe	 SHORT $LN1@P_if
  054ce	e8 00 00 00 00	 call	 _atl__Eho
  054d3	eb 1b		 jmp	 SHORT $LN8@P_if
$LN1@P_if:
  054d5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  054db	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  054e1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  054e7	83 c2 04	 add	 edx, 4
  054ea	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hp, edx
$LN8@P_if:

; 2010 : }

  054f0	5d		 pop	 ebp
  054f1	c3		 ret	 0
_P_if	ENDP
_TEXT	ENDS
_BSS	SEGMENT
_s_branch DD	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
_bp$ = -4						; size = 4
_P_else	PROC

; 2013 : {

  05500	55		 push	 ebp
  05501	8b ec		 mov	 ebp, esp
  05503	51		 push	 ecx

; 2014 :     stackitem *bp;
; 2015 : 
; 2016 :     Compiling;

  05504	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hb
  05509	83 38 00	 cmp	 DWORD PTR [eax], 0
  0550c	75 0a		 jne	 SHORT $LN8@P_else
  0550e	e8 00 00 00 00	 call	 _notcomp
  05513	e9 18 01 00 00	 jmp	 $LN9@P_else
$LN8@P_else:

; 2017 :     Sl(1);

  05518	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0551e	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _atl__sk
  05524	c1 f9 02	 sar	 ecx, 2
  05527	83 f9 01	 cmp	 ecx, 1
  0552a	7d 0a		 jge	 SHORT $LN7@P_else
  0552c	e8 00 00 00 00	 call	 _atl__Esu
  05531	e9 fa 00 00 00	 jmp	 $LN9@P_else
$LN7@P_else:

; 2018 :     Compconst(s_branch);	      /* Compile branch around other clause */

  05536	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  0553c	83 c2 04	 add	 edx, 4
  0553f	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hx
  05545	76 0d		 jbe	 SHORT $LN6@P_else
  05547	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  0554c	83 c0 04	 add	 eax, 4
  0554f	a3 00 00 00 00	 mov	 DWORD PTR _atl__hx, eax
$LN6@P_else:
  05554	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  0555a	83 c1 04	 add	 ecx, 4
  0555d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  05563	76 0a		 jbe	 SHORT $LN5@P_else
  05565	e8 00 00 00 00	 call	 _atl__Eho
  0556a	e9 c1 00 00 00	 jmp	 $LN9@P_else
$LN5@P_else:
  0556f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  05575	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_branch
  0557a	89 02		 mov	 DWORD PTR [edx], eax
  0557c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  05582	83 c1 04	 add	 ecx, 4
  05585	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hp, ecx

; 2019 :     Compconst(0);		      /* Compile place-holder address cell */

  0558b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  05591	83 c2 04	 add	 edx, 4
  05594	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hx
  0559a	76 0d		 jbe	 SHORT $LN4@P_else
  0559c	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  055a1	83 c0 04	 add	 eax, 4
  055a4	a3 00 00 00 00	 mov	 DWORD PTR _atl__hx, eax
$LN4@P_else:
  055a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  055af	83 c1 04	 add	 ecx, 4
  055b2	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  055b8	76 07		 jbe	 SHORT $LN3@P_else
  055ba	e8 00 00 00 00	 call	 _atl__Eho
  055bf	eb 6f		 jmp	 SHORT $LN9@P_else
$LN3@P_else:
  055c1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  055c7	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  055cd	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  055d2	83 c0 04	 add	 eax, 4
  055d5	a3 00 00 00 00	 mov	 DWORD PTR _atl__hp, eax

; 2020 :     Hpc(S0);

  055da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  055e0	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  055e3	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  055e9	72 10		 jb	 SHORT $LN1@P_else
  055eb	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  055f0	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  055f3	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  055f9	72 07		 jb	 SHORT $LN2@P_else
$LN1@P_else:
  055fb	e8 00 00 00 00	 call	 _atl__Ebp
  05600	eb 2e		 jmp	 SHORT $LN9@P_else
$LN2@P_else:

; 2021 :     bp = (stackitem *) S0;	      /* Get IF backpatch address */

  05602	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  05608	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  0560b	89 45 fc	 mov	 DWORD PTR _bp$[ebp], eax

; 2022 :     *bp = hptr - bp;

  0560e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  05614	2b 4d fc	 sub	 ecx, DWORD PTR _bp$[ebp]
  05617	c1 f9 02	 sar	 ecx, 2
  0561a	8b 55 fc	 mov	 edx, DWORD PTR _bp$[ebp]
  0561d	89 0a		 mov	 DWORD PTR [edx], ecx

; 2023 :     S0 = (stackitem) (hptr - 1);      /* Update backpatch for THEN */

  0561f	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  05624	83 e8 04	 sub	 eax, 4
  05627	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0562d	89 41 fc	 mov	 DWORD PTR [ecx-4], eax
$LN9@P_else:

; 2024 : }

  05630	8b e5		 mov	 esp, ebp
  05632	5d		 pop	 ebp
  05633	c3		 ret	 0
_P_else	ENDP
; Function compile flags: /Odtp
_bp$ = -4						; size = 4
_P_then	PROC

; 2027 : {

  05640	55		 push	 ebp
  05641	8b ec		 mov	 ebp, esp
  05643	51		 push	 ecx

; 2028 :     stackitem *bp;
; 2029 : 
; 2030 :     Compiling;

  05644	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hb
  05649	83 38 00	 cmp	 DWORD PTR [eax], 0
  0564c	75 07		 jne	 SHORT $LN4@P_then
  0564e	e8 00 00 00 00	 call	 _notcomp
  05653	eb 6f		 jmp	 SHORT $LN5@P_then
$LN4@P_then:

; 2031 :     Sl(1);

  05655	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0565b	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _atl__sk
  05661	c1 f9 02	 sar	 ecx, 2
  05664	83 f9 01	 cmp	 ecx, 1
  05667	7d 07		 jge	 SHORT $LN3@P_then
  05669	e8 00 00 00 00	 call	 _atl__Esu
  0566e	eb 54		 jmp	 SHORT $LN5@P_then
$LN3@P_then:

; 2032 :     Hpc(S0);

  05670	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  05676	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  05679	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hs
  0567f	72 11		 jb	 SHORT $LN1@P_then
  05681	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  05687	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  0568a	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__ht
  05690	72 07		 jb	 SHORT $LN2@P_then
$LN1@P_then:
  05692	e8 00 00 00 00	 call	 _atl__Ebp
  05697	eb 2b		 jmp	 SHORT $LN5@P_then
$LN2@P_then:

; 2033 :     bp = (stackitem *) S0;	      /* Get IF/ELSE backpatch address */

  05699	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0569e	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  056a1	89 4d fc	 mov	 DWORD PTR _bp$[ebp], ecx

; 2034 :     *bp = hptr - bp;

  056a4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  056aa	2b 55 fc	 sub	 edx, DWORD PTR _bp$[ebp]
  056ad	c1 fa 02	 sar	 edx, 2
  056b0	8b 45 fc	 mov	 eax, DWORD PTR _bp$[ebp]
  056b3	89 10		 mov	 DWORD PTR [eax], edx

; 2035 :     Pop;

  056b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  056bb	83 e9 04	 sub	 ecx, 4
  056be	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN5@P_then:

; 2036 : }

  056c4	8b e5		 mov	 esp, ebp
  056c6	5d		 pop	 ebp
  056c7	c3		 ret	 0
_P_then	ENDP
; Function compile flags: /Odtp
_s$84356 = -4						; size = 4
_P_qdup	PROC

; 2039 : {

  056d0	55		 push	 ebp
  056d1	8b ec		 mov	 ebp, esp
  056d3	51		 push	 ecx

; 2040 :     Sl(1);

  056d4	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  056d9	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  056df	c1 f8 02	 sar	 eax, 2
  056e2	83 f8 01	 cmp	 eax, 1
  056e5	7d 07		 jge	 SHORT $LN4@P_qdup
  056e7	e8 00 00 00 00	 call	 _atl__Esu
  056ec	eb 67		 jmp	 SHORT $LN5@P_qdup
$LN4@P_qdup:

; 2041 :     if (S0 != 0) {

  056ee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  056f4	83 79 fc 00	 cmp	 DWORD PTR [ecx-4], 0
  056f8	74 5b		 je	 SHORT $LN5@P_qdup

; 2042 : 	stackitem s = S0;

  056fa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  05700	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  05703	89 45 fc	 mov	 DWORD PTR _s$84356[ebp], eax

; 2043 : 	So(1);

  05706	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0570c	83 c1 04	 add	 ecx, 4
  0570f	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__sx
  05715	76 0f		 jbe	 SHORT $LN2@P_qdup
  05717	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0571d	83 c2 04	 add	 edx, 4
  05720	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sx, edx
$LN2@P_qdup:
  05726	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0572b	83 c0 04	 add	 eax, 4
  0572e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__st
  05734	76 07		 jbe	 SHORT $LN1@P_qdup
  05736	e8 00 00 00 00	 call	 _atl__Eso
  0573b	eb 18		 jmp	 SHORT $LN5@P_qdup
$LN1@P_qdup:

; 2044 : 	Push = s;

  0573d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  05743	8b 55 fc	 mov	 edx, DWORD PTR _s$84356[ebp]
  05746	89 11		 mov	 DWORD PTR [ecx], edx
  05748	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0574d	83 c0 04	 add	 eax, 4
  05750	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN5@P_qdup:

; 2045 :     }
; 2046 : }

  05755	8b e5		 mov	 esp, ebp
  05757	5d		 pop	 ebp
  05758	c3		 ret	 0
_P_qdup	ENDP
; Function compile flags: /Odtp
_P_begin PROC

; 2049 : {

  05760	55		 push	 ebp
  05761	8b ec		 mov	 ebp, esp

; 2050 :     Compiling;

  05763	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hb
  05768	83 38 00	 cmp	 DWORD PTR [eax], 0
  0576b	75 07		 jne	 SHORT $LN3@P_begin
  0576d	e8 00 00 00 00	 call	 _notcomp
  05772	eb 52		 jmp	 SHORT $LN4@P_begin
$LN3@P_begin:

; 2051 :     So(1);

  05774	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0577a	83 c1 04	 add	 ecx, 4
  0577d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__sx
  05783	76 0f		 jbe	 SHORT $LN2@P_begin
  05785	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0578b	83 c2 04	 add	 edx, 4
  0578e	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sx, edx
$LN2@P_begin:
  05794	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  05799	83 c0 04	 add	 eax, 4
  0579c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__st
  057a2	76 07		 jbe	 SHORT $LN1@P_begin
  057a4	e8 00 00 00 00	 call	 _atl__Eso
  057a9	eb 1b		 jmp	 SHORT $LN4@P_begin
$LN1@P_begin:

; 2052 :     Push = (stackitem) hptr;	      /* Save jump back address on stack */

  057ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  057b1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  057b7	89 11		 mov	 DWORD PTR [ecx], edx
  057b9	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  057be	83 c0 04	 add	 eax, 4
  057c1	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN4@P_begin:

; 2053 : }

  057c6	5d		 pop	 ebp
  057c7	c3		 ret	 0
_P_begin ENDP
; Function compile flags: /Odtp
_off$ = -8						; size = 4
_bp$ = -4						; size = 4
_P_until PROC

; 2056 : {

  057d0	55		 push	 ebp
  057d1	8b ec		 mov	 ebp, esp
  057d3	83 ec 08	 sub	 esp, 8

; 2057 :     stackitem off;
; 2058 :     stackitem *bp;
; 2059 : 
; 2060 :     Compiling;

  057d6	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hb
  057db	83 38 00	 cmp	 DWORD PTR [eax], 0
  057de	75 0a		 jne	 SHORT $LN8@P_until
  057e0	e8 00 00 00 00	 call	 _notcomp
  057e5	e9 15 01 00 00	 jmp	 $LN9@P_until
$LN8@P_until:

; 2061 :     Sl(1);

  057ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  057f0	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _atl__sk
  057f6	c1 f9 02	 sar	 ecx, 2
  057f9	83 f9 01	 cmp	 ecx, 1
  057fc	7d 0a		 jge	 SHORT $LN7@P_until
  057fe	e8 00 00 00 00	 call	 _atl__Esu
  05803	e9 f7 00 00 00	 jmp	 $LN9@P_until
$LN7@P_until:

; 2062 :     Compconst(s_qbranch);	      /* Compile question branch */

  05808	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  0580e	83 c2 04	 add	 edx, 4
  05811	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hx
  05817	76 0d		 jbe	 SHORT $LN6@P_until
  05819	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  0581e	83 c0 04	 add	 eax, 4
  05821	a3 00 00 00 00	 mov	 DWORD PTR _atl__hx, eax
$LN6@P_until:
  05826	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  0582c	83 c1 04	 add	 ecx, 4
  0582f	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  05835	76 0a		 jbe	 SHORT $LN5@P_until
  05837	e8 00 00 00 00	 call	 _atl__Eho
  0583c	e9 be 00 00 00	 jmp	 $LN9@P_until
$LN5@P_until:
  05841	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  05847	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_qbranch
  0584c	89 02		 mov	 DWORD PTR [edx], eax
  0584e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  05854	83 c1 04	 add	 ecx, 4
  05857	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hp, ecx

; 2063 :     Hpc(S0);

  0585d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  05863	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  05866	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hs
  0586c	72 11		 jb	 SHORT $LN3@P_until
  0586e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  05874	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  05877	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__ht
  0587d	72 07		 jb	 SHORT $LN4@P_until
$LN3@P_until:
  0587f	e8 00 00 00 00	 call	 _atl__Ebp
  05884	eb 79		 jmp	 SHORT $LN9@P_until
$LN4@P_until:

; 2064 :     bp = (stackitem *) S0;	      /* Get BEGIN address */

  05886	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0588b	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0588e	89 4d fc	 mov	 DWORD PTR _bp$[ebp], ecx

; 2065 :     off = -(hptr - bp);

  05891	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  05897	2b 55 fc	 sub	 edx, DWORD PTR _bp$[ebp]
  0589a	c1 fa 02	 sar	 edx, 2
  0589d	f7 da		 neg	 edx
  0589f	89 55 f8	 mov	 DWORD PTR _off$[ebp], edx

; 2066 :     Compconst(off);		      /* Compile negative jumpback address */

  058a2	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  058a7	83 c0 04	 add	 eax, 4
  058aa	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hx
  058b0	76 0f		 jbe	 SHORT $LN2@P_until
  058b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  058b8	83 c1 04	 add	 ecx, 4
  058bb	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hx, ecx
$LN2@P_until:
  058c1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  058c7	83 c2 04	 add	 edx, 4
  058ca	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__ht
  058d0	76 07		 jbe	 SHORT $LN1@P_until
  058d2	e8 00 00 00 00	 call	 _atl__Eho
  058d7	eb 26		 jmp	 SHORT $LN9@P_until
$LN1@P_until:
  058d9	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  058de	8b 4d f8	 mov	 ecx, DWORD PTR _off$[ebp]
  058e1	89 08		 mov	 DWORD PTR [eax], ecx
  058e3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  058e9	83 c2 04	 add	 edx, 4
  058ec	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hp, edx

; 2067 :     Pop;

  058f2	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  058f7	83 e8 04	 sub	 eax, 4
  058fa	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN9@P_until:

; 2068 : }

  058ff	8b e5		 mov	 esp, ebp
  05901	5d		 pop	 ebp
  05902	c3		 ret	 0
_P_until ENDP
; Function compile flags: /Odtp
_off$ = -8						; size = 4
_bp$ = -4						; size = 4
_P_again PROC

; 2071 : {

  05910	55		 push	 ebp
  05911	8b ec		 mov	 ebp, esp
  05913	83 ec 08	 sub	 esp, 8

; 2072 :     stackitem off;
; 2073 :     stackitem *bp;
; 2074 : 
; 2075 :     Compiling;

  05916	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hb
  0591b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0591e	75 0a		 jne	 SHORT $LN7@P_again
  05920	e8 00 00 00 00	 call	 _notcomp
  05925	e9 f9 00 00 00	 jmp	 $LN8@P_again
$LN7@P_again:

; 2076 :     Compconst(s_branch);	      /* Compile unconditional branch */

  0592a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  05930	83 c1 04	 add	 ecx, 4
  05933	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__hx
  05939	76 0f		 jbe	 SHORT $LN6@P_again
  0593b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  05941	83 c2 04	 add	 edx, 4
  05944	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hx, edx
$LN6@P_again:
  0594a	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  0594f	83 c0 04	 add	 eax, 4
  05952	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__ht
  05958	76 0a		 jbe	 SHORT $LN5@P_again
  0595a	e8 00 00 00 00	 call	 _atl__Eho
  0595f	e9 bf 00 00 00	 jmp	 $LN8@P_again
$LN5@P_again:
  05964	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  0596a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _s_branch
  05970	89 11		 mov	 DWORD PTR [ecx], edx
  05972	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  05977	83 c0 04	 add	 eax, 4
  0597a	a3 00 00 00 00	 mov	 DWORD PTR _atl__hp, eax

; 2077 :     Hpc(S0);

  0597f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  05985	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  05988	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  0598e	72 10		 jb	 SHORT $LN3@P_again
  05990	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  05995	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  05998	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  0599e	72 07		 jb	 SHORT $LN4@P_again
$LN3@P_again:
  059a0	e8 00 00 00 00	 call	 _atl__Ebp
  059a5	eb 7c		 jmp	 SHORT $LN8@P_again
$LN4@P_again:

; 2078 :     bp = (stackitem *) S0;	      /* Get BEGIN address */

  059a7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  059ad	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  059b0	89 45 fc	 mov	 DWORD PTR _bp$[ebp], eax

; 2079 :     off = -(hptr - bp);

  059b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  059b9	2b 4d fc	 sub	 ecx, DWORD PTR _bp$[ebp]
  059bc	c1 f9 02	 sar	 ecx, 2
  059bf	f7 d9		 neg	 ecx
  059c1	89 4d f8	 mov	 DWORD PTR _off$[ebp], ecx

; 2080 :     Compconst(off);		      /* Compile negative jumpback address */

  059c4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  059ca	83 c2 04	 add	 edx, 4
  059cd	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hx
  059d3	76 0d		 jbe	 SHORT $LN2@P_again
  059d5	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  059da	83 c0 04	 add	 eax, 4
  059dd	a3 00 00 00 00	 mov	 DWORD PTR _atl__hx, eax
$LN2@P_again:
  059e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  059e8	83 c1 04	 add	 ecx, 4
  059eb	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  059f1	76 07		 jbe	 SHORT $LN1@P_again
  059f3	e8 00 00 00 00	 call	 _atl__Eho
  059f8	eb 29		 jmp	 SHORT $LN8@P_again
$LN1@P_again:
  059fa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  05a00	8b 45 f8	 mov	 eax, DWORD PTR _off$[ebp]
  05a03	89 02		 mov	 DWORD PTR [edx], eax
  05a05	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  05a0b	83 c1 04	 add	 ecx, 4
  05a0e	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hp, ecx

; 2081 :     Pop;

  05a14	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  05a1a	83 ea 04	 sub	 edx, 4
  05a1d	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN8@P_again:

; 2082 : }

  05a23	8b e5		 mov	 esp, ebp
  05a25	5d		 pop	 ebp
  05a26	c3		 ret	 0
_P_again ENDP
; Function compile flags: /Odtp
_P_while PROC

; 2085 : {

  05a30	55		 push	 ebp
  05a31	8b ec		 mov	 ebp, esp

; 2086 :     Compiling;

  05a33	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hb
  05a38	83 38 00	 cmp	 DWORD PTR [eax], 0
  05a3b	75 0a		 jne	 SHORT $LN7@P_while
  05a3d	e8 00 00 00 00	 call	 _notcomp
  05a42	e9 00 01 00 00	 jmp	 $LN8@P_while
$LN7@P_while:

; 2087 :     So(1);

  05a47	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  05a4d	83 c1 04	 add	 ecx, 4
  05a50	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__sx
  05a56	76 0f		 jbe	 SHORT $LN6@P_while
  05a58	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  05a5e	83 c2 04	 add	 edx, 4
  05a61	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sx, edx
$LN6@P_while:
  05a67	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  05a6c	83 c0 04	 add	 eax, 4
  05a6f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__st
  05a75	76 0a		 jbe	 SHORT $LN5@P_while
  05a77	e8 00 00 00 00	 call	 _atl__Eso
  05a7c	e9 c6 00 00 00	 jmp	 $LN8@P_while
$LN5@P_while:

; 2088 :     Compconst(s_qbranch);	      /* Compile question branch */

  05a81	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  05a87	83 c1 04	 add	 ecx, 4
  05a8a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__hx
  05a90	76 0f		 jbe	 SHORT $LN4@P_while
  05a92	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  05a98	83 c2 04	 add	 edx, 4
  05a9b	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hx, edx
$LN4@P_while:
  05aa1	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  05aa6	83 c0 04	 add	 eax, 4
  05aa9	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__ht
  05aaf	76 0a		 jbe	 SHORT $LN3@P_while
  05ab1	e8 00 00 00 00	 call	 _atl__Eho
  05ab6	e9 8c 00 00 00	 jmp	 $LN8@P_while
$LN3@P_while:
  05abb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  05ac1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _s_qbranch
  05ac7	89 11		 mov	 DWORD PTR [ecx], edx
  05ac9	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  05ace	83 c0 04	 add	 eax, 4
  05ad1	a3 00 00 00 00	 mov	 DWORD PTR _atl__hp, eax

; 2089 :     Compconst(0);		      /* Compile place-holder address cell */

  05ad6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  05adc	83 c1 04	 add	 ecx, 4
  05adf	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__hx
  05ae5	76 0f		 jbe	 SHORT $LN2@P_while
  05ae7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  05aed	83 c2 04	 add	 edx, 4
  05af0	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hx, edx
$LN2@P_while:
  05af6	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  05afb	83 c0 04	 add	 eax, 4
  05afe	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__ht
  05b04	76 07		 jbe	 SHORT $LN1@P_while
  05b06	e8 00 00 00 00	 call	 _atl__Eho
  05b0b	eb 3a		 jmp	 SHORT $LN8@P_while
$LN1@P_while:
  05b0d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  05b13	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  05b19	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  05b1f	83 c2 04	 add	 edx, 4
  05b22	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hp, edx

; 2090 :     Push = (stackitem) (hptr - 1);    /* Queue backpatch for REPEAT */

  05b28	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  05b2d	83 e8 04	 sub	 eax, 4
  05b30	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  05b36	89 01		 mov	 DWORD PTR [ecx], eax
  05b38	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  05b3e	83 c2 04	 add	 edx, 4
  05b41	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN8@P_while:

; 2091 : }

  05b47	5d		 pop	 ebp
  05b48	c3		 ret	 0
_P_while ENDP
; Function compile flags: /Odtp
_bp1$ = -12						; size = 4
_off$ = -8						; size = 4
_bp$ = -4						; size = 4
_P_repeat PROC

; 2094 : {

  05b50	55		 push	 ebp
  05b51	8b ec		 mov	 ebp, esp
  05b53	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2095 :     stackitem off;
; 2096 :     stackitem *bp1, *bp;
; 2097 : 
; 2098 :     Compiling;

  05b56	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hb
  05b5b	83 38 00	 cmp	 DWORD PTR [eax], 0
  05b5e	75 0a		 jne	 SHORT $LN10@P_repeat
  05b60	e8 00 00 00 00	 call	 _notcomp
  05b65	e9 6e 01 00 00	 jmp	 $LN11@P_repeat
$LN10@P_repeat:

; 2099 :     Sl(2);

  05b6a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  05b70	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _atl__sk
  05b76	c1 f9 02	 sar	 ecx, 2
  05b79	83 f9 02	 cmp	 ecx, 2
  05b7c	7d 0a		 jge	 SHORT $LN9@P_repeat
  05b7e	e8 00 00 00 00	 call	 _atl__Esu
  05b83	e9 50 01 00 00	 jmp	 $LN11@P_repeat
$LN9@P_repeat:

; 2100 :     Hpc(S0);

  05b88	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  05b8e	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  05b91	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hs
  05b97	72 11		 jb	 SHORT $LN7@P_repeat
  05b99	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  05b9f	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  05ba2	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__ht
  05ba8	72 0a		 jb	 SHORT $LN8@P_repeat
$LN7@P_repeat:
  05baa	e8 00 00 00 00	 call	 _atl__Ebp
  05baf	e9 24 01 00 00	 jmp	 $LN11@P_repeat
$LN8@P_repeat:

; 2101 :     bp1 = (stackitem *) S0;	      /* Get WHILE backpatch address */

  05bb4	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  05bb9	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  05bbc	89 4d f4	 mov	 DWORD PTR _bp1$[ebp], ecx

; 2102 :     Pop;

  05bbf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  05bc5	83 ea 04	 sub	 edx, 4
  05bc8	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx

; 2103 :     Compconst(s_branch);	      /* Compile unconditional branch */

  05bce	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  05bd3	83 c0 04	 add	 eax, 4
  05bd6	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hx
  05bdc	76 0f		 jbe	 SHORT $LN6@P_repeat
  05bde	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  05be4	83 c1 04	 add	 ecx, 4
  05be7	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hx, ecx
$LN6@P_repeat:
  05bed	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  05bf3	83 c2 04	 add	 edx, 4
  05bf6	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__ht
  05bfc	76 0a		 jbe	 SHORT $LN5@P_repeat
  05bfe	e8 00 00 00 00	 call	 _atl__Eho
  05c03	e9 d0 00 00 00	 jmp	 $LN11@P_repeat
$LN5@P_repeat:
  05c08	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  05c0d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _s_branch
  05c13	89 08		 mov	 DWORD PTR [eax], ecx
  05c15	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  05c1b	83 c2 04	 add	 edx, 4
  05c1e	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hp, edx

; 2104 :     Hpc(S0);

  05c24	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  05c29	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  05c2c	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__hs
  05c32	72 11		 jb	 SHORT $LN3@P_repeat
  05c34	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  05c3a	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  05c3d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__ht
  05c43	72 0a		 jb	 SHORT $LN4@P_repeat
$LN3@P_repeat:
  05c45	e8 00 00 00 00	 call	 _atl__Ebp
  05c4a	e9 89 00 00 00	 jmp	 $LN11@P_repeat
$LN4@P_repeat:

; 2105 :     bp = (stackitem *) S0;	      /* Get BEGIN address */

  05c4f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  05c55	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  05c58	89 55 fc	 mov	 DWORD PTR _bp$[ebp], edx

; 2106 :     off = -(hptr - bp);

  05c5b	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  05c60	2b 45 fc	 sub	 eax, DWORD PTR _bp$[ebp]
  05c63	c1 f8 02	 sar	 eax, 2
  05c66	f7 d8		 neg	 eax
  05c68	89 45 f8	 mov	 DWORD PTR _off$[ebp], eax

; 2107 :     Compconst(off);		      /* Compile negative jumpback address */

  05c6b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  05c71	83 c1 04	 add	 ecx, 4
  05c74	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__hx
  05c7a	76 0f		 jbe	 SHORT $LN2@P_repeat
  05c7c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  05c82	83 c2 04	 add	 edx, 4
  05c85	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hx, edx
$LN2@P_repeat:
  05c8b	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  05c90	83 c0 04	 add	 eax, 4
  05c93	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__ht
  05c99	76 07		 jbe	 SHORT $LN1@P_repeat
  05c9b	e8 00 00 00 00	 call	 _atl__Eho
  05ca0	eb 36		 jmp	 SHORT $LN11@P_repeat
$LN1@P_repeat:
  05ca2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  05ca8	8b 55 f8	 mov	 edx, DWORD PTR _off$[ebp]
  05cab	89 11		 mov	 DWORD PTR [ecx], edx
  05cad	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  05cb2	83 c0 04	 add	 eax, 4
  05cb5	a3 00 00 00 00	 mov	 DWORD PTR _atl__hp, eax

; 2108 :     *bp1 = hptr - bp1;                /* Backpatch REPEAT's jump out of loop */

  05cba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  05cc0	2b 4d f4	 sub	 ecx, DWORD PTR _bp1$[ebp]
  05cc3	c1 f9 02	 sar	 ecx, 2
  05cc6	8b 55 f4	 mov	 edx, DWORD PTR _bp1$[ebp]
  05cc9	89 0a		 mov	 DWORD PTR [edx], ecx

; 2109 :     Pop;

  05ccb	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  05cd0	83 e8 04	 sub	 eax, 4
  05cd3	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN11@P_repeat:

; 2110 : }

  05cd8	8b e5		 mov	 esp, ebp
  05cda	5d		 pop	 ebp
  05cdb	c3		 ret	 0
_P_repeat ENDP
_TEXT	ENDS
_BSS	SEGMENT
_s_xdo	DD	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
_P_do	PROC

; 2113 : {

  05ce0	55		 push	 ebp
  05ce1	8b ec		 mov	 ebp, esp

; 2114 :     Compiling;

  05ce3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hb
  05ce8	83 38 00	 cmp	 DWORD PTR [eax], 0
  05ceb	75 0a		 jne	 SHORT $LN7@P_do
  05ced	e8 00 00 00 00	 call	 _notcomp
  05cf2	e9 fa 00 00 00	 jmp	 $LN8@P_do
$LN7@P_do:

; 2115 :     Compconst(s_xdo);		      /* Compile runtime DO word */

  05cf7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  05cfd	83 c1 04	 add	 ecx, 4
  05d00	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__hx
  05d06	76 0f		 jbe	 SHORT $LN6@P_do
  05d08	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  05d0e	83 c2 04	 add	 edx, 4
  05d11	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hx, edx
$LN6@P_do:
  05d17	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  05d1c	83 c0 04	 add	 eax, 4
  05d1f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__ht
  05d25	76 0a		 jbe	 SHORT $LN5@P_do
  05d27	e8 00 00 00 00	 call	 _atl__Eho
  05d2c	e9 c0 00 00 00	 jmp	 $LN8@P_do
$LN5@P_do:
  05d31	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  05d37	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _s_xdo
  05d3d	89 11		 mov	 DWORD PTR [ecx], edx
  05d3f	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  05d44	83 c0 04	 add	 eax, 4
  05d47	a3 00 00 00 00	 mov	 DWORD PTR _atl__hp, eax

; 2116 :     So(1);

  05d4c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  05d52	83 c1 04	 add	 ecx, 4
  05d55	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__sx
  05d5b	76 0f		 jbe	 SHORT $LN4@P_do
  05d5d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  05d63	83 c2 04	 add	 edx, 4
  05d66	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sx, edx
$LN4@P_do:
  05d6c	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  05d71	83 c0 04	 add	 eax, 4
  05d74	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__st
  05d7a	76 07		 jbe	 SHORT $LN3@P_do
  05d7c	e8 00 00 00 00	 call	 _atl__Eso
  05d81	eb 6e		 jmp	 SHORT $LN8@P_do
$LN3@P_do:

; 2117 :     Compconst(0);		      /* Reserve cell for LEAVE-taking */

  05d83	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  05d89	83 c1 04	 add	 ecx, 4
  05d8c	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__hx
  05d92	76 0f		 jbe	 SHORT $LN2@P_do
  05d94	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  05d9a	83 c2 04	 add	 edx, 4
  05d9d	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hx, edx
$LN2@P_do:
  05da3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  05da8	83 c0 04	 add	 eax, 4
  05dab	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__ht
  05db1	76 07		 jbe	 SHORT $LN1@P_do
  05db3	e8 00 00 00 00	 call	 _atl__Eho
  05db8	eb 37		 jmp	 SHORT $LN8@P_do
$LN1@P_do:
  05dba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  05dc0	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  05dc6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  05dcc	83 c2 04	 add	 edx, 4
  05dcf	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hp, edx

; 2118 :     Push = (stackitem) hptr;	      /* Save jump back address on stack */

  05dd5	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  05dda	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  05de0	89 08		 mov	 DWORD PTR [eax], ecx
  05de2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  05de8	83 c2 04	 add	 edx, 4
  05deb	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN8@P_do:

; 2119 : }

  05df1	5d		 pop	 ebp
  05df2	c3		 ret	 0
_P_do	ENDP
; Function compile flags: /Odtp
_P_xdo	PROC

; 2122 : {

  05e00	55		 push	 ebp
  05e01	8b ec		 mov	 ebp, esp

; 2123 :     Sl(2);

  05e03	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  05e08	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  05e0e	c1 f8 02	 sar	 eax, 2
  05e11	83 f8 02	 cmp	 eax, 2
  05e14	7d 0a		 jge	 SHORT $LN3@P_xdo
  05e16	e8 00 00 00 00	 call	 _atl__Esu
  05e1b	e9 b6 00 00 00	 jmp	 $LN4@P_xdo
$LN3@P_xdo:

; 2124 :     Rso(3);

  05e20	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__rp
  05e26	83 c1 0c	 add	 ecx, 12			; 0000000cH
  05e29	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__rx
  05e2f	76 0f		 jbe	 SHORT $LN2@P_xdo
  05e31	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__rp
  05e37	83 c2 0c	 add	 edx, 12			; 0000000cH
  05e3a	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__rx, edx
$LN2@P_xdo:
  05e40	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__rp
  05e45	83 c0 0c	 add	 eax, 12			; 0000000cH
  05e48	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__rt
  05e4e	76 07		 jbe	 SHORT $LN1@P_xdo
  05e50	e8 00 00 00 00	 call	 _atl__Erso
  05e55	eb 7f		 jmp	 SHORT $LN4@P_xdo
$LN1@P_xdo:

; 2125 :     Rpush = ip + ((stackitem) *ip);   /* Push exit address from loop */

  05e57	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__ip
  05e5d	8b 11		 mov	 edx, DWORD PTR [ecx]
  05e5f	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__ip
  05e64	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  05e67	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__rp
  05e6d	89 0a		 mov	 DWORD PTR [edx], ecx
  05e6f	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__rp
  05e74	83 c0 04	 add	 eax, 4
  05e77	a3 00 00 00 00	 mov	 DWORD PTR _atl__rp, eax

; 2126 :     ip++;			      /* Increment past exit address word */

  05e7c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__ip
  05e82	83 c1 04	 add	 ecx, 4
  05e85	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__ip, ecx

; 2127 :     Rpush = (rstackitem) S1;	      /* Push loop limit on return stack */

  05e8b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__rp
  05e91	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  05e96	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  05e99	89 0a		 mov	 DWORD PTR [edx], ecx
  05e9b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__rp
  05ea1	83 c2 04	 add	 edx, 4
  05ea4	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__rp, edx

; 2128 :     Rpush = (rstackitem) S0;	      /* Iteration variable initial value to

  05eaa	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__rp
  05eaf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  05eb5	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  05eb8	89 10		 mov	 DWORD PTR [eax], edx
  05eba	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__rp
  05ebf	83 c0 04	 add	 eax, 4
  05ec2	a3 00 00 00 00	 mov	 DWORD PTR _atl__rp, eax

; 2129 : 					 return stack */
; 2130 :     stk -= 2;

  05ec7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  05ecd	83 e9 08	 sub	 ecx, 8
  05ed0	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN4@P_xdo:

; 2131 : }

  05ed6	5d		 pop	 ebp
  05ed7	c3		 ret	 0
_P_xdo	ENDP
_TEXT	ENDS
_BSS	SEGMENT
_s_xqdo	DD	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
_P_qdo	PROC

; 2134 : {

  05ee0	55		 push	 ebp
  05ee1	8b ec		 mov	 ebp, esp

; 2135 :     Compiling;

  05ee3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hb
  05ee8	83 38 00	 cmp	 DWORD PTR [eax], 0
  05eeb	75 0a		 jne	 SHORT $LN7@P_qdo
  05eed	e8 00 00 00 00	 call	 _notcomp
  05ef2	e9 fa 00 00 00	 jmp	 $LN8@P_qdo
$LN7@P_qdo:

; 2136 :     Compconst(s_xqdo);		      /* Compile runtime ?DO word */

  05ef7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  05efd	83 c1 04	 add	 ecx, 4
  05f00	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__hx
  05f06	76 0f		 jbe	 SHORT $LN6@P_qdo
  05f08	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  05f0e	83 c2 04	 add	 edx, 4
  05f11	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hx, edx
$LN6@P_qdo:
  05f17	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  05f1c	83 c0 04	 add	 eax, 4
  05f1f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__ht
  05f25	76 0a		 jbe	 SHORT $LN5@P_qdo
  05f27	e8 00 00 00 00	 call	 _atl__Eho
  05f2c	e9 c0 00 00 00	 jmp	 $LN8@P_qdo
$LN5@P_qdo:
  05f31	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  05f37	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _s_xqdo
  05f3d	89 11		 mov	 DWORD PTR [ecx], edx
  05f3f	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  05f44	83 c0 04	 add	 eax, 4
  05f47	a3 00 00 00 00	 mov	 DWORD PTR _atl__hp, eax

; 2137 :     So(1);

  05f4c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  05f52	83 c1 04	 add	 ecx, 4
  05f55	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__sx
  05f5b	76 0f		 jbe	 SHORT $LN4@P_qdo
  05f5d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  05f63	83 c2 04	 add	 edx, 4
  05f66	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sx, edx
$LN4@P_qdo:
  05f6c	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  05f71	83 c0 04	 add	 eax, 4
  05f74	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__st
  05f7a	76 07		 jbe	 SHORT $LN3@P_qdo
  05f7c	e8 00 00 00 00	 call	 _atl__Eso
  05f81	eb 6e		 jmp	 SHORT $LN8@P_qdo
$LN3@P_qdo:

; 2138 :     Compconst(0);		      /* Reserve cell for LEAVE-taking */

  05f83	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  05f89	83 c1 04	 add	 ecx, 4
  05f8c	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__hx
  05f92	76 0f		 jbe	 SHORT $LN2@P_qdo
  05f94	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  05f9a	83 c2 04	 add	 edx, 4
  05f9d	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hx, edx
$LN2@P_qdo:
  05fa3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  05fa8	83 c0 04	 add	 eax, 4
  05fab	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__ht
  05fb1	76 07		 jbe	 SHORT $LN1@P_qdo
  05fb3	e8 00 00 00 00	 call	 _atl__Eho
  05fb8	eb 37		 jmp	 SHORT $LN8@P_qdo
$LN1@P_qdo:
  05fba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  05fc0	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  05fc6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  05fcc	83 c2 04	 add	 edx, 4
  05fcf	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hp, edx

; 2139 :     Push = (stackitem) hptr;	      /* Save jump back address on stack */

  05fd5	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  05fda	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  05fe0	89 08		 mov	 DWORD PTR [eax], ecx
  05fe2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  05fe8	83 c2 04	 add	 edx, 4
  05feb	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN8@P_qdo:

; 2140 : }

  05ff1	5d		 pop	 ebp
  05ff2	c3		 ret	 0
_P_qdo	ENDP
; Function compile flags: /Odtp
_P_xqdo PROC

; 2143 : {

  06000	55		 push	 ebp
  06001	8b ec		 mov	 ebp, esp

; 2144 :     Sl(2);

  06003	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  06008	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0600e	c1 f8 02	 sar	 eax, 2
  06011	83 f8 02	 cmp	 eax, 2
  06014	7d 0a		 jge	 SHORT $LN5@P_xqdo
  06016	e8 00 00 00 00	 call	 _atl__Esu
  0601b	e9 ea 00 00 00	 jmp	 $LN6@P_xqdo
$LN5@P_xqdo:

; 2145 :     if (S0 == S1) {

  06020	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  06026	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0602c	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  0602f	3b 42 f8	 cmp	 eax, DWORD PTR [edx-8]
  06032	75 1b		 jne	 SHORT $LN4@P_xqdo

; 2146 : 	ip += (stackitem) *ip;

  06034	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__ip
  0603a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0603c	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__ip
  06041	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  06044	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__ip, ecx

; 2147 :     } else {

  0604a	e9 ac 00 00 00	 jmp	 $LN3@P_xqdo
$LN4@P_xqdo:

; 2148 : 	Rso(3);

  0604f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__rp
  06055	83 c2 0c	 add	 edx, 12			; 0000000cH
  06058	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__rx
  0605e	76 0d		 jbe	 SHORT $LN2@P_xqdo
  06060	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__rp
  06065	83 c0 0c	 add	 eax, 12			; 0000000cH
  06068	a3 00 00 00 00	 mov	 DWORD PTR _atl__rx, eax
$LN2@P_xqdo:
  0606d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__rp
  06073	83 c1 0c	 add	 ecx, 12			; 0000000cH
  06076	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__rt
  0607c	76 0a		 jbe	 SHORT $LN1@P_xqdo
  0607e	e8 00 00 00 00	 call	 _atl__Erso
  06083	e9 82 00 00 00	 jmp	 $LN6@P_xqdo
$LN1@P_xqdo:

; 2149 : 	Rpush = ip + ((stackitem) *ip);/* Push exit address from loop */

  06088	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__ip
  0608e	8b 02		 mov	 eax, DWORD PTR [edx]
  06090	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__ip
  06096	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  06099	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__rp
  0609e	89 10		 mov	 DWORD PTR [eax], edx
  060a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__rp
  060a6	83 c1 04	 add	 ecx, 4
  060a9	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__rp, ecx

; 2150 : 	ip++;			      /* Increment past exit address word */

  060af	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__ip
  060b5	83 c2 04	 add	 edx, 4
  060b8	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__ip, edx

; 2151 : 	Rpush = (rstackitem) S1;      /* Push loop limit on return stack */

  060be	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__rp
  060c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  060c9	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  060cc	89 10		 mov	 DWORD PTR [eax], edx
  060ce	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__rp
  060d3	83 c0 04	 add	 eax, 4
  060d6	a3 00 00 00 00	 mov	 DWORD PTR _atl__rp, eax

; 2152 : 	Rpush = (rstackitem) S0;      /* Iteration variable initial value to

  060db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__rp
  060e1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  060e7	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  060ea	89 01		 mov	 DWORD PTR [ecx], eax
  060ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__rp
  060f2	83 c1 04	 add	 ecx, 4
  060f5	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__rp, ecx
$LN3@P_xqdo:

; 2153 : 					 return stack */
; 2154 :     }
; 2155 :     stk -= 2;

  060fb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  06101	83 ea 08	 sub	 edx, 8
  06104	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN6@P_xqdo:

; 2156 : }

  0610a	5d		 pop	 ebp
  0610b	c3		 ret	 0
_P_xqdo	ENDP
_TEXT	ENDS
_BSS	SEGMENT
_s_xloop DD	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
_off$ = -8						; size = 4
_bp$ = -4						; size = 4
_P_loop	PROC

; 2159 : {

  06110	55		 push	 ebp
  06111	8b ec		 mov	 ebp, esp
  06113	83 ec 08	 sub	 esp, 8

; 2160 :     stackitem off;
; 2161 :     stackitem *bp;
; 2162 : 
; 2163 :     Compiling;

  06116	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hb
  0611b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0611e	75 0a		 jne	 SHORT $LN8@P_loop
  06120	e8 00 00 00 00	 call	 _notcomp
  06125	e9 2e 01 00 00	 jmp	 $LN9@P_loop
$LN8@P_loop:

; 2164 :     Sl(1);

  0612a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  06130	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _atl__sk
  06136	c1 f9 02	 sar	 ecx, 2
  06139	83 f9 01	 cmp	 ecx, 1
  0613c	7d 0a		 jge	 SHORT $LN7@P_loop
  0613e	e8 00 00 00 00	 call	 _atl__Esu
  06143	e9 10 01 00 00	 jmp	 $LN9@P_loop
$LN7@P_loop:

; 2165 :     Compconst(s_xloop); 	      /* Compile runtime loop */

  06148	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  0614e	83 c2 04	 add	 edx, 4
  06151	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hx
  06157	76 0d		 jbe	 SHORT $LN6@P_loop
  06159	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  0615e	83 c0 04	 add	 eax, 4
  06161	a3 00 00 00 00	 mov	 DWORD PTR _atl__hx, eax
$LN6@P_loop:
  06166	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  0616c	83 c1 04	 add	 ecx, 4
  0616f	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  06175	76 0a		 jbe	 SHORT $LN5@P_loop
  06177	e8 00 00 00 00	 call	 _atl__Eho
  0617c	e9 d7 00 00 00	 jmp	 $LN9@P_loop
$LN5@P_loop:
  06181	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  06187	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_xloop
  0618c	89 02		 mov	 DWORD PTR [edx], eax
  0618e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  06194	83 c1 04	 add	 ecx, 4
  06197	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hp, ecx

; 2166 :     Hpc(S0);

  0619d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  061a3	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  061a6	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hs
  061ac	72 11		 jb	 SHORT $LN3@P_loop
  061ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  061b4	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  061b7	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__ht
  061bd	72 0a		 jb	 SHORT $LN4@P_loop
$LN3@P_loop:
  061bf	e8 00 00 00 00	 call	 _atl__Ebp
  061c4	e9 8f 00 00 00	 jmp	 $LN9@P_loop
$LN4@P_loop:

; 2167 :     bp = (stackitem *) S0;	      /* Get DO address */

  061c9	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  061ce	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  061d1	89 4d fc	 mov	 DWORD PTR _bp$[ebp], ecx

; 2168 :     off = -(hptr - bp);

  061d4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  061da	2b 55 fc	 sub	 edx, DWORD PTR _bp$[ebp]
  061dd	c1 fa 02	 sar	 edx, 2
  061e0	f7 da		 neg	 edx
  061e2	89 55 f8	 mov	 DWORD PTR _off$[ebp], edx

; 2169 :     Compconst(off);		      /* Compile negative jumpback address */

  061e5	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  061ea	83 c0 04	 add	 eax, 4
  061ed	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hx
  061f3	76 0f		 jbe	 SHORT $LN2@P_loop
  061f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  061fb	83 c1 04	 add	 ecx, 4
  061fe	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hx, ecx
$LN2@P_loop:
  06204	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  0620a	83 c2 04	 add	 edx, 4
  0620d	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__ht
  06213	76 07		 jbe	 SHORT $LN1@P_loop
  06215	e8 00 00 00 00	 call	 _atl__Eho
  0621a	eb 3c		 jmp	 SHORT $LN9@P_loop
$LN1@P_loop:
  0621c	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  06221	8b 4d f8	 mov	 ecx, DWORD PTR _off$[ebp]
  06224	89 08		 mov	 DWORD PTR [eax], ecx
  06226	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  0622c	83 c2 04	 add	 edx, 4
  0622f	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hp, edx

; 2170 :     *(bp - 1) = (hptr - bp) + 1;      /* Backpatch exit address offset */

  06235	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  0623a	2b 45 fc	 sub	 eax, DWORD PTR _bp$[ebp]
  0623d	c1 f8 02	 sar	 eax, 2
  06240	83 c0 01	 add	 eax, 1
  06243	8b 4d fc	 mov	 ecx, DWORD PTR _bp$[ebp]
  06246	89 41 fc	 mov	 DWORD PTR [ecx-4], eax

; 2171 :     Pop;

  06249	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0624f	83 ea 04	 sub	 edx, 4
  06252	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN9@P_loop:

; 2172 : }

  06258	8b e5		 mov	 esp, ebp
  0625a	5d		 pop	 ebp
  0625b	c3		 ret	 0
_P_loop	ENDP
_TEXT	ENDS
_BSS	SEGMENT
_s_pxloop DD	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
_off$ = -8						; size = 4
_bp$ = -4						; size = 4
_P_ploop PROC

; 2175 : {

  06260	55		 push	 ebp
  06261	8b ec		 mov	 ebp, esp
  06263	83 ec 08	 sub	 esp, 8

; 2176 :     stackitem off;
; 2177 :     stackitem *bp;
; 2178 : 
; 2179 :     Compiling;

  06266	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hb
  0626b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0626e	75 0a		 jne	 SHORT $LN8@P_ploop
  06270	e8 00 00 00 00	 call	 _notcomp
  06275	e9 2e 01 00 00	 jmp	 $LN9@P_ploop
$LN8@P_ploop:

; 2180 :     Sl(1);

  0627a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  06280	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _atl__sk
  06286	c1 f9 02	 sar	 ecx, 2
  06289	83 f9 01	 cmp	 ecx, 1
  0628c	7d 0a		 jge	 SHORT $LN7@P_ploop
  0628e	e8 00 00 00 00	 call	 _atl__Esu
  06293	e9 10 01 00 00	 jmp	 $LN9@P_ploop
$LN7@P_ploop:

; 2181 :     Compconst(s_pxloop);	      /* Compile runtime +loop */

  06298	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  0629e	83 c2 04	 add	 edx, 4
  062a1	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hx
  062a7	76 0d		 jbe	 SHORT $LN6@P_ploop
  062a9	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  062ae	83 c0 04	 add	 eax, 4
  062b1	a3 00 00 00 00	 mov	 DWORD PTR _atl__hx, eax
$LN6@P_ploop:
  062b6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  062bc	83 c1 04	 add	 ecx, 4
  062bf	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  062c5	76 0a		 jbe	 SHORT $LN5@P_ploop
  062c7	e8 00 00 00 00	 call	 _atl__Eho
  062cc	e9 d7 00 00 00	 jmp	 $LN9@P_ploop
$LN5@P_ploop:
  062d1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  062d7	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_pxloop
  062dc	89 02		 mov	 DWORD PTR [edx], eax
  062de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  062e4	83 c1 04	 add	 ecx, 4
  062e7	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hp, ecx

; 2182 :     Hpc(S0);

  062ed	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  062f3	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  062f6	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hs
  062fc	72 11		 jb	 SHORT $LN3@P_ploop
  062fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  06304	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  06307	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__ht
  0630d	72 0a		 jb	 SHORT $LN4@P_ploop
$LN3@P_ploop:
  0630f	e8 00 00 00 00	 call	 _atl__Ebp
  06314	e9 8f 00 00 00	 jmp	 $LN9@P_ploop
$LN4@P_ploop:

; 2183 :     bp = (stackitem *) S0;	      /* Get DO address */

  06319	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0631e	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  06321	89 4d fc	 mov	 DWORD PTR _bp$[ebp], ecx

; 2184 :     off = -(hptr - bp);

  06324	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  0632a	2b 55 fc	 sub	 edx, DWORD PTR _bp$[ebp]
  0632d	c1 fa 02	 sar	 edx, 2
  06330	f7 da		 neg	 edx
  06332	89 55 f8	 mov	 DWORD PTR _off$[ebp], edx

; 2185 :     Compconst(off);		      /* Compile negative jumpback address */

  06335	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  0633a	83 c0 04	 add	 eax, 4
  0633d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hx
  06343	76 0f		 jbe	 SHORT $LN2@P_ploop
  06345	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  0634b	83 c1 04	 add	 ecx, 4
  0634e	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hx, ecx
$LN2@P_ploop:
  06354	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  0635a	83 c2 04	 add	 edx, 4
  0635d	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__ht
  06363	76 07		 jbe	 SHORT $LN1@P_ploop
  06365	e8 00 00 00 00	 call	 _atl__Eho
  0636a	eb 3c		 jmp	 SHORT $LN9@P_ploop
$LN1@P_ploop:
  0636c	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  06371	8b 4d f8	 mov	 ecx, DWORD PTR _off$[ebp]
  06374	89 08		 mov	 DWORD PTR [eax], ecx
  06376	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  0637c	83 c2 04	 add	 edx, 4
  0637f	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hp, edx

; 2186 :     *(bp - 1) = (hptr - bp) + 1;      /* Backpatch exit address offset */

  06385	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  0638a	2b 45 fc	 sub	 eax, DWORD PTR _bp$[ebp]
  0638d	c1 f8 02	 sar	 eax, 2
  06390	83 c0 01	 add	 eax, 1
  06393	8b 4d fc	 mov	 ecx, DWORD PTR _bp$[ebp]
  06396	89 41 fc	 mov	 DWORD PTR [ecx-4], eax

; 2187 :     Pop;

  06399	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0639f	83 ea 04	 sub	 edx, 4
  063a2	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN9@P_ploop:

; 2188 : }

  063a8	8b e5		 mov	 esp, ebp
  063aa	5d		 pop	 ebp
  063ab	c3		 ret	 0
_P_ploop ENDP
; Function compile flags: /Odtp
_P_xloop PROC

; 2191 : {

  063b0	55		 push	 ebp
  063b1	8b ec		 mov	 ebp, esp

; 2192 :     Rsl(3);

  063b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__rp
  063b8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__rk
  063be	c1 f8 02	 sar	 eax, 2
  063c1	83 f8 03	 cmp	 eax, 3
  063c4	7d 07		 jge	 SHORT $LN3@P_xloop
  063c6	e8 00 00 00 00	 call	 _atl__Ersu
  063cb	eb 5d		 jmp	 SHORT $LN4@P_xloop
$LN3@P_xloop:

; 2193 :     R0 = (rstackitem) (((stackitem) R0) + 1);

  063cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__rp
  063d3	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  063d6	83 c2 01	 add	 edx, 1
  063d9	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__rp
  063de	89 50 fc	 mov	 DWORD PTR [eax-4], edx

; 2194 :     if (((stackitem) R0) == ((stackitem) R1)) {

  063e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__rp
  063e7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__rp
  063ed	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  063f0	3b 42 f8	 cmp	 eax, DWORD PTR [edx-8]
  063f3	75 20		 jne	 SHORT $LN2@P_xloop

; 2195 : 	rstk -= 3;		      /* Pop iteration variable and limit */

  063f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__rp
  063fb	83 e9 0c	 sub	 ecx, 12			; 0000000cH
  063fe	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__rp, ecx

; 2196 : 	ip++;			      /* Skip the jump address */

  06404	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__ip
  0640a	83 c2 04	 add	 edx, 4
  0640d	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__ip, edx

; 2197 :     } else {

  06413	eb 15		 jmp	 SHORT $LN4@P_xloop
$LN2@P_xloop:

; 2198 : 	ip += (stackitem) *ip;

  06415	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__ip
  0641a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0641c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__ip
  06422	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  06425	a3 00 00 00 00	 mov	 DWORD PTR _atl__ip, eax
$LN4@P_xloop:

; 2199 :     }
; 2200 : }

  0642a	5d		 pop	 ebp
  0642b	c3		 ret	 0
_P_xloop ENDP
; Function compile flags: /Odtp
_niter$ = -4						; size = 4
_P_xploop PROC

; 2203 : {

  06430	55		 push	 ebp
  06431	8b ec		 mov	 ebp, esp
  06433	51		 push	 ecx

; 2204 :     stackitem niter;
; 2205 : 
; 2206 :     Sl(1);

  06434	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  06439	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0643f	c1 f8 02	 sar	 eax, 2
  06442	83 f8 01	 cmp	 eax, 1
  06445	7d 0a		 jge	 SHORT $LN4@P_xploop
  06447	e8 00 00 00 00	 call	 _atl__Esu
  0644c	e9 a2 00 00 00	 jmp	 $LN5@P_xploop
$LN4@P_xploop:

; 2207 :     Rsl(3);

  06451	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__rp
  06457	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _atl__rk
  0645d	c1 f9 02	 sar	 ecx, 2
  06460	83 f9 03	 cmp	 ecx, 3
  06463	7d 0a		 jge	 SHORT $LN3@P_xploop
  06465	e8 00 00 00 00	 call	 _atl__Ersu
  0646a	e9 84 00 00 00	 jmp	 $LN5@P_xploop
$LN3@P_xploop:

; 2208 : 
; 2209 :     niter = ((stackitem) R0) + S0;

  0646f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__rp
  06475	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  06478	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0647e	03 41 fc	 add	 eax, DWORD PTR [ecx-4]
  06481	89 45 fc	 mov	 DWORD PTR _niter$[ebp], eax

; 2210 :     Pop;

  06484	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0648a	83 ea 04	 sub	 edx, 4
  0648d	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx

; 2211 :     if ((niter >= ((stackitem) R1)) &&
; 2212 : 	(((stackitem) R0) < ((stackitem) R1))) {

  06493	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__rp
  06498	8b 4d fc	 mov	 ecx, DWORD PTR _niter$[ebp]
  0649b	3b 48 f8	 cmp	 ecx, DWORD PTR [eax-8]
  0649e	7c 31		 jl	 SHORT $LN2@P_xploop
  064a0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__rp
  064a6	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__rp
  064ab	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  064ae	3b 48 f8	 cmp	 ecx, DWORD PTR [eax-8]
  064b1	7d 1e		 jge	 SHORT $LN2@P_xploop

; 2213 : 	rstk -= 3;		      /* Pop iteration variable and limit */

  064b3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__rp
  064b9	83 ea 0c	 sub	 edx, 12			; 0000000cH
  064bc	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__rp, edx

; 2214 : 	ip++;			      /* Skip the jump address */

  064c2	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__ip
  064c7	83 c0 04	 add	 eax, 4
  064ca	a3 00 00 00 00	 mov	 DWORD PTR _atl__ip, eax

; 2215 :     } else {

  064cf	eb 22		 jmp	 SHORT $LN5@P_xploop
$LN2@P_xploop:

; 2216 : 	ip += (stackitem) *ip;

  064d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__ip
  064d7	8b 11		 mov	 edx, DWORD PTR [ecx]
  064d9	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__ip
  064de	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  064e1	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__ip, ecx

; 2217 : 	R0 = (rstackitem) niter;

  064e7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__rp
  064ed	8b 45 fc	 mov	 eax, DWORD PTR _niter$[ebp]
  064f0	89 42 fc	 mov	 DWORD PTR [edx-4], eax
$LN5@P_xploop:

; 2218 :     }
; 2219 : }

  064f3	8b e5		 mov	 esp, ebp
  064f5	5d		 pop	 ebp
  064f6	c3		 ret	 0
_P_xploop ENDP
; Function compile flags: /Odtp
_P_leave PROC

; 2222 : {

  06500	55		 push	 ebp
  06501	8b ec		 mov	 ebp, esp

; 2223 :     Rsl(3);

  06503	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__rp
  06508	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__rk
  0650e	c1 f8 02	 sar	 eax, 2
  06511	83 f8 03	 cmp	 eax, 3
  06514	7d 07		 jge	 SHORT $LN1@P_leave
  06516	e8 00 00 00 00	 call	 _atl__Ersu
  0651b	eb 1c		 jmp	 SHORT $LN2@P_leave
$LN1@P_leave:

; 2224 :     ip = R2;

  0651d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__rp
  06523	8b 51 f4	 mov	 edx, DWORD PTR [ecx-12]
  06526	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__ip, edx

; 2225 :     rstk -= 3;

  0652c	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__rp
  06531	83 e8 0c	 sub	 eax, 12			; 0000000cH
  06534	a3 00 00 00 00	 mov	 DWORD PTR _atl__rp, eax
$LN2@P_leave:

; 2226 : }

  06539	5d		 pop	 ebp
  0653a	c3		 ret	 0
_P_leave ENDP
; Function compile flags: /Odtp
_P_i	PROC

; 2229 : {

  06540	55		 push	 ebp
  06541	8b ec		 mov	 ebp, esp

; 2230 :     Rsl(3);

  06543	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__rp
  06548	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__rk
  0654e	c1 f8 02	 sar	 eax, 2
  06551	83 f8 03	 cmp	 eax, 3
  06554	7d 07		 jge	 SHORT $LN3@P_i
  06556	e8 00 00 00 00	 call	 _atl__Ersu
  0655b	eb 57		 jmp	 SHORT $LN4@P_i
$LN3@P_i:

; 2231 :     So(1);

  0655d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  06563	83 c1 04	 add	 ecx, 4
  06566	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__sx
  0656c	76 0f		 jbe	 SHORT $LN2@P_i
  0656e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  06574	83 c2 04	 add	 edx, 4
  06577	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sx, edx
$LN2@P_i:
  0657d	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  06582	83 c0 04	 add	 eax, 4
  06585	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__st
  0658b	76 07		 jbe	 SHORT $LN1@P_i
  0658d	e8 00 00 00 00	 call	 _atl__Eso
  06592	eb 20		 jmp	 SHORT $LN4@P_i
$LN1@P_i:

; 2232 :     Push = (stackitem) R0;            /* It's the top item on return stack */

  06594	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0659a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__rp
  065a0	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  065a3	89 01		 mov	 DWORD PTR [ecx], eax
  065a5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  065ab	83 c1 04	 add	 ecx, 4
  065ae	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN4@P_i:

; 2233 : }

  065b4	5d		 pop	 ebp
  065b5	c3		 ret	 0
_P_i	ENDP
; Function compile flags: /Odtp
_P_j	PROC

; 2236 : {

  065c0	55		 push	 ebp
  065c1	8b ec		 mov	 ebp, esp

; 2237 :     Rsl(6);

  065c3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__rp
  065c8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__rk
  065ce	c1 f8 02	 sar	 eax, 2
  065d1	83 f8 06	 cmp	 eax, 6
  065d4	7d 07		 jge	 SHORT $LN3@P_j
  065d6	e8 00 00 00 00	 call	 _atl__Ersu
  065db	eb 57		 jmp	 SHORT $LN4@P_j
$LN3@P_j:

; 2238 :     So(1);

  065dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  065e3	83 c1 04	 add	 ecx, 4
  065e6	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__sx
  065ec	76 0f		 jbe	 SHORT $LN2@P_j
  065ee	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  065f4	83 c2 04	 add	 edx, 4
  065f7	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sx, edx
$LN2@P_j:
  065fd	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  06602	83 c0 04	 add	 eax, 4
  06605	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__st
  0660b	76 07		 jbe	 SHORT $LN1@P_j
  0660d	e8 00 00 00 00	 call	 _atl__Eso
  06612	eb 20		 jmp	 SHORT $LN4@P_j
$LN1@P_j:

; 2239 :     Push = (stackitem) rstk[-4];      /* It's the 4th item on return stack */

  06614	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0661a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__rp
  06620	8b 42 f0	 mov	 eax, DWORD PTR [edx-16]
  06623	89 01		 mov	 DWORD PTR [ecx], eax
  06625	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0662b	83 c1 04	 add	 ecx, 4
  0662e	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN4@P_j:

; 2240 : }

  06634	5d		 pop	 ebp
  06635	c3		 ret	 0
_P_j	ENDP
; Function compile flags: /Odtp
_P_quit PROC

; 2243 : {

  06640	55		 push	 ebp
  06641	8b ec		 mov	 ebp, esp

; 2244 :     rstk = rstack;		      /* Clear return stack */

  06643	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__rk
  06648	a3 00 00 00 00	 mov	 DWORD PTR _atl__rp, eax

; 2245 : #ifdef WALKBACK
; 2246 :     wbptr = wback;

  0664d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _wback
  06653	89 0d 00 00 00
	00		 mov	 DWORD PTR _wbptr, ecx

; 2247 : #endif
; 2248 :     ip = NULL;			      /* Stop execution of current word */

  06659	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _atl__ip, 0

; 2249 : }

  06663	5d		 pop	 ebp
  06664	c3		 ret	 0
_P_quit	ENDP
; Function compile flags: /Odtp
_P_abort PROC

; 2252 : {

  06670	55		 push	 ebp
  06671	8b ec		 mov	 ebp, esp

; 2253 :     P_clear();			      /* Clear the data stack */

  06673	e8 00 00 00 00	 call	 _P_clear

; 2254 :     P_quit();			      /* Shut down execution */

  06678	e8 00 00 00 00	 call	 _P_quit

; 2255 : }

  0667d	5d		 pop	 ebp
  0667e	c3		 ret	 0
_P_abort ENDP
_TEXT	ENDS
_BSS	SEGMENT
_s_abortq DD	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
_P_abortq PROC

; 2258 : {

  06680	55		 push	 ebp
  06681	8b ec		 mov	 ebp, esp

; 2259 :     if (state) {

  06683	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hb
  06688	83 38 00	 cmp	 DWORD PTR [eax], 0
  0668b	74 61		 je	 SHORT $LN4@P_abortq

; 2260 : 	stringlit = True;	      /* Set string literal expected */

  0668d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _stringlit, 1

; 2261 : 	Compconst(s_abortq);	      /* Compile ourselves */

  06697	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  0669d	83 c1 04	 add	 ecx, 4
  066a0	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__hx
  066a6	76 0f		 jbe	 SHORT $LN3@P_abortq
  066a8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  066ae	83 c2 04	 add	 edx, 4
  066b1	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hx, edx
$LN3@P_abortq:
  066b7	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  066bc	83 c0 04	 add	 eax, 4
  066bf	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__ht
  066c5	76 0a		 jbe	 SHORT $LN2@P_abortq
  066c7	e8 00 00 00 00	 call	 _atl__Eho
  066cc	e9 87 00 00 00	 jmp	 $LN5@P_abortq
$LN2@P_abortq:
  066d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  066d7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _s_abortq
  066dd	89 11		 mov	 DWORD PTR [ecx], edx
  066df	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  066e4	83 c0 04	 add	 eax, 4
  066e7	a3 00 00 00 00	 mov	 DWORD PTR _atl__hp, eax

; 2262 :     } else {

  066ec	eb 6a		 jmp	 SHORT $LN5@P_abortq
$LN4@P_abortq:

; 2263 :         V printf("%s", (char *) ip);  /* Otherwise, print string literal

  066ee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__ip
  066f4	51		 push	 ecx
  066f5	68 00 00 00 00	 push	 OFFSET $SG84562
  066fa	e8 00 00 00 00	 call	 _printf
  066ff	83 c4 08	 add	 esp, 8

; 2264 : 					 in in-line code. */
; 2265 : #ifdef WALKBACK
; 2266 : 	pwalkback();

  06702	e8 00 00 00 00	 call	 _pwalkback

; 2267 : #endif /* WALKBACK */
; 2268 : 	P_abort();		      /* Abort */

  06707	e8 00 00 00 00	 call	 _P_abort

; 2269 : 	atl_comment = state = Falsity;/* Reset all interpretation state */

  0670c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hb
  06712	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  06718	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _atl_comment, 0

; 2270 : 	forgetpend = defpend = stringlit =
; 2271 : 		     tickpend = ctickpend = False;

  06722	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ctickpend, 0
  0672c	a1 00 00 00 00	 mov	 eax, DWORD PTR _ctickpend
  06731	a3 00 00 00 00	 mov	 DWORD PTR _tickpend, eax
  06736	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tickpend
  0673c	89 0d 00 00 00
	00		 mov	 DWORD PTR _stringlit, ecx
  06742	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _stringlit
  06748	89 15 00 00 00
	00		 mov	 DWORD PTR _defpend, edx
  0674e	a1 00 00 00 00	 mov	 eax, DWORD PTR _defpend
  06753	a3 00 00 00 00	 mov	 DWORD PTR _forgetpend, eax
$LN5@P_abortq:

; 2272 :     }
; 2273 : }

  06758	5d		 pop	 ebp
  06759	c3		 ret	 0
_P_abortq ENDP
; Function compile flags: /Odtp
_P_immediate PROC

; 2278 : {

  06760	55		 push	 ebp
  06761	8b ec		 mov	 ebp, esp

; 2279 :     dict->wname[0] |= IMMEDIATE;

  06763	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__dh
  06768	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0676b	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0676e	83 ca 01	 or	 edx, 1
  06771	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__dh
  06776	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  06779	88 11		 mov	 BYTE PTR [ecx], dl

; 2280 : }

  0677b	5d		 pop	 ebp
  0677c	c3		 ret	 0
_P_immediate ENDP
; Function compile flags: /Odtp
_P_lbrack PROC

; 2283 : {

  06780	55		 push	 ebp
  06781	8b ec		 mov	 ebp, esp

; 2284 :     Compiling;

  06783	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hb
  06788	83 38 00	 cmp	 DWORD PTR [eax], 0
  0678b	75 07		 jne	 SHORT $LN1@P_lbrack
  0678d	e8 00 00 00 00	 call	 _notcomp
  06792	eb 0c		 jmp	 SHORT $LN2@P_lbrack
$LN1@P_lbrack:

; 2285 :     state = Falsity;

  06794	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hb
  0679a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$LN2@P_lbrack:

; 2286 : }

  067a0	5d		 pop	 ebp
  067a1	c3		 ret	 0
_P_lbrack ENDP
; Function compile flags: /Odtp
_P_rbrack PROC

; 2289 : {

  067b0	55		 push	 ebp
  067b1	8b ec		 mov	 ebp, esp

; 2290 :     state = Truth;

  067b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hb
  067b8	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1

; 2291 : }

  067be	5d		 pop	 ebp
  067bf	c3		 ret	 0
_P_rbrack ENDP
_TEXT	ENDS
PUBLIC	_atl__Pds
; Function compile flags: /Odtp
_TEXT	SEGMENT
_atl__Pds PROC

; 2294 : {

  067c0	55		 push	 ebp
  067c1	8b ec		 mov	 ebp, esp

; 2295 :     Rso(1);

  067c3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__rp
  067c8	83 c0 04	 add	 eax, 4
  067cb	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__rx
  067d1	76 0f		 jbe	 SHORT $LN4@atl__Pds
  067d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__rp
  067d9	83 c1 04	 add	 ecx, 4
  067dc	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__rx, ecx
$LN4@atl__Pds:
  067e2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__rp
  067e8	83 c2 04	 add	 edx, 4
  067eb	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__rt
  067f1	76 0a		 jbe	 SHORT $LN3@atl__Pds
  067f3	e8 00 00 00 00	 call	 _atl__Erso
  067f8	e9 9c 00 00 00	 jmp	 $LN5@atl__Pds
$LN3@atl__Pds:

; 2296 :     So(1);

  067fd	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  06802	83 c0 04	 add	 eax, 4
  06805	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__sx
  0680b	76 0f		 jbe	 SHORT $LN2@atl__Pds
  0680d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  06813	83 c1 04	 add	 ecx, 4
  06816	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sx, ecx
$LN2@atl__Pds:
  0681c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  06822	83 c2 04	 add	 edx, 4
  06825	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__st
  0682b	76 07		 jbe	 SHORT $LN1@atl__Pds
  0682d	e8 00 00 00 00	 call	 _atl__Eso
  06832	eb 65		 jmp	 SHORT $LN5@atl__Pds
$LN1@atl__Pds:

; 2297 :     Rpush = ip; 		      /* Push instruction pointer */

  06834	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__rp
  06839	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__ip
  0683f	89 08		 mov	 DWORD PTR [eax], ecx
  06841	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__rp
  06847	83 c2 04	 add	 edx, 4
  0684a	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__rp, edx

; 2298 : #ifdef WALKBACK
; 2299 :     *wbptr++ = curword; 	      /* Place word on walkback stack */

  06850	a1 00 00 00 00	 mov	 eax, DWORD PTR _wbptr
  06855	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__cw
  0685b	89 08		 mov	 DWORD PTR [eax], ecx
  0685d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _wbptr
  06863	83 c2 04	 add	 edx, 4
  06866	89 15 00 00 00
	00		 mov	 DWORD PTR _wbptr, edx

; 2300 : #endif
; 2301 :     /* The compiler having craftily squirreled away the DOES> clause
; 2302 :        address before the word definition on the heap, we back up to
; 2303 :        the heap cell before the current word and load the pointer from
; 2304 :        there.  This is an ABSOLUTE heap address, not a relative offset. */
; 2305 :     ip = *((dictword ***) (((stackitem *) curword) - 1));

  0686c	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__cw
  06871	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  06874	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__ip, ecx

; 2306 : 
; 2307 :     /* Push the address of this word's body as the argument to the
; 2308 :        DOES> clause. */
; 2309 :     Push = (stackitem) (((stackitem *) curword) + Dictwordl);

  0687a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__cw
  06880	83 c2 0c	 add	 edx, 12			; 0000000cH
  06883	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  06888	89 10		 mov	 DWORD PTR [eax], edx
  0688a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  06890	83 c1 04	 add	 ecx, 4
  06893	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx
$LN5@atl__Pds:

; 2310 : }

  06899	5d		 pop	 ebp
  0689a	c3		 ret	 0
_atl__Pds ENDP
; Function compile flags: /Odtp
tv83 = -12						; size = 4
_hp$84588 = -8						; size = 4
_sp$84586 = -4						; size = 4
_P_does	PROC

; 2313 : {

  068a0	55		 push	 ebp
  068a1	8b ec		 mov	 ebp, esp
  068a3	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2314 : 
; 2315 :     /* O.K., we were compiling our way through this definition and we've
; 2316 :        encountered the Dreaded and Dastardly Does.  Here's what we do
; 2317 :        about it.  The problem is that when we execute the word, we
; 2318 :        want to push its address on the stack and call the code for the
; 2319 :        DOES> clause by diverting the IP to that address.  But...how
; 2320 :        are we to know where the DOES> clause goes without adding a
; 2321 :        field to every word in the system just to remember it.  Recall
; 2322 :        that since this system is portable we can't cop-out through
; 2323 :        machine code.  Further, we can't compile something into the
; 2324 :        word because the defining code may have already allocated heap
; 2325 :        for the word's body.  Yukkkk.  Oh well, how about this?  Let's
; 2326 :        copy any and all heap allocated for the word down one stackitem
; 2327 :        and then jam the DOES> code address BEFORE the link field in
; 2328 :        the word we're defining.
; 2329 : 
; 2330 :        Then, when (DOES>) (P_dodoes) is called to execute the word, it
; 2331 :        will fetch that code address by backing up past the start of
; 2332 :        the word and seting IP to it.  Note that FORGET must recognise
; 2333 :        such words (by the presence of the pointer to P_dodoes() in
; 2334 :        their wcode field, in case you're wondering), and make sure to
; 2335 :        deallocate the heap word containing the link when a
; 2336 :        DOES>-defined word is deleted.  */
; 2337 : 
; 2338 :     if (createword != NULL) {

  068a6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _atl__wd, 0
  068ad	0f 84 0d 01 00
	00		 je	 $LN8@P_does

; 2339 : 	stackitem *sp = ((stackitem *) createword), *hp;

  068b3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__wd
  068b8	89 45 fc	 mov	 DWORD PTR _sp$84586[ebp], eax

; 2340 : 
; 2341 : 	Rsl(1);

  068bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__rp
  068c1	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _atl__rk
  068c7	c1 f9 02	 sar	 ecx, 2
  068ca	83 f9 01	 cmp	 ecx, 1
  068cd	7d 0a		 jge	 SHORT $LN6@P_does
  068cf	e8 00 00 00 00	 call	 _atl__Ersu
  068d4	e9 e7 00 00 00	 jmp	 $LN8@P_does
$LN6@P_does:

; 2342 : 	Ho(1);

  068d9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  068df	83 c2 04	 add	 edx, 4
  068e2	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hx
  068e8	76 0d		 jbe	 SHORT $LN5@P_does
  068ea	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  068ef	83 c0 04	 add	 eax, 4
  068f2	a3 00 00 00 00	 mov	 DWORD PTR _atl__hx, eax
$LN5@P_does:
  068f7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  068fd	83 c1 04	 add	 ecx, 4
  06900	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  06906	76 0a		 jbe	 SHORT $LN4@P_does
  06908	e8 00 00 00 00	 call	 _atl__Eho
  0690d	e9 ae 00 00 00	 jmp	 $LN8@P_does
$LN4@P_does:

; 2343 : 
; 2344 : 	/* Copy the word definition one word down in the heap to
; 2345 : 	   permit us to prefix it with the DOES clause address. */
; 2346 : 
; 2347 : 	for (hp = hptr - 1; hp >= sp; hp--)

  06912	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  06918	83 ea 04	 sub	 edx, 4
  0691b	89 55 f8	 mov	 DWORD PTR _hp$84588[ebp], edx
  0691e	eb 09		 jmp	 SHORT $LN3@P_does
$LN2@P_does:
  06920	8b 45 f8	 mov	 eax, DWORD PTR _hp$84588[ebp]
  06923	83 e8 04	 sub	 eax, 4
  06926	89 45 f8	 mov	 DWORD PTR _hp$84588[ebp], eax
$LN3@P_does:
  06929	8b 4d f8	 mov	 ecx, DWORD PTR _hp$84588[ebp]
  0692c	3b 4d fc	 cmp	 ecx, DWORD PTR _sp$84586[ebp]
  0692f	72 0d		 jb	 SHORT $LN1@P_does

; 2348 : 	    *(hp + 1) = *hp;

  06931	8b 55 f8	 mov	 edx, DWORD PTR _hp$84588[ebp]
  06934	8b 45 f8	 mov	 eax, DWORD PTR _hp$84588[ebp]
  06937	8b 08		 mov	 ecx, DWORD PTR [eax]
  06939	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0693c	eb e2		 jmp	 SHORT $LN2@P_does
$LN1@P_does:

; 2349 : 	hptr++; 		      /* Expand allocated length of word */

  0693e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  06944	83 c2 04	 add	 edx, 4
  06947	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hp, edx

; 2350 : 	*sp++ = (stackitem) ip;       /* Store DOES> clause address before

  0694d	8b 45 fc	 mov	 eax, DWORD PTR _sp$84586[ebp]
  06950	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__ip
  06956	89 08		 mov	 DWORD PTR [eax], ecx
  06958	8b 55 fc	 mov	 edx, DWORD PTR _sp$84586[ebp]
  0695b	83 c2 04	 add	 edx, 4
  0695e	89 55 fc	 mov	 DWORD PTR _sp$84586[ebp], edx

; 2351 :                                          word's definition structure. */
; 2352 : 	createword = (dictword *) sp; /* Move word definition down 1 item */

  06961	8b 45 fc	 mov	 eax, DWORD PTR _sp$84586[ebp]
  06964	a3 00 00 00 00	 mov	 DWORD PTR _atl__wd, eax

; 2353 : 	createword->wcode = P_dodoes; /* Set code field to indirect jump */

  06969	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__wd
  0696f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], OFFSET _atl__Pds

; 2354 : 
; 2355 : 	/* Now simulate an EXIT to bail out of the definition without
; 2356 : 	   executing the DOES> clause at definition time. */
; 2357 : 
; 2358 : 	ip = R0;		      /* Set IP to top of return stack */

  06976	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__rp
  0697c	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  0697f	a3 00 00 00 00	 mov	 DWORD PTR _atl__ip, eax

; 2359 : #ifdef WALKBACK
; 2360 : 	wbptr = (wbptr > wback) ? wbptr - 1 : wback;

  06984	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _wbptr
  0698a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _wback
  06990	76 0e		 jbe	 SHORT $LN10@P_does
  06992	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _wbptr
  06998	83 ea 04	 sub	 edx, 4
  0699b	89 55 f4	 mov	 DWORD PTR tv83[ebp], edx
  0699e	eb 08		 jmp	 SHORT $LN11@P_does
$LN10@P_does:
  069a0	a1 00 00 00 00	 mov	 eax, DWORD PTR _wback
  069a5	89 45 f4	 mov	 DWORD PTR tv83[ebp], eax
$LN11@P_does:
  069a8	8b 4d f4	 mov	 ecx, DWORD PTR tv83[ebp]
  069ab	89 0d 00 00 00
	00		 mov	 DWORD PTR _wbptr, ecx

; 2361 : #endif
; 2362 : 	Rpop;			      /* Pop the return stack */

  069b1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__rp
  069b7	83 ea 04	 sub	 edx, 4
  069ba	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__rp, edx
$LN8@P_does:

; 2363 :     }
; 2364 : }

  069c0	8b e5		 mov	 esp, ebp
  069c2	5d		 pop	 ebp
  069c3	c3		 ret	 0
_P_does	ENDP
; Function compile flags: /Odtp
_P_colon PROC

; 2367 : {

  069d0	55		 push	 ebp
  069d1	8b ec		 mov	 ebp, esp

; 2368 :     state = Truth;		      /* Set compilation underway */

  069d3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hb
  069d8	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1

; 2369 :     P_create(); 		      /* Create conventional word */

  069de	e8 00 00 00 00	 call	 _atl__Pcr

; 2370 : }

  069e3	5d		 pop	 ebp
  069e4	c3		 ret	 0
_P_colon ENDP
_TEXT	ENDS
_BSS	SEGMENT
_s_exit	DD	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
_P_semicolon PROC

; 2373 : {

  069f0	55		 push	 ebp
  069f1	8b ec		 mov	 ebp, esp

; 2374 :     Compiling;

  069f3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hb
  069f8	83 38 00	 cmp	 DWORD PTR [eax], 0
  069fb	75 07		 jne	 SHORT $LN4@P_semicolo
  069fd	e8 00 00 00 00	 call	 _notcomp
  06a02	eb 7e		 jmp	 SHORT $LN5@P_semicolo
$LN4@P_semicolo:

; 2375 :     Ho(1);

  06a04	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  06a0a	83 c1 04	 add	 ecx, 4
  06a0d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__hx
  06a13	76 0f		 jbe	 SHORT $LN3@P_semicolo
  06a15	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  06a1b	83 c2 04	 add	 edx, 4
  06a1e	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hx, edx
$LN3@P_semicolo:
  06a24	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  06a29	83 c0 04	 add	 eax, 4
  06a2c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__ht
  06a32	76 07		 jbe	 SHORT $LN2@P_semicolo
  06a34	e8 00 00 00 00	 call	 _atl__Eho
  06a39	eb 47		 jmp	 SHORT $LN5@P_semicolo
$LN2@P_semicolo:

; 2376 :     Hstore = s_exit;

  06a3b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  06a41	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _s_exit
  06a47	89 11		 mov	 DWORD PTR [ecx], edx
  06a49	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  06a4e	83 c0 04	 add	 eax, 4
  06a51	a3 00 00 00 00	 mov	 DWORD PTR _atl__hp, eax

; 2377 :     state = Falsity;		      /* No longer compiling */

  06a56	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hb
  06a5c	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 2378 :     /* We wait until now to plug the P_nest code so that it will be
; 2379 :        present only in completed definitions. */
; 2380 :     if (createword != NULL)

  06a62	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _atl__wd, 0
  06a69	74 0d		 je	 SHORT $LN1@P_semicolo

; 2381 : 	createword->wcode = P_nest;   /* Use P_nest for code */

  06a6b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__wd
  06a71	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], OFFSET _P_nest
$LN1@P_semicolo:

; 2382 :     createword = NULL;		      /* Flag no word being created */

  06a78	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _atl__wd, 0
$LN5@P_semicolo:

; 2383 : }

  06a82	5d		 pop	 ebp
  06a83	c3		 ret	 0
_P_semicolon ENDP
_TEXT	ENDS
_BSS	SEGMENT
_tokbuf	DB	080H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
_di$84612 = -8						; size = 4
_i$ = -4						; size = 4
_P_tick	PROC

; 2386 : {

  06a90	55		 push	 ebp
  06a91	8b ec		 mov	 ebp, esp
  06a93	83 ec 08	 sub	 esp, 8

; 2387 :     int i;
; 2388 : 
; 2389 :     /* Try to get next symbol from the input stream.  If
; 2390 :        we can't, and we're executing a compiled word,
; 2391 :        report an error.  Since we can't call back to the
; 2392 :        calling program for more input, we're stuck. */
; 2393 : 
; 2394 :     i = token(&instream);	      /* Scan for next token */

  06a96	68 00 00 00 00	 push	 OFFSET _instream
  06a9b	e8 00 00 00 00	 call	 _token
  06aa0	83 c4 04	 add	 esp, 4
  06aa3	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 2395 :     if (i != TokNull) {

  06aa6	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  06aaa	0f 84 a7 00 00
	00		 je	 $LN10@P_tick

; 2396 : 	if (i == TokWord) {

  06ab0	83 7d fc 01	 cmp	 DWORD PTR _i$[ebp], 1
  06ab4	0f 85 89 00 00
	00		 jne	 $LN9@P_tick

; 2397 : 	    dictword *di;
; 2398 : 
; 2399 : 	    ucase(tokbuf);

  06aba	68 00 00 00 00	 push	 OFFSET _tokbuf
  06abf	e8 00 00 00 00	 call	 _ucase
  06ac4	83 c4 04	 add	 esp, 4

; 2400 : 	    if ((di = lookup(tokbuf)) != NULL) {

  06ac7	68 00 00 00 00	 push	 OFFSET _tokbuf
  06acc	e8 00 00 00 00	 call	 _lookup
  06ad1	83 c4 04	 add	 esp, 4
  06ad4	89 45 f8	 mov	 DWORD PTR _di$84612[ebp], eax
  06ad7	83 7d f8 00	 cmp	 DWORD PTR _di$84612[ebp], 0
  06adb	74 52		 je	 SHORT $LN8@P_tick

; 2401 : 		So(1);

  06add	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  06ae2	83 c0 04	 add	 eax, 4
  06ae5	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__sx
  06aeb	76 0f		 jbe	 SHORT $LN7@P_tick
  06aed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  06af3	83 c1 04	 add	 ecx, 4
  06af6	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sx, ecx
$LN7@P_tick:
  06afc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  06b02	83 c2 04	 add	 edx, 4
  06b05	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__st
  06b0b	76 07		 jbe	 SHORT $LN6@P_tick
  06b0d	e8 00 00 00 00	 call	 _atl__Eso
  06b12	eb 6a		 jmp	 SHORT $LN11@P_tick
$LN6@P_tick:

; 2402 : 		Push = (stackitem) di; /* Push word compile address */

  06b14	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  06b19	8b 4d f8	 mov	 ecx, DWORD PTR _di$84612[ebp]
  06b1c	89 08		 mov	 DWORD PTR [eax], ecx
  06b1e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  06b24	83 c2 04	 add	 edx, 4
  06b27	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx

; 2403 : 	    } else {

  06b2d	eb 12		 jmp	 SHORT $LN5@P_tick
$LN8@P_tick:

; 2404 :                 V printf(" '%s' undefined ", tokbuf);

  06b2f	68 00 00 00 00	 push	 OFFSET _tokbuf
  06b34	68 00 00 00 00	 push	 OFFSET $SG84620
  06b39	e8 00 00 00 00	 call	 _printf
  06b3e	83 c4 08	 add	 esp, 8
$LN5@P_tick:

; 2405 : 	    }
; 2406 : 	} else {

  06b41	eb 12		 jmp	 SHORT $LN4@P_tick
$LN9@P_tick:

; 2407 :             V printf("\nWord not specified when expected.\n");

  06b43	68 00 00 00 00	 push	 OFFSET $SG84623
  06b48	e8 00 00 00 00	 call	 _printf
  06b4d	83 c4 04	 add	 esp, 4

; 2408 : 	    P_abort();

  06b50	e8 00 00 00 00	 call	 _P_abort
$LN4@P_tick:

; 2409 : 	}
; 2410 :     } else {

  06b55	eb 27		 jmp	 SHORT $LN11@P_tick
$LN10@P_tick:

; 2411 : 	/* O.K., there was nothing in the input stream.  Set the
; 2412 : 	   tickpend flag to cause the compilation address of the next
; 2413 :            token to be pushed when it's supplied on a subsequent input
; 2414 : 	   line. */
; 2415 : 	if (ip == NULL) {

  06b57	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _atl__ip, 0
  06b5e	75 0c		 jne	 SHORT $LN2@P_tick

; 2416 : 	    tickpend = True;	      /* Set tick pending */

  06b60	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _tickpend, 1

; 2417 : 	} else {

  06b6a	eb 12		 jmp	 SHORT $LN11@P_tick
$LN2@P_tick:

; 2418 :             V printf("\nWord requested by ` not on same input line.\n");

  06b6c	68 00 00 00 00	 push	 OFFSET $SG84629
  06b71	e8 00 00 00 00	 call	 _printf
  06b76	83 c4 04	 add	 esp, 4

; 2419 : 	    P_abort();

  06b79	e8 00 00 00 00	 call	 _P_abort
$LN11@P_tick:

; 2420 : 	}
; 2421 :     }
; 2422 : }

  06b7e	8b e5		 mov	 esp, ebp
  06b80	5d		 pop	 ebp
  06b81	c3		 ret	 0
_P_tick	ENDP
_TEXT	ENDS
EXTRN	_toupper:PROC
EXTRN	_islower:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_ch$ = -1						; size = 1
_c$ = 8							; size = 4
_ucase	PROC

; 271  : {

  06b90	55		 push	 ebp
  06b91	8b ec		 mov	 ebp, esp
  06b93	51		 push	 ecx
$LN3@ucase:

; 272  :     char ch;
; 273  : 
; 274  :     while ((ch = *c) != EOS) {

  06b94	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  06b97	8a 08		 mov	 cl, BYTE PTR [eax]
  06b99	88 4d ff	 mov	 BYTE PTR _ch$[ebp], cl
  06b9c	0f be 55 ff	 movsx	 edx, BYTE PTR _ch$[ebp]
  06ba0	85 d2		 test	 edx, edx
  06ba2	74 2e		 je	 SHORT $LN4@ucase

; 275  : 	if (islower(ch))

  06ba4	0f be 45 ff	 movsx	 eax, BYTE PTR _ch$[ebp]
  06ba8	50		 push	 eax
  06ba9	e8 00 00 00 00	 call	 _islower
  06bae	83 c4 04	 add	 esp, 4
  06bb1	85 c0		 test	 eax, eax
  06bb3	74 12		 je	 SHORT $LN1@ucase

; 276  : 	    *c = toupper(ch);

  06bb5	0f be 4d ff	 movsx	 ecx, BYTE PTR _ch$[ebp]
  06bb9	51		 push	 ecx
  06bba	e8 00 00 00 00	 call	 _toupper
  06bbf	83 c4 04	 add	 esp, 4
  06bc2	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  06bc5	88 02		 mov	 BYTE PTR [edx], al
$LN1@ucase:

; 277  : 	c++;

  06bc7	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  06bca	83 c0 01	 add	 eax, 1
  06bcd	89 45 08	 mov	 DWORD PTR _c$[ebp], eax

; 278  :     }

  06bd0	eb c2		 jmp	 SHORT $LN3@ucase
$LN4@ucase:

; 279  : }

  06bd2	8b e5		 mov	 esp, ebp
  06bd4	5d		 pop	 ebp
  06bd5	c3		 ret	 0
_ucase	ENDP
_TEXT	ENDS
EXTRN	_sscanf:PROC
EXTRN	_isxdigit:PROC
EXTRN	_isdigit:PROC
EXTRN	_isspace:PROC
_BSS	SEGMENT
_tokreal DQ	01H DUP (?)
_tokint	DD	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
tv95 = -36						; size = 4
_tc$82977 = -29						; size = 1
_tcp$82978 = -28					; size = 4
_c$82954 = -22						; size = 1
_c$82933 = -21						; size = 1
_tp$82917 = -20						; size = 4
_rstring$82920 = -16					; size = 4
_istring$82919 = -12					; size = 4
_tl$82918 = -8						; size = 4
_sp$ = -4						; size = 4
_cp$ = 8						; size = 4
_token	PROC

; 285  : {

  06be0	55		 push	 ebp
  06be1	8b ec		 mov	 ebp, esp
  06be3	83 ec 24	 sub	 esp, 36			; 00000024H

; 286  :     char *sp = *cp;

  06be6	8b 45 08	 mov	 eax, DWORD PTR _cp$[ebp]
  06be9	8b 08		 mov	 ecx, DWORD PTR [eax]
  06beb	89 4d fc	 mov	 DWORD PTR _sp$[ebp], ecx
$LN49@token:

; 287  : 
; 288  :     while (True) {

  06bee	ba 01 00 00 00	 mov	 edx, 1
  06bf3	85 d2		 test	 edx, edx
  06bf5	0f 84 de 03 00
	00		 je	 $LN50@token

; 289  : 	char *tp = tokbuf;

  06bfb	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _tp$82917[ebp], OFFSET _tokbuf

; 290  : 	int tl = 0;

  06c02	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _tl$82918[ebp], 0

; 291  : 	Boolean istring = False, rstring = False;

  06c09	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _istring$82919[ebp], 0
  06c10	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _rstring$82920[ebp], 0

; 292  : 
; 293  : 	if (atl_comment) {

  06c17	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _atl_comment, 0
  06c1e	74 42		 je	 SHORT $LN43@token
$LN46@token:

; 294  :             while (*sp != ')') {

  06c20	8b 45 fc	 mov	 eax, DWORD PTR _sp$[ebp]
  06c23	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  06c26	83 f9 29	 cmp	 ecx, 41			; 00000029H
  06c29	74 24		 je	 SHORT $LN45@token

; 295  : 		if (*sp == EOS) {

  06c2b	8b 55 fc	 mov	 edx, DWORD PTR _sp$[ebp]
  06c2e	0f be 02	 movsx	 eax, BYTE PTR [edx]
  06c31	85 c0		 test	 eax, eax
  06c33	75 0f		 jne	 SHORT $LN44@token

; 296  : 		    *cp = sp;

  06c35	8b 4d 08	 mov	 ecx, DWORD PTR _cp$[ebp]
  06c38	8b 55 fc	 mov	 edx, DWORD PTR _sp$[ebp]
  06c3b	89 11		 mov	 DWORD PTR [ecx], edx

; 297  : 		    return TokNull;

  06c3d	33 c0		 xor	 eax, eax
  06c3f	e9 95 03 00 00	 jmp	 $LN50@token
$LN44@token:

; 298  : 		}
; 299  : 		sp++;

  06c44	8b 45 fc	 mov	 eax, DWORD PTR _sp$[ebp]
  06c47	83 c0 01	 add	 eax, 1
  06c4a	89 45 fc	 mov	 DWORD PTR _sp$[ebp], eax

; 300  : 	    }

  06c4d	eb d1		 jmp	 SHORT $LN46@token
$LN45@token:

; 301  : 	    sp++;

  06c4f	8b 4d fc	 mov	 ecx, DWORD PTR _sp$[ebp]
  06c52	83 c1 01	 add	 ecx, 1
  06c55	89 4d fc	 mov	 DWORD PTR _sp$[ebp], ecx

; 302  : 	    atl_comment = Falsity;

  06c58	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _atl_comment, 0
$LN43@token:

; 303  : 	}
; 304  : 
; 305  : 	while (isspace(*sp))		  /* Skip leading blanks */

  06c62	8b 55 fc	 mov	 edx, DWORD PTR _sp$[ebp]
  06c65	0f be 02	 movsx	 eax, BYTE PTR [edx]
  06c68	50		 push	 eax
  06c69	e8 00 00 00 00	 call	 _isspace
  06c6e	83 c4 04	 add	 esp, 4
  06c71	85 c0		 test	 eax, eax
  06c73	74 0b		 je	 SHORT $LN42@token

; 306  : 	    sp++;

  06c75	8b 4d fc	 mov	 ecx, DWORD PTR _sp$[ebp]
  06c78	83 c1 01	 add	 ecx, 1
  06c7b	89 4d fc	 mov	 DWORD PTR _sp$[ebp], ecx
  06c7e	eb e2		 jmp	 SHORT $LN43@token
$LN42@token:

; 307  : 
; 308  :         if (*sp == '"') {                 /* Is this a string ? */

  06c80	8b 55 fc	 mov	 edx, DWORD PTR _sp$[ebp]
  06c83	0f be 02	 movsx	 eax, BYTE PTR [edx]
  06c86	83 f8 22	 cmp	 eax, 34			; 00000022H
  06c89	0f 85 11 01 00
	00		 jne	 $LN23@token

; 309  : 
; 310  : 	    /* Assemble string token. */
; 311  : 
; 312  : 	    sp++;

  06c8f	8b 4d fc	 mov	 ecx, DWORD PTR _sp$[ebp]
  06c92	83 c1 01	 add	 ecx, 1
  06c95	89 4d fc	 mov	 DWORD PTR _sp$[ebp], ecx
$LN40@token:

; 313  : 	    while (True) {

  06c98	ba 01 00 00 00	 mov	 edx, 1
  06c9d	85 d2		 test	 edx, edx
  06c9f	0f 84 f2 00 00
	00		 je	 $LN39@token

; 314  : 		char c = *sp++;

  06ca5	8b 45 fc	 mov	 eax, DWORD PTR _sp$[ebp]
  06ca8	8a 08		 mov	 cl, BYTE PTR [eax]
  06caa	88 4d eb	 mov	 BYTE PTR _c$82933[ebp], cl
  06cad	8b 55 fc	 mov	 edx, DWORD PTR _sp$[ebp]
  06cb0	83 c2 01	 add	 edx, 1
  06cb3	89 55 fc	 mov	 DWORD PTR _sp$[ebp], edx

; 315  : 
; 316  :                 if (c == '"') {

  06cb6	0f be 45 eb	 movsx	 eax, BYTE PTR _c$82933[ebp]
  06cba	83 f8 22	 cmp	 eax, 34			; 00000022H
  06cbd	75 1f		 jne	 SHORT $LN38@token

; 317  : 		    sp++;

  06cbf	8b 4d fc	 mov	 ecx, DWORD PTR _sp$[ebp]
  06cc2	83 c1 01	 add	 ecx, 1
  06cc5	89 4d fc	 mov	 DWORD PTR _sp$[ebp], ecx

; 318  : 		    *tp++ = EOS;

  06cc8	8b 55 ec	 mov	 edx, DWORD PTR _tp$82917[ebp]
  06ccb	c6 02 00	 mov	 BYTE PTR [edx], 0
  06cce	8b 45 ec	 mov	 eax, DWORD PTR _tp$82917[ebp]
  06cd1	83 c0 01	 add	 eax, 1
  06cd4	89 45 ec	 mov	 DWORD PTR _tp$82917[ebp], eax

; 319  : 		    break;

  06cd7	e9 bb 00 00 00	 jmp	 $LN39@token
  06cdc	eb 23		 jmp	 SHORT $LN37@token
$LN38@token:

; 320  : 		} else if (c == EOS) {

  06cde	0f be 4d eb	 movsx	 ecx, BYTE PTR _c$82933[ebp]
  06ce2	85 c9		 test	 ecx, ecx
  06ce4	75 1b		 jne	 SHORT $LN37@token

; 321  : 		    rstring = True;

  06ce6	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _rstring$82920[ebp], 1

; 322  : 		    *tp++ = EOS;

  06ced	8b 55 ec	 mov	 edx, DWORD PTR _tp$82917[ebp]
  06cf0	c6 02 00	 mov	 BYTE PTR [edx], 0
  06cf3	8b 45 ec	 mov	 eax, DWORD PTR _tp$82917[ebp]
  06cf6	83 c0 01	 add	 eax, 1
  06cf9	89 45 ec	 mov	 DWORD PTR _tp$82917[ebp], eax

; 323  : 		    break;

  06cfc	e9 96 00 00 00	 jmp	 $LN39@token
$LN37@token:

; 324  : 		}
; 325  :                 if (c == '\\') {

  06d01	0f be 4d eb	 movsx	 ecx, BYTE PTR _c$82933[ebp]
  06d05	83 f9 5c	 cmp	 ecx, 92			; 0000005cH
  06d08	75 5f		 jne	 SHORT $LN35@token

; 326  : 		    c = *sp++;

  06d0a	8b 55 fc	 mov	 edx, DWORD PTR _sp$[ebp]
  06d0d	8a 02		 mov	 al, BYTE PTR [edx]
  06d0f	88 45 eb	 mov	 BYTE PTR _c$82933[ebp], al
  06d12	8b 4d fc	 mov	 ecx, DWORD PTR _sp$[ebp]
  06d15	83 c1 01	 add	 ecx, 1
  06d18	89 4d fc	 mov	 DWORD PTR _sp$[ebp], ecx

; 327  : 		    if (c == EOS) {

  06d1b	0f be 55 eb	 movsx	 edx, BYTE PTR _c$82933[ebp]
  06d1f	85 d2		 test	 edx, edx
  06d21	75 09		 jne	 SHORT $LN34@token

; 328  : 			rstring = True;

  06d23	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _rstring$82920[ebp], 1

; 329  : 			break;

  06d2a	eb 6b		 jmp	 SHORT $LN39@token
$LN34@token:

; 330  : 		    }
; 331  : 		    switch (c) {

  06d2c	0f be 45 eb	 movsx	 eax, BYTE PTR _c$82933[ebp]
  06d30	89 45 dc	 mov	 DWORD PTR tv95[ebp], eax
  06d33	8b 4d dc	 mov	 ecx, DWORD PTR tv95[ebp]
  06d36	83 e9 62	 sub	 ecx, 98			; 00000062H
  06d39	89 4d dc	 mov	 DWORD PTR tv95[ebp], ecx
  06d3c	83 7d dc 12	 cmp	 DWORD PTR tv95[ebp], 18	; 00000012H
  06d40	77 27		 ja	 SHORT $LN35@token
  06d42	8b 55 dc	 mov	 edx, DWORD PTR tv95[ebp]
  06d45	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN52@token[edx]
  06d4c	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN53@token[eax*4]
$LN31@token:

; 332  :                         case 'b':
; 333  :                             c = '\b';

  06d53	c6 45 eb 08	 mov	 BYTE PTR _c$82933[ebp], 8

; 334  : 			    break;

  06d57	eb 10		 jmp	 SHORT $LN35@token
$LN30@token:

; 335  :                         case 'n':
; 336  :                             c = '\n';

  06d59	c6 45 eb 0a	 mov	 BYTE PTR _c$82933[ebp], 10 ; 0000000aH

; 337  : 			    break;

  06d5d	eb 0a		 jmp	 SHORT $LN35@token
$LN29@token:

; 338  :                         case 'r':
; 339  :                             c = '\r';

  06d5f	c6 45 eb 0d	 mov	 BYTE PTR _c$82933[ebp], 13 ; 0000000dH

; 340  : 			    break;

  06d63	eb 04		 jmp	 SHORT $LN35@token
$LN28@token:

; 341  :                         case 't':
; 342  :                             c = '\t';

  06d65	c6 45 eb 09	 mov	 BYTE PTR _c$82933[ebp], 9
$LN35@token:

; 343  : 			    break;
; 344  : 			default:
; 345  : 			    break;
; 346  : 		    }
; 347  : 		}
; 348  : 		if (tl < (sizeof tokbuf) - 1) {

  06d69	83 7d f8 7f	 cmp	 DWORD PTR _tl$82918[ebp], 127 ; 0000007fH
  06d6d	73 1c		 jae	 SHORT $LN26@token

; 349  : 		   *tp++ = c;

  06d6f	8b 4d ec	 mov	 ecx, DWORD PTR _tp$82917[ebp]
  06d72	8a 55 eb	 mov	 dl, BYTE PTR _c$82933[ebp]
  06d75	88 11		 mov	 BYTE PTR [ecx], dl
  06d77	8b 45 ec	 mov	 eax, DWORD PTR _tp$82917[ebp]
  06d7a	83 c0 01	 add	 eax, 1
  06d7d	89 45 ec	 mov	 DWORD PTR _tp$82917[ebp], eax

; 350  : 		   tl++;

  06d80	8b 4d f8	 mov	 ecx, DWORD PTR _tl$82918[ebp]
  06d83	83 c1 01	 add	 ecx, 1
  06d86	89 4d f8	 mov	 DWORD PTR _tl$82918[ebp], ecx

; 351  : 		} else {

  06d89	eb 07		 jmp	 SHORT $LN25@token
$LN26@token:

; 352  : 		    rstring = True;

  06d8b	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _rstring$82920[ebp], 1
$LN25@token:

; 353  : 		}
; 354  : 	    }

  06d92	e9 01 ff ff ff	 jmp	 $LN40@token
$LN39@token:

; 355  : 	    istring = True;

  06d97	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _istring$82919[ebp], 1

; 356  : 	} else {

  06d9e	eb 66		 jmp	 SHORT $LN24@token
$LN23@token:

; 357  : 
; 358  : 	    /* Scan the next raw token */
; 359  : 
; 360  : 	    while (True) {

  06da0	ba 01 00 00 00	 mov	 edx, 1
  06da5	85 d2		 test	 edx, edx
  06da7	74 5d		 je	 SHORT $LN24@token

; 361  : 		char c = *sp++;

  06da9	8b 45 fc	 mov	 eax, DWORD PTR _sp$[ebp]
  06dac	8a 08		 mov	 cl, BYTE PTR [eax]
  06dae	88 4d ea	 mov	 BYTE PTR _c$82954[ebp], cl
  06db1	8b 55 fc	 mov	 edx, DWORD PTR _sp$[ebp]
  06db4	83 c2 01	 add	 edx, 1
  06db7	89 55 fc	 mov	 DWORD PTR _sp$[ebp], edx

; 362  : 
; 363  : 		if (c == EOS || isspace(c)) {

  06dba	0f be 45 ea	 movsx	 eax, BYTE PTR _c$82954[ebp]
  06dbe	85 c0		 test	 eax, eax
  06dc0	74 11		 je	 SHORT $LN20@token
  06dc2	0f be 4d ea	 movsx	 ecx, BYTE PTR _c$82954[ebp]
  06dc6	51		 push	 ecx
  06dc7	e8 00 00 00 00	 call	 _isspace
  06dcc	83 c4 04	 add	 esp, 4
  06dcf	85 c0		 test	 eax, eax
  06dd1	74 11		 je	 SHORT $LN21@token
$LN20@token:

; 364  : 		    *tp++ = EOS;

  06dd3	8b 55 ec	 mov	 edx, DWORD PTR _tp$82917[ebp]
  06dd6	c6 02 00	 mov	 BYTE PTR [edx], 0
  06dd9	8b 45 ec	 mov	 eax, DWORD PTR _tp$82917[ebp]
  06ddc	83 c0 01	 add	 eax, 1
  06ddf	89 45 ec	 mov	 DWORD PTR _tp$82917[ebp], eax

; 365  : 		    break;

  06de2	eb 22		 jmp	 SHORT $LN24@token
$LN21@token:

; 366  : 		}
; 367  : 		if (tl < (sizeof tokbuf) - 1) {

  06de4	83 7d f8 7f	 cmp	 DWORD PTR _tl$82918[ebp], 127 ; 0000007fH
  06de8	73 1a		 jae	 SHORT $LN19@token

; 368  : 		    *tp++ = c;

  06dea	8b 4d ec	 mov	 ecx, DWORD PTR _tp$82917[ebp]
  06ded	8a 55 ea	 mov	 dl, BYTE PTR _c$82954[ebp]
  06df0	88 11		 mov	 BYTE PTR [ecx], dl
  06df2	8b 45 ec	 mov	 eax, DWORD PTR _tp$82917[ebp]
  06df5	83 c0 01	 add	 eax, 1
  06df8	89 45 ec	 mov	 DWORD PTR _tp$82917[ebp], eax

; 369  : 		    tl++;

  06dfb	8b 4d f8	 mov	 ecx, DWORD PTR _tl$82918[ebp]
  06dfe	83 c1 01	 add	 ecx, 1
  06e01	89 4d f8	 mov	 DWORD PTR _tl$82918[ebp], ecx
$LN19@token:

; 370  : 		}
; 371  : 	    }

  06e04	eb 9a		 jmp	 SHORT $LN23@token
$LN24@token:

; 372  : 	}
; 373  : 	*cp = --sp;			  /* Store end of scan pointer */

  06e06	8b 55 fc	 mov	 edx, DWORD PTR _sp$[ebp]
  06e09	83 ea 01	 sub	 edx, 1
  06e0c	89 55 fc	 mov	 DWORD PTR _sp$[ebp], edx
  06e0f	8b 45 08	 mov	 eax, DWORD PTR _cp$[ebp]
  06e12	8b 4d fc	 mov	 ecx, DWORD PTR _sp$[ebp]
  06e15	89 08		 mov	 DWORD PTR [eax], ecx

; 374  : 
; 375  : 	if (istring) {

  06e17	83 7d f4 00	 cmp	 DWORD PTR _istring$82919[ebp], 0
  06e1b	74 33		 je	 SHORT $LN18@token

; 376  : 	    if (rstring) {

  06e1d	83 7d f0 00	 cmp	 DWORD PTR _rstring$82920[ebp], 0
  06e21	74 23		 je	 SHORT $LN17@token

; 377  : #ifdef MEMMESSAGE
; 378  :                 V printf("\nRunaway string: %s\n", tokbuf);

  06e23	68 00 00 00 00	 push	 OFFSET _tokbuf
  06e28	68 00 00 00 00	 push	 OFFSET $SG82961
  06e2d	e8 00 00 00 00	 call	 _printf
  06e32	83 c4 08	 add	 esp, 8

; 379  : #endif
; 380  : 		evalstat = ATL_RUNSTRING;

  06e35	c7 05 00 00 00
	00 f6 ff ff ff	 mov	 DWORD PTR _evalstat, -10 ; fffffff6H

; 381  : 		return TokNull;

  06e3f	33 c0		 xor	 eax, eax
  06e41	e9 93 01 00 00	 jmp	 $LN50@token
$LN17@token:

; 382  : 	    }
; 383  : 	    return TokString;

  06e46	b8 04 00 00 00	 mov	 eax, 4
  06e4b	e9 89 01 00 00	 jmp	 $LN50@token
$LN18@token:

; 384  : 	}
; 385  : 
; 386  : 	if (tokbuf[0] == EOS)

  06e50	0f be 15 00 00
	00 00		 movsx	 edx, BYTE PTR _tokbuf
  06e57	85 d2		 test	 edx, edx
  06e59	75 07		 jne	 SHORT $LN16@token

; 387  : 	    return TokNull;

  06e5b	33 c0		 xor	 eax, eax
  06e5d	e9 77 01 00 00	 jmp	 $LN50@token
$LN16@token:

; 388  : 
; 389  : 	/* See if token is a comment to end of line character.	If so, discard
; 390  : 	   the rest of the line and return null for this token request. */
; 391  : 
; 392  :         if (strcmp(tokbuf, "\\") == 0) {

  06e62	68 00 00 00 00	 push	 OFFSET $SG82964
  06e67	68 00 00 00 00	 push	 OFFSET _tokbuf
  06e6c	e8 00 00 00 00	 call	 _strcmp
  06e71	83 c4 08	 add	 esp, 8
  06e74	85 c0		 test	 eax, eax
  06e76	75 24		 jne	 SHORT $LN15@token
$LN14@token:

; 393  : 	    while (*sp != EOS)

  06e78	8b 45 fc	 mov	 eax, DWORD PTR _sp$[ebp]
  06e7b	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  06e7e	85 c9		 test	 ecx, ecx
  06e80	74 0b		 je	 SHORT $LN13@token

; 394  : 		sp++;

  06e82	8b 55 fc	 mov	 edx, DWORD PTR _sp$[ebp]
  06e85	83 c2 01	 add	 edx, 1
  06e88	89 55 fc	 mov	 DWORD PTR _sp$[ebp], edx
  06e8b	eb eb		 jmp	 SHORT $LN14@token
$LN13@token:

; 395  : 	    *cp = sp;

  06e8d	8b 45 08	 mov	 eax, DWORD PTR _cp$[ebp]
  06e90	8b 4d fc	 mov	 ecx, DWORD PTR _sp$[ebp]
  06e93	89 08		 mov	 DWORD PTR [eax], ecx

; 396  : 	    return TokNull;

  06e95	33 c0		 xor	 eax, eax
  06e97	e9 3d 01 00 00	 jmp	 $LN50@token
$LN15@token:

; 397  : 	}
; 398  : 
; 399  : 	/* See if this token is a comment open delimiter.  If so, set to
; 400  : 	   ignore all characters until the matching comment close delimiter. */
; 401  : 
; 402  :         if (strcmp(tokbuf, "(") == 0) {

  06e9c	68 00 00 00 00	 push	 OFFSET $SG82969
  06ea1	68 00 00 00 00	 push	 OFFSET _tokbuf
  06ea6	e8 00 00 00 00	 call	 _strcmp
  06eab	83 c4 08	 add	 esp, 8
  06eae	85 c0		 test	 eax, eax
  06eb0	75 54		 jne	 SHORT $LN12@token
$LN11@token:

; 403  : 	    while (*sp != EOS) {

  06eb2	8b 55 fc	 mov	 edx, DWORD PTR _sp$[ebp]
  06eb5	0f be 02	 movsx	 eax, BYTE PTR [edx]
  06eb8	85 c0		 test	 eax, eax
  06eba	74 18		 je	 SHORT $LN10@token

; 404  :                 if (*sp == ')')

  06ebc	8b 4d fc	 mov	 ecx, DWORD PTR _sp$[ebp]
  06ebf	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  06ec2	83 fa 29	 cmp	 edx, 41			; 00000029H
  06ec5	75 02		 jne	 SHORT $LN9@token

; 405  : 		    break;

  06ec7	eb 0b		 jmp	 SHORT $LN10@token
$LN9@token:

; 406  : 		sp++;

  06ec9	8b 45 fc	 mov	 eax, DWORD PTR _sp$[ebp]
  06ecc	83 c0 01	 add	 eax, 1
  06ecf	89 45 fc	 mov	 DWORD PTR _sp$[ebp], eax

; 407  : 	    }

  06ed2	eb de		 jmp	 SHORT $LN11@token
$LN10@token:

; 408  :             if (*sp == ')') {

  06ed4	8b 4d fc	 mov	 ecx, DWORD PTR _sp$[ebp]
  06ed7	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  06eda	83 fa 29	 cmp	 edx, 41			; 00000029H
  06edd	75 0e		 jne	 SHORT $LN8@token

; 409  : 		sp++;

  06edf	8b 45 fc	 mov	 eax, DWORD PTR _sp$[ebp]
  06ee2	83 c0 01	 add	 eax, 1
  06ee5	89 45 fc	 mov	 DWORD PTR _sp$[ebp], eax

; 410  : 		continue;

  06ee8	e9 01 fd ff ff	 jmp	 $LN49@token
$LN8@token:

; 411  : 	    }
; 412  : 	    atl_comment = Truth;

  06eed	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _atl_comment, -1

; 413  : 	    *cp = sp;

  06ef7	8b 4d 08	 mov	 ecx, DWORD PTR _cp$[ebp]
  06efa	8b 55 fc	 mov	 edx, DWORD PTR _sp$[ebp]
  06efd	89 11		 mov	 DWORD PTR [ecx], edx

; 414  : 	    return TokNull;

  06eff	33 c0		 xor	 eax, eax
  06f01	e9 d3 00 00 00	 jmp	 $LN50@token
$LN12@token:

; 415  : 	}
; 416  : 
; 417  : 	/* See if the token is a number. */
; 418  : 
; 419  :         if (isdigit(tokbuf[0]) || tokbuf[0] == '-') {

  06f06	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR _tokbuf
  06f0d	50		 push	 eax
  06f0e	e8 00 00 00 00	 call	 _isdigit
  06f13	83 c4 04	 add	 esp, 4
  06f16	85 c0		 test	 eax, eax
  06f18	75 10		 jne	 SHORT $LN6@token
  06f1a	0f be 0d 00 00
	00 00		 movsx	 ecx, BYTE PTR _tokbuf
  06f21	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  06f24	0f 85 a3 00 00
	00		 jne	 $LN7@token
$LN6@token:

; 420  : 	    char tc;
; 421  : 	    char *tcp;
; 422  : 
; 423  : #ifdef OS2
; 424  : 	    /* Compensate for error in OS/2 sscanf() library function */
; 425  :             if ((tokbuf[0] == '-') &&
; 426  : 		!(isdigit(tokbuf[1]) ||
; 427  :                     (((tokbuf[1] == 'x') || (tokbuf[1] == 'X')) &&
; 428  : 			isxdigit(tokbuf[2])))) {

  06f2a	0f be 15 00 00
	00 00		 movsx	 edx, BYTE PTR _tokbuf
  06f31	83 fa 2d	 cmp	 edx, 45			; 0000002dH
  06f34	75 47		 jne	 SHORT $LN5@token
  06f36	0f be 05 01 00
	00 00		 movsx	 eax, BYTE PTR _tokbuf+1
  06f3d	50		 push	 eax
  06f3e	e8 00 00 00 00	 call	 _isdigit
  06f43	83 c4 04	 add	 esp, 4
  06f46	85 c0		 test	 eax, eax
  06f48	75 33		 jne	 SHORT $LN5@token
  06f4a	0f be 0d 01 00
	00 00		 movsx	 ecx, BYTE PTR _tokbuf+1
  06f51	83 f9 78	 cmp	 ecx, 120		; 00000078H
  06f54	74 0c		 je	 SHORT $LN3@token
  06f56	0f be 15 01 00
	00 00		 movsx	 edx, BYTE PTR _tokbuf+1
  06f5d	83 fa 58	 cmp	 edx, 88			; 00000058H
  06f60	75 14		 jne	 SHORT $LN4@token
$LN3@token:
  06f62	0f be 05 02 00
	00 00		 movsx	 eax, BYTE PTR _tokbuf+2
  06f69	50		 push	 eax
  06f6a	e8 00 00 00 00	 call	 _isxdigit
  06f6f	83 c4 04	 add	 esp, 4
  06f72	85 c0		 test	 eax, eax
  06f74	75 07		 jne	 SHORT $LN5@token
$LN4@token:

; 429  : 		return TokWord;

  06f76	b8 01 00 00 00	 mov	 eax, 1
  06f7b	eb 5c		 jmp	 SHORT $LN50@token
$LN5@token:

; 430  : 	    }
; 431  : #endif /* OS2 */
; 432  : #ifdef USE_SSCANF
; 433  :             if (sscanf(tokbuf, "%li%c", &tokint, &tc) == 1)
; 434  : 		return TokInt;
; 435  : #else
; 436  :     	    tokint = strtoul(tokbuf, &tcp, 0);

  06f7d	6a 00		 push	 0
  06f7f	8d 4d e4	 lea	 ecx, DWORD PTR _tcp$82978[ebp]
  06f82	51		 push	 ecx
  06f83	68 00 00 00 00	 push	 OFFSET _tokbuf
  06f88	e8 00 00 00 00	 call	 _strtoul
  06f8d	83 c4 0c	 add	 esp, 12			; 0000000cH
  06f90	a3 00 00 00 00	 mov	 DWORD PTR _tokint, eax

; 437  : 	    if (*tcp == 0) {

  06f95	8b 55 e4	 mov	 edx, DWORD PTR _tcp$82978[ebp]
  06f98	0f be 02	 movsx	 eax, BYTE PTR [edx]
  06f9b	85 c0		 test	 eax, eax
  06f9d	75 07		 jne	 SHORT $LN2@token

; 438  : 	    	return TokInt;

  06f9f	b8 02 00 00 00	 mov	 eax, 2
  06fa4	eb 33		 jmp	 SHORT $LN50@token
$LN2@token:

; 439  : 	    }
; 440  : #endif
; 441  : #ifdef REAL
; 442  :             if (sscanf(tokbuf, "%lf%c", &tokreal, &tc) == 1)

  06fa6	8d 4d e3	 lea	 ecx, DWORD PTR _tc$82977[ebp]
  06fa9	51		 push	 ecx
  06faa	68 00 00 00 00	 push	 OFFSET _tokreal
  06faf	68 00 00 00 00	 push	 OFFSET $SG82984
  06fb4	68 00 00 00 00	 push	 OFFSET _tokbuf
  06fb9	e8 00 00 00 00	 call	 _sscanf
  06fbe	83 c4 10	 add	 esp, 16			; 00000010H
  06fc1	83 f8 01	 cmp	 eax, 1
  06fc4	75 07		 jne	 SHORT $LN7@token

; 443  : 		return TokReal;

  06fc6	b8 03 00 00 00	 mov	 eax, 3
  06fcb	eb 0c		 jmp	 SHORT $LN50@token
$LN7@token:

; 444  : #endif
; 445  : 	}
; 446  : 	return TokWord;

  06fcd	b8 01 00 00 00	 mov	 eax, 1
  06fd2	eb 05		 jmp	 SHORT $LN50@token

; 447  :     }

  06fd4	e9 15 fc ff ff	 jmp	 $LN49@token
$LN50@token:

; 448  : }

  06fd9	8b e5		 mov	 esp, ebp
  06fdb	5d		 pop	 ebp
  06fdc	c3		 ret	 0
  06fdd	8d 49 00	 npad	 3
$LN53@token:
  06fe0	00 00 00 00	 DD	 $LN31@token
  06fe4	00 00 00 00	 DD	 $LN30@token
  06fe8	00 00 00 00	 DD	 $LN29@token
  06fec	00 00 00 00	 DD	 $LN28@token
  06ff0	00 00 00 00	 DD	 $LN35@token
$LN52@token:
  06ff4	00		 DB	 0
  06ff5	04		 DB	 4
  06ff6	04		 DB	 4
  06ff7	04		 DB	 4
  06ff8	04		 DB	 4
  06ff9	04		 DB	 4
  06ffa	04		 DB	 4
  06ffb	04		 DB	 4
  06ffc	04		 DB	 4
  06ffd	04		 DB	 4
  06ffe	04		 DB	 4
  06fff	04		 DB	 4
  07000	01		 DB	 1
  07001	04		 DB	 4
  07002	04		 DB	 4
  07003	04		 DB	 4
  07004	02		 DB	 2
  07005	04		 DB	 4
  07006	03		 DB	 3
_token	ENDP
; Function compile flags: /Odtp
_dw$ = -4						; size = 4
_tkname$ = 8						; size = 4
_lookup	PROC

; 454  : {

  07010	55		 push	 ebp
  07011	8b ec		 mov	 ebp, esp
  07013	51		 push	 ecx

; 455  :     dictword *dw = dict;

  07014	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__dh
  07019	89 45 fc	 mov	 DWORD PTR _dw$[ebp], eax

; 456  : 
; 457  :     ucase(tkname);		      /* Force name to upper case */

  0701c	8b 4d 08	 mov	 ecx, DWORD PTR _tkname$[ebp]
  0701f	51		 push	 ecx
  07020	e8 00 00 00 00	 call	 _ucase
  07025	83 c4 04	 add	 esp, 4
$LN3@lookup:

; 458  :     while (dw != NULL) {

  07028	83 7d fc 00	 cmp	 DWORD PTR _dw$[ebp], 0
  0702c	74 48		 je	 SHORT $LN2@lookup

; 459  : 	if (!(dw->wname[0] & WORDHIDDEN) &&
; 460  : 	     (strcmp(dw->wname + 1, tkname) == 0)) {

  0702e	8b 55 fc	 mov	 edx, DWORD PTR _dw$[ebp]
  07031	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  07034	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  07037	83 e1 04	 and	 ecx, 4
  0703a	75 30		 jne	 SHORT $LN1@lookup
  0703c	8b 55 08	 mov	 edx, DWORD PTR _tkname$[ebp]
  0703f	52		 push	 edx
  07040	8b 45 fc	 mov	 eax, DWORD PTR _dw$[ebp]
  07043	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  07046	83 c1 01	 add	 ecx, 1
  07049	51		 push	 ecx
  0704a	e8 00 00 00 00	 call	 _strcmp
  0704f	83 c4 08	 add	 esp, 8
  07052	85 c0		 test	 eax, eax
  07054	75 16		 jne	 SHORT $LN1@lookup

; 461  : #ifdef WORDSUSED
; 462  : 	    *(dw->wname) |= WORDUSED; /* Mark this word used */

  07056	8b 55 fc	 mov	 edx, DWORD PTR _dw$[ebp]
  07059	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0705c	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0705f	83 c9 02	 or	 ecx, 2
  07062	8b 55 fc	 mov	 edx, DWORD PTR _dw$[ebp]
  07065	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  07068	88 08		 mov	 BYTE PTR [eax], cl

; 463  : #endif
; 464  : 	    break;

  0706a	eb 0a		 jmp	 SHORT $LN2@lookup
$LN1@lookup:

; 465  : 	}
; 466  : 	dw = dw->wnext;

  0706c	8b 4d fc	 mov	 ecx, DWORD PTR _dw$[ebp]
  0706f	8b 11		 mov	 edx, DWORD PTR [ecx]
  07071	89 55 fc	 mov	 DWORD PTR _dw$[ebp], edx

; 467  :     }

  07074	eb b2		 jmp	 SHORT $LN3@lookup
$LN2@lookup:

; 468  :     return dw;

  07076	8b 45 fc	 mov	 eax, DWORD PTR _dw$[ebp]

; 469  : }

  07079	8b e5		 mov	 esp, ebp
  0707b	5d		 pop	 ebp
  0707c	c3		 ret	 0
_lookup	ENDP
; Function compile flags: /Odtp
_P_bracktick PROC

; 2425 : {

  07080	55		 push	 ebp
  07081	8b ec		 mov	 ebp, esp

; 2426 :     Compiling;

  07083	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hb
  07088	83 38 00	 cmp	 DWORD PTR [eax], 0
  0708b	75 07		 jne	 SHORT $LN1@P_bracktic
  0708d	e8 00 00 00 00	 call	 _notcomp
  07092	eb 0a		 jmp	 SHORT $LN2@P_bracktic
$LN1@P_bracktic:

; 2427 :     ctickpend = True;		      /* Force literal treatment of next

  07094	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _ctickpend, 1
$LN2@P_bracktic:

; 2428 : 					 word in compile stream */
; 2429 : }

  0709e	5d		 pop	 ebp
  0709f	c3		 ret	 0
_P_bracktick ENDP
; Function compile flags: /Odtp
_wp$ = -4						; size = 4
_P_execute PROC

; 2432 : {

  070a0	55		 push	 ebp
  070a1	8b ec		 mov	 ebp, esp
  070a3	51		 push	 ecx

; 2433 :     dictword *wp;
; 2434 : 
; 2435 :     Sl(1);

  070a4	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  070a9	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  070af	c1 f8 02	 sar	 eax, 2
  070b2	83 f8 01	 cmp	 eax, 1
  070b5	7d 07		 jge	 SHORT $LN1@P_execute
  070b7	e8 00 00 00 00	 call	 _atl__Esu
  070bc	eb 25		 jmp	 SHORT $LN2@P_execute
$LN1@P_execute:

; 2436 :     wp = (dictword *) S0;	      /* Load word address from stack */

  070be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  070c4	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  070c7	89 55 fc	 mov	 DWORD PTR _wp$[ebp], edx

; 2437 :     Pop;			      /* Pop data stack before execution */

  070ca	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  070cf	83 e8 04	 sub	 eax, 4
  070d2	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax

; 2438 :     exword(wp); 		      /* Recursively call exword() to run

  070d7	8b 4d fc	 mov	 ecx, DWORD PTR _wp$[ebp]
  070da	51		 push	 ecx
  070db	e8 00 00 00 00	 call	 _exword
  070e0	83 c4 04	 add	 esp, 4
$LN2@P_execute:

; 2439 : 					 the word. */
; 2440 : }

  070e3	8b e5		 mov	 esp, ebp
  070e5	5d		 pop	 ebp
  070e6	c3		 ret	 0
_P_execute ENDP
; Function compile flags: /Odtp
_P_body PROC

; 2443 : {

  070f0	55		 push	 ebp
  070f1	8b ec		 mov	 ebp, esp

; 2444 :     Sl(1);

  070f3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  070f8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  070fe	c1 f8 02	 sar	 eax, 2
  07101	83 f8 01	 cmp	 eax, 1
  07104	7d 07		 jge	 SHORT $LN1@P_body
  07106	e8 00 00 00 00	 call	 _atl__Esu
  0710b	eb 14		 jmp	 SHORT $LN2@P_body
$LN1@P_body:

; 2445 :     S0 += Dictwordl * sizeof(stackitem);

  0710d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  07113	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  07116	83 c2 0c	 add	 edx, 12			; 0000000cH
  07119	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0711e	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN2@P_body:

; 2446 : }

  07121	5d		 pop	 ebp
  07122	c3		 ret	 0
_P_body	ENDP
; Function compile flags: /Odtp
_P_state PROC

; 2449 : {

  07130	55		 push	 ebp
  07131	8b ec		 mov	 ebp, esp

; 2450 :     So(1);

  07133	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  07138	83 c0 04	 add	 eax, 4
  0713b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__sx
  07141	76 0f		 jbe	 SHORT $LN2@P_state
  07143	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  07149	83 c1 04	 add	 ecx, 4
  0714c	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sx, ecx
$LN2@P_state:
  07152	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  07158	83 c2 04	 add	 edx, 4
  0715b	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__st
  07161	76 07		 jbe	 SHORT $LN1@P_state
  07163	e8 00 00 00 00	 call	 _atl__Eso
  07168	eb 1c		 jmp	 SHORT $LN3@P_state
$LN1@P_state:

; 2451 :     Push = (stackitem) &state;

  0716a	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0716f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hb
  07175	89 08		 mov	 DWORD PTR [eax], ecx
  07177	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0717d	83 c2 04	 add	 edx, 4
  07180	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN3@P_state:

; 2452 : }

  07186	5d		 pop	 ebp
  07187	c3		 ret	 0
_P_state ENDP
; Function compile flags: /Odtp
_dw$ = -4						; size = 4
_P_find	PROC

; 2459 : {

  07190	55		 push	 ebp
  07191	8b ec		 mov	 ebp, esp
  07193	51		 push	 ecx

; 2460 :     dictword *dw;
; 2461 : 
; 2462 :     Sl(1);

  07194	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  07199	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0719f	c1 f8 02	 sar	 eax, 2
  071a2	83 f8 01	 cmp	 eax, 1
  071a5	7d 0a		 jge	 SHORT $LN7@P_find
  071a7	e8 00 00 00 00	 call	 _atl__Esu
  071ac	e9 e5 00 00 00	 jmp	 $LN8@P_find
$LN7@P_find:

; 2463 :     So(1);

  071b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  071b7	83 c1 04	 add	 ecx, 4
  071ba	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__sx
  071c0	76 0f		 jbe	 SHORT $LN6@P_find
  071c2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  071c8	83 c2 04	 add	 edx, 4
  071cb	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sx, edx
$LN6@P_find:
  071d1	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  071d6	83 c0 04	 add	 eax, 4
  071d9	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__st
  071df	76 0a		 jbe	 SHORT $LN5@P_find
  071e1	e8 00 00 00 00	 call	 _atl__Eso
  071e6	e9 ab 00 00 00	 jmp	 $LN8@P_find
$LN5@P_find:

; 2464 :     Hpc(S0);

  071eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  071f1	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  071f4	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  071fa	72 10		 jb	 SHORT $LN3@P_find
  071fc	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  07201	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  07204	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  0720a	72 0a		 jb	 SHORT $LN4@P_find
$LN3@P_find:
  0720c	e8 00 00 00 00	 call	 _atl__Ebp
  07211	e9 80 00 00 00	 jmp	 $LN8@P_find
$LN4@P_find:

; 2465 :     V strcpy(tokbuf, (char *) S0);    /* Use built-in token buffer... */

  07216	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0721c	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  0721f	50		 push	 eax
  07220	68 00 00 00 00	 push	 OFFSET _tokbuf
  07225	e8 00 00 00 00	 call	 _strcpy
  0722a	83 c4 08	 add	 esp, 8

; 2466 :     dw = lookup(tokbuf);              /* So ucase() in lookup() doesn't wipe */

  0722d	68 00 00 00 00	 push	 OFFSET _tokbuf
  07232	e8 00 00 00 00	 call	 _lookup
  07237	83 c4 04	 add	 esp, 4
  0723a	89 45 fc	 mov	 DWORD PTR _dw$[ebp], eax

; 2467 : 				      /* the token on the stack */
; 2468 :     if (dw != NULL) {

  0723d	83 7d fc 00	 cmp	 DWORD PTR _dw$[ebp], 0
  07241	74 3a		 je	 SHORT $LN2@P_find

; 2469 : 	S0 = (stackitem) dw;

  07243	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  07249	8b 55 fc	 mov	 edx, DWORD PTR _dw$[ebp]
  0724c	89 51 fc	 mov	 DWORD PTR [ecx-4], edx

; 2470 : 	/* Push immediate flag */
; 2471 : 	Push = (dw->wname[0] & IMMEDIATE) ? 1 : -1;

  0724f	8b 45 fc	 mov	 eax, DWORD PTR _dw$[ebp]
  07252	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  07255	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  07258	83 e2 01	 and	 edx, 1
  0725b	f7 da		 neg	 edx
  0725d	1b d2		 sbb	 edx, edx
  0725f	83 e2 02	 and	 edx, 2
  07262	83 c2 ff	 add	 edx, -1
  07265	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0726a	89 10		 mov	 DWORD PTR [eax], edx
  0726c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  07272	83 c1 04	 add	 ecx, 4
  07275	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx

; 2472 :     } else {

  0727b	eb 19		 jmp	 SHORT $LN8@P_find
$LN2@P_find:

; 2473 : 	Push = 0;

  0727d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  07283	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  07289	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0728e	83 c0 04	 add	 eax, 4
  07291	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN8@P_find:

; 2474 :     }
; 2475 : }

  07296	8b e5		 mov	 esp, ebp
  07298	5d		 pop	 ebp
  07299	c3		 ret	 0
_P_find	ENDP
; Function compile flags: /Odtp
_P_toname PROC

; 2480 : {

  072a0	55		 push	 ebp
  072a1	8b ec		 mov	 ebp, esp

; 2481 :     Sl(1);

  072a3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  072a8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  072ae	c1 f8 02	 sar	 eax, 2
  072b1	83 f8 01	 cmp	 eax, 1
  072b4	7d 07		 jge	 SHORT $LN1@P_toname
  072b6	e8 00 00 00 00	 call	 _atl__Esu
  072bb	eb 20		 jmp	 SHORT $LN2@P_toname
$LN1@P_toname:

; 2482 :     S0 += DfOff(wname);

  072bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__dh
  072c3	83 c1 04	 add	 ecx, 4
  072c6	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _atl__dh
  072cc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  072d2	03 4a fc	 add	 ecx, DWORD PTR [edx-4]
  072d5	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  072da	89 48 fc	 mov	 DWORD PTR [eax-4], ecx
$LN2@P_toname:

; 2483 : }

  072dd	5d		 pop	 ebp
  072de	c3		 ret	 0
_P_toname ENDP
; Function compile flags: /Odtp
_P_tolink PROC

; 2486 : {

  072e0	55		 push	 ebp
  072e1	8b ec		 mov	 ebp, esp

; 2487 : if (DfOff(wnext) != 0) V printf("\n>LINK Foulup--wnext is not at zero!\n");

  072e3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__dh
  072e8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__dh
  072ee	74 0d		 je	 SHORT $LN2@P_tolink
  072f0	68 00 00 00 00	 push	 OFFSET $SG84677
  072f5	e8 00 00 00 00	 call	 _printf
  072fa	83 c4 04	 add	 esp, 4
$LN2@P_tolink:

; 2488 : /*  Sl(1);
; 2489 :     S0 += DfOff(wnext);  */	      /* Null operation.  Wnext is first */
; 2490 : }

  072fd	5d		 pop	 ebp
  072fe	c3		 ret	 0
_P_tolink ENDP
; Function compile flags: /Odtp
_P_frombody PROC

; 2493 : {

  07300	55		 push	 ebp
  07301	8b ec		 mov	 ebp, esp

; 2494 :     Sl(1);

  07303	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  07308	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0730e	c1 f8 02	 sar	 eax, 2
  07311	83 f8 01	 cmp	 eax, 1
  07314	7d 07		 jge	 SHORT $LN1@P_frombody
  07316	e8 00 00 00 00	 call	 _atl__Esu
  0731b	eb 14		 jmp	 SHORT $LN2@P_frombody
$LN1@P_frombody:

; 2495 :     S0 -= Dictwordl * sizeof(stackitem);

  0731d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  07323	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  07326	83 ea 0c	 sub	 edx, 12			; 0000000cH
  07329	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0732e	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN2@P_frombody:

; 2496 : }

  07331	5d		 pop	 ebp
  07332	c3		 ret	 0
_P_frombody ENDP
; Function compile flags: /Odtp
_P_fromname PROC

; 2499 : {

  07340	55		 push	 ebp
  07341	8b ec		 mov	 ebp, esp

; 2500 :     Sl(1);

  07343	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  07348	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0734e	c1 f8 02	 sar	 eax, 2
  07351	83 f8 01	 cmp	 eax, 1
  07354	7d 07		 jge	 SHORT $LN1@P_fromname
  07356	e8 00 00 00 00	 call	 _atl__Esu
  0735b	eb 23		 jmp	 SHORT $LN2@P_fromname
$LN1@P_fromname:

; 2501 :     S0 -= DfOff(wname);

  0735d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__dh
  07363	83 c1 04	 add	 ecx, 4
  07366	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _atl__dh
  0736c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  07372	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  07375	2b c1		 sub	 eax, ecx
  07377	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0737d	89 41 fc	 mov	 DWORD PTR [ecx-4], eax
$LN2@P_fromname:

; 2502 : }

  07380	5d		 pop	 ebp
  07381	c3		 ret	 0
_P_fromname ENDP
; Function compile flags: /Odtp
_P_fromlink PROC

; 2505 : {

  07390	55		 push	 ebp
  07391	8b ec		 mov	 ebp, esp

; 2506 : if (DfOff(wnext) != 0) V printf("\nLINK> Foulup--wnext is not at zero!\n");

  07393	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__dh
  07398	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__dh
  0739e	74 0d		 je	 SHORT $LN2@P_fromlink
  073a0	68 00 00 00 00	 push	 OFFSET $SG84696
  073a5	e8 00 00 00 00	 call	 _printf
  073aa	83 c4 04	 add	 esp, 4
$LN2@P_fromlink:

; 2507 : /*  Sl(1);
; 2508 :     S0 -= DfOff(wnext);  */	      /* Null operation.  Wnext is first */
; 2509 : }

  073ad	5d		 pop	 ebp
  073ae	c3		 ret	 0
_P_fromlink ENDP
; Function compile flags: /Odtp
_from$ = -8						; size = 4
_to$ = -4						; size = 4
_P_nametolink PROC

; 2516 : {

  073b0	55		 push	 ebp
  073b1	8b ec		 mov	 ebp, esp
  073b3	83 ec 08	 sub	 esp, 8

; 2517 :     char *from, *to;
; 2518 : 
; 2519 :     Sl(1);

  073b6	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  073bb	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  073c1	c1 f8 02	 sar	 eax, 2
  073c4	83 f8 01	 cmp	 eax, 1
  073c7	7d 07		 jge	 SHORT $LN1@P_nametoli
  073c9	e8 00 00 00 00	 call	 _atl__Esu
  073ce	eb 2e		 jmp	 SHORT $LN2@P_nametoli
$LN1@P_nametoli:

; 2520 :     /*
; 2521 :     S0 -= DfTran(wnext, wname);
; 2522 :     */
; 2523 :     from = (char *) &(dict->wnext);

  073d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__dh
  073d6	89 4d f8	 mov	 DWORD PTR _from$[ebp], ecx

; 2524 :     to = (char *) &(dict->wname);

  073d9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__dh
  073df	83 c2 04	 add	 edx, 4
  073e2	89 55 fc	 mov	 DWORD PTR _to$[ebp], edx

; 2525 :     S0 -= (to - from);

  073e5	8b 45 fc	 mov	 eax, DWORD PTR _to$[ebp]
  073e8	2b 45 f8	 sub	 eax, DWORD PTR _from$[ebp]
  073eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  073f1	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  073f4	2b d0		 sub	 edx, eax
  073f6	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  073fb	89 50 fc	 mov	 DWORD PTR [eax-4], edx
$LN2@P_nametoli:

; 2526 : }

  073fe	8b e5		 mov	 esp, ebp
  07400	5d		 pop	 ebp
  07401	c3		 ret	 0
_P_nametolink ENDP
; Function compile flags: /Odtp
_from$ = -8						; size = 4
_to$ = -4						; size = 4
_P_linktoname PROC

; 2529 : {

  07410	55		 push	 ebp
  07411	8b ec		 mov	 ebp, esp
  07413	83 ec 08	 sub	 esp, 8

; 2530 :     char *from, *to;
; 2531 : 
; 2532 :     Sl(1);

  07416	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0741b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  07421	c1 f8 02	 sar	 eax, 2
  07424	83 f8 01	 cmp	 eax, 1
  07427	7d 07		 jge	 SHORT $LN1@P_linktona
  07429	e8 00 00 00 00	 call	 _atl__Esu
  0742e	eb 2d		 jmp	 SHORT $LN2@P_linktona
$LN1@P_linktona:

; 2533 :     /*
; 2534 :     S0 += DfTran(wnext, wname);
; 2535 :     */
; 2536 :     from = (char *) &(dict->wnext);

  07430	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__dh
  07436	89 4d f8	 mov	 DWORD PTR _from$[ebp], ecx

; 2537 :     to = (char *) &(dict->wname);

  07439	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__dh
  0743f	83 c2 04	 add	 edx, 4
  07442	89 55 fc	 mov	 DWORD PTR _to$[ebp], edx

; 2538 :     S0 += (to - from);

  07445	8b 45 fc	 mov	 eax, DWORD PTR _to$[ebp]
  07448	2b 45 f8	 sub	 eax, DWORD PTR _from$[ebp]
  0744b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  07451	03 41 fc	 add	 eax, DWORD PTR [ecx-4]
  07454	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0745a	89 42 fc	 mov	 DWORD PTR [edx-4], eax
$LN2@P_linktona:

; 2539 : }

  0745d	8b e5		 mov	 esp, ebp
  0745f	5d		 pop	 ebp
  07460	c3		 ret	 0
_P_linktoname ENDP
; Function compile flags: /Odtp
_P_fetchname PROC

; 2542 : {

  07470	55		 push	 ebp
  07471	8b ec		 mov	 ebp, esp

; 2543 :     Sl(2);			      /* nfa string -- */

  07473	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  07478	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0747e	c1 f8 02	 sar	 eax, 2
  07481	83 f8 02	 cmp	 eax, 2
  07484	7d 07		 jge	 SHORT $LN5@P_fetchnam
  07486	e8 00 00 00 00	 call	 _atl__Esu
  0748b	eb 7f		 jmp	 SHORT $LN6@P_fetchnam
$LN5@P_fetchnam:

; 2544 :     Hpc(S0);

  0748d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  07493	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  07496	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  0749c	72 10		 jb	 SHORT $LN3@P_fetchnam
  0749e	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  074a3	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  074a6	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  074ac	72 07		 jb	 SHORT $LN4@P_fetchnam
$LN3@P_fetchnam:
  074ae	e8 00 00 00 00	 call	 _atl__Ebp
  074b3	eb 57		 jmp	 SHORT $LN6@P_fetchnam
$LN4@P_fetchnam:

; 2545 :     Hpc(S1);

  074b5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  074bb	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  074be	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hs
  074c4	72 11		 jb	 SHORT $LN1@P_fetchnam
  074c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  074cc	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  074cf	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__ht
  074d5	72 07		 jb	 SHORT $LN2@P_fetchnam
$LN1@P_fetchnam:
  074d7	e8 00 00 00 00	 call	 _atl__Ebp
  074dc	eb 2e		 jmp	 SHORT $LN6@P_fetchnam
$LN2@P_fetchnam:

; 2546 :     /* Since the name buffers aren't in the system heap, but
; 2547 :        rather are separately allocated with alloc(), we can't
; 2548 :        check the name pointer references.  But, hey, if the user's
; 2549 :        futzing with word dictionary items on the heap in the first
; 2550 :        place, there's a billion other ways to bring us down at
; 2551 :        his command. */
; 2552 :     V strcpy((char *) S0, *((char **) S1) + 1);

  074de	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  074e3	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  074e6	8b 11		 mov	 edx, DWORD PTR [ecx]
  074e8	83 c2 01	 add	 edx, 1
  074eb	52		 push	 edx
  074ec	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  074f1	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  074f4	51		 push	 ecx
  074f5	e8 00 00 00 00	 call	 _strcpy
  074fa	83 c4 08	 add	 esp, 8

; 2553 :     Pop2;

  074fd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  07503	83 ea 08	 sub	 edx, 8
  07506	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN6@P_fetchnam:

; 2554 : }

  0750c	5d		 pop	 ebp
  0750d	c3		 ret	 0
_P_fetchname ENDP
_TEXT	ENDS
EXTRN	_free:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_tflags$ = -5						; size = 1
_cp$ = -4						; size = 4
_P_storename PROC

; 2557 : {

  07510	55		 push	 ebp
  07511	8b ec		 mov	 ebp, esp
  07513	83 ec 08	 sub	 esp, 8

; 2558 :     char tflags;
; 2559 :     char *cp;
; 2560 : 
; 2561 :     Sl(2);			      /* string nfa -- */

  07516	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0751b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  07521	c1 f8 02	 sar	 eax, 2
  07524	83 f8 02	 cmp	 eax, 2
  07527	7d 0a		 jge	 SHORT $LN5@P_storenam
  07529	e8 00 00 00 00	 call	 _atl__Esu
  0752e	e9 d7 00 00 00	 jmp	 $LN6@P_storenam
$LN5@P_storenam:

; 2562 :     Hpc(S0);			      /* See comments in P_fetchname above */

  07533	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  07539	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  0753c	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  07542	72 10		 jb	 SHORT $LN3@P_storenam
  07544	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  07549	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0754c	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  07552	72 0a		 jb	 SHORT $LN4@P_storenam
$LN3@P_storenam:
  07554	e8 00 00 00 00	 call	 _atl__Ebp
  07559	e9 ac 00 00 00	 jmp	 $LN6@P_storenam
$LN4@P_storenam:

; 2563 :     Hpc(S1);			      /* checking name pointers */

  0755e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  07564	8b 42 f8	 mov	 eax, DWORD PTR [edx-8]
  07567	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hs
  0756d	72 11		 jb	 SHORT $LN1@P_storenam
  0756f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  07575	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  07578	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__ht
  0757e	72 0a		 jb	 SHORT $LN2@P_storenam
$LN1@P_storenam:
  07580	e8 00 00 00 00	 call	 _atl__Ebp
  07585	e9 80 00 00 00	 jmp	 $LN6@P_storenam
$LN2@P_storenam:

; 2564 :     tflags = **((char **) S0);

  0758a	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  0758f	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  07592	8b 11		 mov	 edx, DWORD PTR [ecx]
  07594	8a 02		 mov	 al, BYTE PTR [edx]
  07596	88 45 fb	 mov	 BYTE PTR _tflags$[ebp], al

; 2565 :     free(*((char **) S0));

  07599	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0759f	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  075a2	8b 02		 mov	 eax, DWORD PTR [edx]
  075a4	50		 push	 eax
  075a5	e8 00 00 00 00	 call	 _free
  075aa	83 c4 04	 add	 esp, 4

; 2566 :     *((char **) S0) = cp = alloc((unsigned int) (strlen((char *) S1) + 2));

  075ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  075b3	8b 51 f8	 mov	 edx, DWORD PTR [ecx-8]
  075b6	52		 push	 edx
  075b7	e8 00 00 00 00	 call	 _strlen
  075bc	83 c4 04	 add	 esp, 4
  075bf	83 c0 02	 add	 eax, 2
  075c2	50		 push	 eax
  075c3	e8 00 00 00 00	 call	 _alloc
  075c8	83 c4 04	 add	 esp, 4
  075cb	89 45 fc	 mov	 DWORD PTR _cp$[ebp], eax
  075ce	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  075d3	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  075d6	8b 55 fc	 mov	 edx, DWORD PTR _cp$[ebp]
  075d9	89 11		 mov	 DWORD PTR [ecx], edx

; 2567 :     V strcpy(cp + 1, (char *) S1);

  075db	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  075e0	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  075e3	51		 push	 ecx
  075e4	8b 55 fc	 mov	 edx, DWORD PTR _cp$[ebp]
  075e7	83 c2 01	 add	 edx, 1
  075ea	52		 push	 edx
  075eb	e8 00 00 00 00	 call	 _strcpy
  075f0	83 c4 08	 add	 esp, 8

; 2568 :     *cp = tflags;

  075f3	8b 45 fc	 mov	 eax, DWORD PTR _cp$[ebp]
  075f6	8a 4d fb	 mov	 cl, BYTE PTR _tflags$[ebp]
  075f9	88 08		 mov	 BYTE PTR [eax], cl

; 2569 :     Pop2;

  075fb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  07601	83 ea 08	 sub	 edx, 8
  07604	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN6@P_storenam:

; 2570 : }

  0760a	8b e5		 mov	 esp, ebp
  0760c	5d		 pop	 ebp
  0760d	c3		 ret	 0
_P_storename ENDP
_TEXT	ENDS
EXTRN	_abort:PROC
EXTRN	_malloc:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_cp$ = -4						; size = 4
_size$ = 8						; size = 4
_alloc	PROC

; 256  : {

  07610	55		 push	 ebp
  07611	8b ec		 mov	 ebp, esp
  07613	51		 push	 ecx

; 257  :     char *cp = malloc(size);

  07614	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  07617	50		 push	 eax
  07618	e8 00 00 00 00	 call	 _malloc
  0761d	83 c4 04	 add	 esp, 4
  07620	89 45 fc	 mov	 DWORD PTR _cp$[ebp], eax

; 258  : 
; 259  : /* printf("\nAlloc %u", size); */
; 260  :     if (cp == NULL) {

  07623	83 7d fc 00	 cmp	 DWORD PTR _cp$[ebp], 0
  07627	75 1f		 jne	 SHORT $LN1@alloc

; 261  :         V fprintf(stderr, "\n\nOut of memory!  %u bytes requested.\n", size);

  07629	8b 4d 08	 mov	 ecx, DWORD PTR _size$[ebp]
  0762c	51		 push	 ecx
  0762d	68 00 00 00 00	 push	 OFFSET $SG82899
  07632	e8 00 00 00 00	 call	 ___iob_func
  07637	83 c0 40	 add	 eax, 64			; 00000040H
  0763a	50		 push	 eax
  0763b	e8 00 00 00 00	 call	 _fprintf
  07640	83 c4 0c	 add	 esp, 12			; 0000000cH

; 262  : 	abort();

  07643	e8 00 00 00 00	 call	 _abort
$LN1@alloc:

; 263  :     }
; 264  :     return cp;

  07648	8b 45 fc	 mov	 eax, DWORD PTR _cp$[ebp]

; 265  : }

  0764b	8b e5		 mov	 esp, ebp
  0764d	5d		 pop	 ebp
  0764e	c3		 ret	 0
_alloc	ENDP
_TEXT	ENDS
EXTRN	_system:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_P_system PROC

; 2576 : {				      /* string -- status */

  07650	55		 push	 ebp
  07651	8b ec		 mov	 ebp, esp

; 2577 :     Sl(1);

  07653	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  07658	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0765e	c1 f8 02	 sar	 eax, 2
  07661	83 f8 01	 cmp	 eax, 1
  07664	7d 07		 jge	 SHORT $LN3@P_system
  07666	e8 00 00 00 00	 call	 _atl__Esu
  0766b	eb 43		 jmp	 SHORT $LN4@P_system
$LN3@P_system:

; 2578 :     Hpc(S0);

  0766d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  07673	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  07676	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hs
  0767c	72 10		 jb	 SHORT $LN1@P_system
  0767e	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  07683	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  07686	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  0768c	72 07		 jb	 SHORT $LN2@P_system
$LN1@P_system:
  0768e	e8 00 00 00 00	 call	 _atl__Ebp
  07693	eb 1b		 jmp	 SHORT $LN4@P_system
$LN2@P_system:

; 2579 :     S0 = system((char *) S0);

  07695	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0769b	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  0769e	50		 push	 eax
  0769f	e8 00 00 00 00	 call	 _system
  076a4	83 c4 04	 add	 esp, 4
  076a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  076ad	89 41 fc	 mov	 DWORD PTR [ecx-4], eax
$LN4@P_system:

; 2580 : }

  076b0	5d		 pop	 ebp
  076b1	c3		 ret	 0
_P_system ENDP
; Function compile flags: /Odtp
_P_trace PROC

; 2585 : {

  076c0	55		 push	 ebp
  076c1	8b ec		 mov	 ebp, esp

; 2586 :     Sl(1);

  076c3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  076c8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  076ce	c1 f8 02	 sar	 eax, 2
  076d1	83 f8 01	 cmp	 eax, 1
  076d4	7d 07		 jge	 SHORT $LN1@P_trace
  076d6	e8 00 00 00 00	 call	 _atl__Esu
  076db	eb 20		 jmp	 SHORT $LN2@P_trace
$LN1@P_trace:

; 2587 :     atl_trace = (S0 == 0) ? Falsity : Truth;

  076dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  076e3	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  076e6	f7 da		 neg	 edx
  076e8	1b d2		 sbb	 edx, edx
  076ea	89 15 00 00 00
	00		 mov	 DWORD PTR _atl_trace, edx

; 2588 :     Pop;

  076f0	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  076f5	83 e8 04	 sub	 eax, 4
  076f8	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN2@P_trace:

; 2589 : }

  076fd	5d		 pop	 ebp
  076fe	c3		 ret	 0
_P_trace ENDP
; Function compile flags: /Odtp
_P_walkback PROC

; 2594 : {

  07700	55		 push	 ebp
  07701	8b ec		 mov	 ebp, esp

; 2595 :     Sl(1);

  07703	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  07708	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _atl__sk
  0770e	c1 f8 02	 sar	 eax, 2
  07711	83 f8 01	 cmp	 eax, 1
  07714	7d 07		 jge	 SHORT $LN1@P_walkback
  07716	e8 00 00 00 00	 call	 _atl__Esu
  0771b	eb 20		 jmp	 SHORT $LN2@P_walkback
$LN1@P_walkback:

; 2596 :     atl_walkback = (S0 == 0) ? Falsity : Truth;

  0771d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  07723	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  07726	f7 da		 neg	 edx
  07728	1b d2		 sbb	 edx, edx
  0772a	89 15 00 00 00
	00		 mov	 DWORD PTR _atl_walkback, edx

; 2597 :     Pop;

  07730	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  07735	83 e8 04	 sub	 eax, 4
  07738	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN2@P_walkback:

; 2598 : }

  0773d	5d		 pop	 ebp
  0773e	c3		 ret	 0
_P_walkback ENDP
; Function compile flags: /Odtp
_dw$ = -4						; size = 4
_P_wordsused PROC

; 2604 : {

  07740	55		 push	 ebp
  07741	8b ec		 mov	 ebp, esp
  07743	51		 push	 ecx

; 2605 :     dictword *dw = dict;

  07744	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__dh
  07749	89 45 fc	 mov	 DWORD PTR _dw$[ebp], eax
$LN3@P_wordsuse:

; 2606 : 
; 2607 :     while (dw != NULL) {

  0774c	83 7d fc 00	 cmp	 DWORD PTR _dw$[ebp], 0
  07750	74 2f		 je	 SHORT $LN2@P_wordsuse

; 2608 : 	if (*(dw->wname) & WORDUSED) {

  07752	8b 4d fc	 mov	 ecx, DWORD PTR _dw$[ebp]
  07755	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  07758	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0775b	83 e0 02	 and	 eax, 2
  0775e	74 17		 je	 SHORT $LN1@P_wordsuse

; 2609 :            V printf("\n%s", dw->wname + 1);

  07760	8b 4d fc	 mov	 ecx, DWORD PTR _dw$[ebp]
  07763	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  07766	83 c2 01	 add	 edx, 1
  07769	52		 push	 edx
  0776a	68 00 00 00 00	 push	 OFFSET $SG84768
  0776f	e8 00 00 00 00	 call	 _printf
  07774	83 c4 08	 add	 esp, 8
$LN1@P_wordsuse:

; 2610 : 	}
; 2611 : #ifdef Keyhit
; 2612 : 	if (kbquit()) {
; 2613 : 	    break;
; 2614 : 	}
; 2615 : #endif
; 2616 : 	dw = dw->wnext;

  07777	8b 45 fc	 mov	 eax, DWORD PTR _dw$[ebp]
  0777a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0777c	89 4d fc	 mov	 DWORD PTR _dw$[ebp], ecx

; 2617 :     }

  0777f	eb cb		 jmp	 SHORT $LN3@P_wordsuse
$LN2@P_wordsuse:

; 2618 :     V printf("\n");

  07781	68 00 00 00 00	 push	 OFFSET $SG84770
  07786	e8 00 00 00 00	 call	 _printf
  0778b	83 c4 04	 add	 esp, 4

; 2619 : }

  0778e	8b e5		 mov	 esp, ebp
  07790	5d		 pop	 ebp
  07791	c3		 ret	 0
_P_wordsused ENDP
; Function compile flags: /Odtp
_dw$ = -4						; size = 4
_P_wordsunused PROC

; 2622 : {

  077a0	55		 push	 ebp
  077a1	8b ec		 mov	 ebp, esp
  077a3	51		 push	 ecx

; 2623 :     dictword *dw = dict;

  077a4	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__dh
  077a9	89 45 fc	 mov	 DWORD PTR _dw$[ebp], eax
$LN3@P_wordsunu:

; 2624 : 
; 2625 :     while (dw != NULL) {

  077ac	83 7d fc 00	 cmp	 DWORD PTR _dw$[ebp], 0
  077b0	74 2f		 je	 SHORT $LN2@P_wordsunu

; 2626 : 	if (!(*(dw->wname) & WORDUSED)) {

  077b2	8b 4d fc	 mov	 ecx, DWORD PTR _dw$[ebp]
  077b5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  077b8	0f be 02	 movsx	 eax, BYTE PTR [edx]
  077bb	83 e0 02	 and	 eax, 2
  077be	75 17		 jne	 SHORT $LN1@P_wordsunu

; 2627 :            V printf("\n%s", dw->wname + 1);

  077c0	8b 4d fc	 mov	 ecx, DWORD PTR _dw$[ebp]
  077c3	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  077c6	83 c2 01	 add	 edx, 1
  077c9	52		 push	 edx
  077ca	68 00 00 00 00	 push	 OFFSET $SG84780
  077cf	e8 00 00 00 00	 call	 _printf
  077d4	83 c4 08	 add	 esp, 8
$LN1@P_wordsunu:

; 2628 : 	}
; 2629 : #ifdef Keyhit
; 2630 : 	if (kbquit()) {
; 2631 : 	    break;
; 2632 : 	}
; 2633 : #endif
; 2634 : 	dw = dw->wnext;

  077d7	8b 45 fc	 mov	 eax, DWORD PTR _dw$[ebp]
  077da	8b 08		 mov	 ecx, DWORD PTR [eax]
  077dc	89 4d fc	 mov	 DWORD PTR _dw$[ebp], ecx

; 2635 :     }

  077df	eb cb		 jmp	 SHORT $LN3@P_wordsunu
$LN2@P_wordsunu:

; 2636 :     V printf("\n");

  077e1	68 00 00 00 00	 push	 OFFSET $SG84782
  077e6	e8 00 00 00 00	 call	 _printf
  077eb	83 c4 04	 add	 esp, 4

; 2637 : }

  077ee	8b e5		 mov	 esp, ebp
  077f0	5d		 pop	 ebp
  077f1	c3		 ret	 0
_P_wordsunused ENDP
; Function compile flags: /Odtp
_P_brackcompile PROC

; 2643 : {

  07800	55		 push	 ebp
  07801	8b ec		 mov	 ebp, esp

; 2644 :     Compiling;

  07803	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hb
  07808	83 38 00	 cmp	 DWORD PTR [eax], 0
  0780b	75 07		 jne	 SHORT $LN1@P_brackcom
  0780d	e8 00 00 00 00	 call	 _notcomp
  07812	eb 0a		 jmp	 SHORT $LN2@P_brackcom
$LN1@P_brackcom:

; 2645 :     cbrackpend = True;		      /* Set [COMPILE] pending */

  07814	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _cbrackpend, 1
$LN2@P_brackcom:

; 2646 : }

  0781e	5d		 pop	 ebp
  0781f	c3		 ret	 0
_P_brackcompile ENDP
_TEXT	ENDS
_BSS	SEGMENT
_s_lit	DD	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
_P_literal PROC

; 2649 : {

  07820	55		 push	 ebp
  07821	8b ec		 mov	 ebp, esp

; 2650 :     Compiling;

  07823	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hb
  07828	83 38 00	 cmp	 DWORD PTR [eax], 0
  0782b	75 0a		 jne	 SHORT $LN4@P_literal
  0782d	e8 00 00 00 00	 call	 _notcomp
  07832	e9 99 00 00 00	 jmp	 $LN5@P_literal
$LN4@P_literal:

; 2651 :     Sl(1);

  07837	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0783d	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _atl__sk
  07843	c1 f9 02	 sar	 ecx, 2
  07846	83 f9 01	 cmp	 ecx, 1
  07849	7d 07		 jge	 SHORT $LN3@P_literal
  0784b	e8 00 00 00 00	 call	 _atl__Esu
  07850	eb 7e		 jmp	 SHORT $LN5@P_literal
$LN3@P_literal:

; 2652 :     Ho(2);

  07852	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  07858	83 c2 08	 add	 edx, 8
  0785b	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hx
  07861	76 0d		 jbe	 SHORT $LN2@P_literal
  07863	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  07868	83 c0 08	 add	 eax, 8
  0786b	a3 00 00 00 00	 mov	 DWORD PTR _atl__hx, eax
$LN2@P_literal:
  07870	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  07876	83 c1 08	 add	 ecx, 8
  07879	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  0787f	76 07		 jbe	 SHORT $LN1@P_literal
  07881	e8 00 00 00 00	 call	 _atl__Eho
  07886	eb 48		 jmp	 SHORT $LN5@P_literal
$LN1@P_literal:

; 2653 :     Hstore = s_lit;		      /* Compile load literal word */

  07888	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  0788e	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_lit
  07893	89 02		 mov	 DWORD PTR [edx], eax
  07895	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  0789b	83 c1 04	 add	 ecx, 4
  0789e	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hp, ecx

; 2654 :     Hstore = S0;		      /* Compile top of stack in line */

  078a4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  078aa	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  078af	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  078b2	89 0a		 mov	 DWORD PTR [edx], ecx
  078b4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  078ba	83 c2 04	 add	 edx, 4
  078bd	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hp, edx

; 2655 :     Pop;

  078c3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  078c8	83 e8 04	 sub	 eax, 4
  078cb	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN5@P_literal:

; 2656 : }

  078d0	5d		 pop	 ebp
  078d1	c3		 ret	 0
_P_literal ENDP
; Function compile flags: /Odtp
_P_compile PROC

; 2659 : {

  078e0	55		 push	 ebp
  078e1	8b ec		 mov	 ebp, esp

; 2660 :     Compiling;

  078e3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hb
  078e8	83 38 00	 cmp	 DWORD PTR [eax], 0
  078eb	75 07		 jne	 SHORT $LN3@P_compile
  078ed	e8 00 00 00 00	 call	 _notcomp
  078f2	eb 65		 jmp	 SHORT $LN4@P_compile
$LN3@P_compile:

; 2661 :     Ho(1);

  078f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  078fa	83 c1 04	 add	 ecx, 4
  078fd	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__hx
  07903	76 0f		 jbe	 SHORT $LN2@P_compile
  07905	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  0790b	83 c2 04	 add	 edx, 4
  0790e	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hx, edx
$LN2@P_compile:
  07914	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  07919	83 c0 04	 add	 eax, 4
  0791c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__ht
  07922	76 07		 jbe	 SHORT $LN1@P_compile
  07924	e8 00 00 00 00	 call	 _atl__Eho
  07929	eb 2e		 jmp	 SHORT $LN4@P_compile
$LN1@P_compile:

; 2662 :     Hstore = (stackitem) *ip++;       /* Compile the next datum from the

  0792b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  07931	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__ip
  07937	8b 02		 mov	 eax, DWORD PTR [edx]
  07939	89 01		 mov	 DWORD PTR [ecx], eax
  0793b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  07941	83 c1 04	 add	 ecx, 4
  07944	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hp, ecx
  0794a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__ip
  07950	83 c2 04	 add	 edx, 4
  07953	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__ip, edx
$LN4@P_compile:

; 2663 : 					 instruction stream. */
; 2664 : }

  07959	5d		 pop	 ebp
  0795a	c3		 ret	 0
_P_compile ENDP
; Function compile flags: /Odtp
_P_backmark PROC

; 2667 : {

  07960	55		 push	 ebp
  07961	8b ec		 mov	 ebp, esp

; 2668 :     Compiling;

  07963	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hb
  07968	83 38 00	 cmp	 DWORD PTR [eax], 0
  0796b	75 07		 jne	 SHORT $LN3@P_backmark
  0796d	e8 00 00 00 00	 call	 _notcomp
  07972	eb 52		 jmp	 SHORT $LN4@P_backmark
$LN3@P_backmark:

; 2669 :     So(1);

  07974	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0797a	83 c1 04	 add	 ecx, 4
  0797d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__sx
  07983	76 0f		 jbe	 SHORT $LN2@P_backmark
  07985	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  0798b	83 c2 04	 add	 edx, 4
  0798e	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sx, edx
$LN2@P_backmark:
  07994	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  07999	83 c0 04	 add	 eax, 4
  0799c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__st
  079a2	76 07		 jbe	 SHORT $LN1@P_backmark
  079a4	e8 00 00 00 00	 call	 _atl__Eso
  079a9	eb 1b		 jmp	 SHORT $LN4@P_backmark
$LN1@P_backmark:

; 2670 :     Push = (stackitem) hptr;	      /* Push heap address onto stack */

  079ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  079b1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  079b7	89 11		 mov	 DWORD PTR [ecx], edx
  079b9	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  079be	83 c0 04	 add	 eax, 4
  079c1	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN4@P_backmark:

; 2671 : }

  079c6	5d		 pop	 ebp
  079c7	c3		 ret	 0
_P_backmark ENDP
; Function compile flags: /Odtp
_offset$ = -4						; size = 4
_P_backresolve PROC

; 2674 : {

  079d0	55		 push	 ebp
  079d1	8b ec		 mov	 ebp, esp
  079d3	51		 push	 ecx

; 2675 :     stackitem offset;
; 2676 : 
; 2677 :     Compiling;

  079d4	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hb
  079d9	83 38 00	 cmp	 DWORD PTR [eax], 0
  079dc	75 0a		 jne	 SHORT $LN6@P_backreso
  079de	e8 00 00 00 00	 call	 _notcomp
  079e3	e9 bc 00 00 00	 jmp	 $LN7@P_backreso
$LN6@P_backreso:

; 2678 :     Sl(1);

  079e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  079ee	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _atl__sk
  079f4	c1 f9 02	 sar	 ecx, 2
  079f7	83 f9 01	 cmp	 ecx, 1
  079fa	7d 0a		 jge	 SHORT $LN5@P_backreso
  079fc	e8 00 00 00 00	 call	 _atl__Esu
  07a01	e9 9e 00 00 00	 jmp	 $LN7@P_backreso
$LN5@P_backreso:

; 2679 :     Ho(1);

  07a06	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  07a0c	83 c2 04	 add	 edx, 4
  07a0f	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hx
  07a15	76 0d		 jbe	 SHORT $LN4@P_backreso
  07a17	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  07a1c	83 c0 04	 add	 eax, 4
  07a1f	a3 00 00 00 00	 mov	 DWORD PTR _atl__hx, eax
$LN4@P_backreso:
  07a24	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  07a2a	83 c1 04	 add	 ecx, 4
  07a2d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  07a33	76 07		 jbe	 SHORT $LN3@P_backreso
  07a35	e8 00 00 00 00	 call	 _atl__Eho
  07a3a	eb 68		 jmp	 SHORT $LN7@P_backreso
$LN3@P_backreso:

; 2680 :     Hpc(S0);

  07a3c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  07a42	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  07a45	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hs
  07a4b	72 11		 jb	 SHORT $LN1@P_backreso
  07a4d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  07a53	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  07a56	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__ht
  07a5c	72 07		 jb	 SHORT $LN2@P_backreso
$LN1@P_backreso:
  07a5e	e8 00 00 00 00	 call	 _atl__Ebp
  07a63	eb 3f		 jmp	 SHORT $LN7@P_backreso
$LN2@P_backreso:

; 2681 :     offset = -(hptr - (stackitem *) S0);

  07a65	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  07a6a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  07a70	2b 48 fc	 sub	 ecx, DWORD PTR [eax-4]
  07a73	c1 f9 02	 sar	 ecx, 2
  07a76	f7 d9		 neg	 ecx
  07a78	89 4d fc	 mov	 DWORD PTR _offset$[ebp], ecx

; 2682 :     Hstore = offset;

  07a7b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  07a81	8b 45 fc	 mov	 eax, DWORD PTR _offset$[ebp]
  07a84	89 02		 mov	 DWORD PTR [edx], eax
  07a86	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  07a8c	83 c1 04	 add	 ecx, 4
  07a8f	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hp, ecx

; 2683 :     Pop;

  07a95	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  07a9b	83 ea 04	 sub	 edx, 4
  07a9e	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN7@P_backreso:

; 2684 : }

  07aa4	8b e5		 mov	 esp, ebp
  07aa6	5d		 pop	 ebp
  07aa7	c3		 ret	 0
_P_backresolve ENDP
; Function compile flags: /Odtp
_P_fwdmark PROC

; 2687 : {

  07ab0	55		 push	 ebp
  07ab1	8b ec		 mov	 ebp, esp

; 2688 :     Compiling;

  07ab3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hb
  07ab8	83 38 00	 cmp	 DWORD PTR [eax], 0
  07abb	75 07		 jne	 SHORT $LN3@P_fwdmark
  07abd	e8 00 00 00 00	 call	 _notcomp
  07ac2	eb 6d		 jmp	 SHORT $LN4@P_fwdmark
$LN3@P_fwdmark:

; 2689 :     Ho(1);

  07ac4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  07aca	83 c1 04	 add	 ecx, 4
  07acd	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__hx
  07ad3	76 0f		 jbe	 SHORT $LN2@P_fwdmark
  07ad5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  07adb	83 c2 04	 add	 edx, 4
  07ade	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hx, edx
$LN2@P_fwdmark:
  07ae4	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  07ae9	83 c0 04	 add	 eax, 4
  07aec	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__ht
  07af2	76 07		 jbe	 SHORT $LN1@P_fwdmark
  07af4	e8 00 00 00 00	 call	 _atl__Eho
  07af9	eb 36		 jmp	 SHORT $LN4@P_fwdmark
$LN1@P_fwdmark:

; 2690 :     Push = (stackitem) hptr;	      /* Push heap address onto stack */

  07afb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  07b01	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  07b07	89 11		 mov	 DWORD PTR [ecx], edx
  07b09	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  07b0e	83 c0 04	 add	 eax, 4
  07b11	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax

; 2691 :     Hstore = 0;

  07b16	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  07b1c	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  07b22	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  07b28	83 c2 04	 add	 edx, 4
  07b2b	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hp, edx
$LN4@P_fwdmark:

; 2692 : }

  07b31	5d		 pop	 ebp
  07b32	c3		 ret	 0
_P_fwdmark ENDP
; Function compile flags: /Odtp
_offset$ = -4						; size = 4
_P_fwdresolve PROC

; 2695 : {

  07b40	55		 push	 ebp
  07b41	8b ec		 mov	 ebp, esp
  07b43	51		 push	 ecx

; 2696 :     stackitem offset;
; 2697 : 
; 2698 :     Compiling;

  07b44	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hb
  07b49	83 38 00	 cmp	 DWORD PTR [eax], 0
  07b4c	75 07		 jne	 SHORT $LN4@P_fwdresol
  07b4e	e8 00 00 00 00	 call	 _notcomp
  07b53	eb 75		 jmp	 SHORT $LN5@P_fwdresol
$LN4@P_fwdresol:

; 2699 :     Sl(1);

  07b55	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  07b5b	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR _atl__sk
  07b61	c1 f9 02	 sar	 ecx, 2
  07b64	83 f9 01	 cmp	 ecx, 1
  07b67	7d 07		 jge	 SHORT $LN3@P_fwdresol
  07b69	e8 00 00 00 00	 call	 _atl__Esu
  07b6e	eb 5a		 jmp	 SHORT $LN5@P_fwdresol
$LN3@P_fwdresol:

; 2700 :     Hpc(S0);

  07b70	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  07b76	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  07b79	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hs
  07b7f	72 11		 jb	 SHORT $LN1@P_fwdresol
  07b81	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  07b87	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  07b8a	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__ht
  07b90	72 07		 jb	 SHORT $LN2@P_fwdresol
$LN1@P_fwdresol:
  07b92	e8 00 00 00 00	 call	 _atl__Ebp
  07b97	eb 31		 jmp	 SHORT $LN5@P_fwdresol
$LN2@P_fwdresol:

; 2701 :     offset = (hptr - (stackitem *) S0);

  07b99	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  07b9e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  07ba4	2b 48 fc	 sub	 ecx, DWORD PTR [eax-4]
  07ba7	c1 f9 02	 sar	 ecx, 2
  07baa	89 4d fc	 mov	 DWORD PTR _offset$[ebp], ecx

; 2702 :     *((stackitem *) S0) = offset;

  07bad	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  07bb3	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  07bb6	8b 4d fc	 mov	 ecx, DWORD PTR _offset$[ebp]
  07bb9	89 08		 mov	 DWORD PTR [eax], ecx

; 2703 :     Pop;

  07bbb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  07bc1	83 ea 04	 sub	 edx, 4
  07bc4	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx
$LN5@P_fwdresol:

; 2704 : }

  07bca	8b e5		 mov	 esp, ebp
  07bcc	5d		 pop	 ebp
  07bcd	c3		 ret	 0
_P_fwdresolve ENDP
_TEXT	ENDS
PUBLIC	_atl_primdef
; Function compile flags: /Odtp
_TEXT	SEGMENT
_nw$ = -16						; size = 4
_pf$ = -12						; size = 4
_i$ = -8						; size = 4
_n$ = -4						; size = 4
_pt$ = 8						; size = 4
_atl_primdef PROC

; 2973 : {

  07bd0	55		 push	 ebp
  07bd1	8b ec		 mov	 ebp, esp
  07bd3	83 ec 10	 sub	 esp, 16			; 00000010H

; 2974 :     struct primfcn *pf = pt;

  07bd6	8b 45 08	 mov	 eax, DWORD PTR _pt$[ebp]
  07bd9	89 45 f4	 mov	 DWORD PTR _pf$[ebp], eax

; 2975 :     dictword *nw;
; 2976 :     int i, n = 0;

  07bdc	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
$LN6@atl_primde:

; 2977 : #ifdef WORDSUSED
; 2978 : #ifdef READONLYSTRINGS
; 2979 :     unsigned int nltotal;
; 2980 :     char *dynames, *cp;
; 2981 : #endif /* READONLYSTRINGS */
; 2982 : #endif /* WORDSUSED */
; 2983 : 
; 2984 :     /* Count the number of definitions in the table. */
; 2985 : 
; 2986 :     while (pf->pname != NULL) {

  07be3	8b 4d f4	 mov	 ecx, DWORD PTR _pf$[ebp]
  07be6	83 39 00	 cmp	 DWORD PTR [ecx], 0
  07be9	74 14		 je	 SHORT $LN5@atl_primde

; 2987 : 	n++;

  07beb	8b 55 fc	 mov	 edx, DWORD PTR _n$[ebp]
  07bee	83 c2 01	 add	 edx, 1
  07bf1	89 55 fc	 mov	 DWORD PTR _n$[ebp], edx

; 2988 : 	pf++;

  07bf4	8b 45 f4	 mov	 eax, DWORD PTR _pf$[ebp]
  07bf7	83 c0 08	 add	 eax, 8
  07bfa	89 45 f4	 mov	 DWORD PTR _pf$[ebp], eax

; 2989 :     }

  07bfd	eb e4		 jmp	 SHORT $LN6@atl_primde
$LN5@atl_primde:

; 2990 : 
; 2991 : #ifdef WORDSUSED
; 2992 : #ifdef READONLYSTRINGS
; 2993 :     nltotal = n;
; 2994 :     for (i = 0; i < n; i++) {
; 2995 : 	nltotal += strlen(pt[i].pname);
; 2996 :     }
; 2997 :     cp = dynames = alloc(nltotal);
; 2998 :     for (i = 0; i < n; i++) {
; 2999 : 	strcpy(cp, pt[i].pname);
; 3000 : 	cp += strlen(cp) + 1;
; 3001 :     }
; 3002 :     cp = dynames;
; 3003 : #endif /* READONLYSTRINGS */
; 3004 : #endif /* WORDSUSED */
; 3005 : 
; 3006 :     nw = (dictword *) alloc((unsigned int) (n * sizeof(dictword)));

  07bff	8b 4d fc	 mov	 ecx, DWORD PTR _n$[ebp]
  07c02	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  07c05	51		 push	 ecx
  07c06	e8 00 00 00 00	 call	 _alloc
  07c0b	83 c4 04	 add	 esp, 4
  07c0e	89 45 f0	 mov	 DWORD PTR _nw$[ebp], eax

; 3007 : 
; 3008 :     nw[n - 1].wnext = dict;

  07c11	8b 55 fc	 mov	 edx, DWORD PTR _n$[ebp]
  07c14	83 ea 01	 sub	 edx, 1
  07c17	6b d2 0c	 imul	 edx, 12			; 0000000cH
  07c1a	8b 45 f0	 mov	 eax, DWORD PTR _nw$[ebp]
  07c1d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__dh
  07c23	89 0c 10	 mov	 DWORD PTR [eax+edx], ecx

; 3009 :     dict = nw;

  07c26	8b 55 f0	 mov	 edx, DWORD PTR _nw$[ebp]
  07c29	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__dh, edx

; 3010 :     for (i = 0; i < n; i++) {

  07c2f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  07c36	eb 09		 jmp	 SHORT $LN4@atl_primde
$LN3@atl_primde:
  07c38	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  07c3b	83 c0 01	 add	 eax, 1
  07c3e	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@atl_primde:
  07c41	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  07c44	3b 4d fc	 cmp	 ecx, DWORD PTR _n$[ebp]
  07c47	7d 41		 jge	 SHORT $LN7@atl_primde

; 3011 : 	nw->wname = pt->pname;

  07c49	8b 55 f0	 mov	 edx, DWORD PTR _nw$[ebp]
  07c4c	8b 45 08	 mov	 eax, DWORD PTR _pt$[ebp]
  07c4f	8b 08		 mov	 ecx, DWORD PTR [eax]
  07c51	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 3012 : #ifdef WORDSUSED
; 3013 : #ifdef READONLYSTRINGS
; 3014 :     	nw->wname = cp;
; 3015 : 	cp += strlen(cp) + 1;
; 3016 : #endif /* READONLYSTRINGS */
; 3017 : #endif /* WORDSUSED */
; 3018 : 	nw->wcode = pt->pcode;

  07c54	8b 55 f0	 mov	 edx, DWORD PTR _nw$[ebp]
  07c57	8b 45 08	 mov	 eax, DWORD PTR _pt$[ebp]
  07c5a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  07c5d	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 3019 : 	if (i != (n - 1)) {

  07c60	8b 55 fc	 mov	 edx, DWORD PTR _n$[ebp]
  07c63	83 ea 01	 sub	 edx, 1
  07c66	39 55 f8	 cmp	 DWORD PTR _i$[ebp], edx
  07c69	74 0b		 je	 SHORT $LN1@atl_primde

; 3020 : 	    nw->wnext = nw + 1;

  07c6b	8b 45 f0	 mov	 eax, DWORD PTR _nw$[ebp]
  07c6e	83 c0 0c	 add	 eax, 12			; 0000000cH
  07c71	8b 4d f0	 mov	 ecx, DWORD PTR _nw$[ebp]
  07c74	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@atl_primde:

; 3021 : 	}
; 3022 : 	nw++;

  07c76	8b 55 f0	 mov	 edx, DWORD PTR _nw$[ebp]
  07c79	83 c2 0c	 add	 edx, 12			; 0000000cH
  07c7c	89 55 f0	 mov	 DWORD PTR _nw$[ebp], edx

; 3023 : 	pt++;

  07c7f	8b 45 08	 mov	 eax, DWORD PTR _pt$[ebp]
  07c82	83 c0 08	 add	 eax, 8
  07c85	89 45 08	 mov	 DWORD PTR _pt$[ebp], eax

; 3024 :     }

  07c88	eb ae		 jmp	 SHORT $LN3@atl_primde
$LN7@atl_primde:

; 3025 : }

  07c8a	8b e5		 mov	 esp, ebp
  07c8c	5d		 pop	 ebp
  07c8d	c3		 ret	 0
_atl_primdef ENDP
; Function compile flags: /Odtp
_wb$85063 = -4						; size = 4
_pwalkback PROC

; 3032 : {

  07c90	55		 push	 ebp
  07c91	8b ec		 mov	 ebp, esp
  07c93	51		 push	 ecx

; 3033 :     if (atl_walkback && ((curword != NULL) || (wbptr > wback))) {

  07c94	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _atl_walkback, 0
  07c9b	0f 84 86 00 00
	00		 je	 $LN6@pwalkback
  07ca1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _atl__cw, 0
  07ca8	75 0d		 jne	 SHORT $LN4@pwalkback
  07caa	a1 00 00 00 00	 mov	 eax, DWORD PTR _wbptr
  07caf	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _wback
  07cb5	76 70		 jbe	 SHORT $LN6@pwalkback
$LN4@pwalkback:

; 3034 :         V printf("Walkback:\n");

  07cb7	68 00 00 00 00	 push	 OFFSET $SG85055
  07cbc	e8 00 00 00 00	 call	 _printf
  07cc1	83 c4 04	 add	 esp, 4

; 3035 : 	if (curword != NULL) {

  07cc4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _atl__cw, 0
  07ccb	74 1a		 je	 SHORT $LN2@pwalkback

; 3036 :             V printf("   %s\n", curword->wname + 1);

  07ccd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__cw
  07cd3	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  07cd6	83 c2 01	 add	 edx, 1
  07cd9	52		 push	 edx
  07cda	68 00 00 00 00	 push	 OFFSET $SG85059
  07cdf	e8 00 00 00 00	 call	 _printf
  07ce4	83 c4 08	 add	 esp, 8
$LN2@pwalkback:

; 3037 : 	}
; 3038 : 	while (wbptr > wback) {

  07ce7	a1 00 00 00 00	 mov	 eax, DWORD PTR _wbptr
  07cec	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _wback
  07cf2	76 33		 jbe	 SHORT $LN6@pwalkback

; 3039 : 	    dictword *wb = *(--wbptr);

  07cf4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _wbptr
  07cfa	83 e9 04	 sub	 ecx, 4
  07cfd	89 0d 00 00 00
	00		 mov	 DWORD PTR _wbptr, ecx
  07d03	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _wbptr
  07d09	8b 02		 mov	 eax, DWORD PTR [edx]
  07d0b	89 45 fc	 mov	 DWORD PTR _wb$85063[ebp], eax

; 3040 :             V printf("   %s\n", wb->wname + 1);

  07d0e	8b 4d fc	 mov	 ecx, DWORD PTR _wb$85063[ebp]
  07d11	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  07d14	83 c2 01	 add	 edx, 1
  07d17	52		 push	 edx
  07d18	68 00 00 00 00	 push	 OFFSET $SG85065
  07d1d	e8 00 00 00 00	 call	 _printf
  07d22	83 c4 08	 add	 esp, 8

; 3041 : 	}

  07d25	eb c0		 jmp	 SHORT $LN2@pwalkback
$LN6@pwalkback:

; 3042 :     }
; 3043 : }

  07d27	8b e5		 mov	 esp, ebp
  07d29	5d		 pop	 ebp
  07d2a	c3		 ret	 0
_pwalkback ENDP
; Function compile flags: /Odtp
_kind$ = 8						; size = 4
_trouble PROC

; 3050 : {

  07d30	55		 push	 ebp
  07d31	8b ec		 mov	 ebp, esp

; 3051 : #ifdef MEMMESSAGE
; 3052 :     V printf("\n%s.\n", kind);

  07d33	8b 45 08	 mov	 eax, DWORD PTR _kind$[ebp]
  07d36	50		 push	 eax
  07d37	68 00 00 00 00	 push	 OFFSET $SG85070
  07d3c	e8 00 00 00 00	 call	 _printf
  07d41	83 c4 08	 add	 esp, 8

; 3053 : #endif
; 3054 : #ifdef WALKBACK
; 3055 :     pwalkback();

  07d44	e8 00 00 00 00	 call	 _pwalkback

; 3056 : #endif /* WALKBACK */
; 3057 :     P_abort();			      /* Abort */

  07d49	e8 00 00 00 00	 call	 _P_abort

; 3058 :     atl_comment = state = Falsity;    /* Reset all interpretation state */

  07d4e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hb
  07d54	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  07d5a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _atl_comment, 0

; 3059 :     forgetpend = defpend = stringlit =
; 3060 : 	tickpend = ctickpend = False;

  07d64	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ctickpend, 0
  07d6e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ctickpend
  07d74	89 15 00 00 00
	00		 mov	 DWORD PTR _tickpend, edx
  07d7a	a1 00 00 00 00	 mov	 eax, DWORD PTR _tickpend
  07d7f	a3 00 00 00 00	 mov	 DWORD PTR _stringlit, eax
  07d84	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stringlit
  07d8a	89 0d 00 00 00
	00		 mov	 DWORD PTR _defpend, ecx
  07d90	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _defpend
  07d96	89 15 00 00 00
	00		 mov	 DWORD PTR _forgetpend, edx

; 3061 : }

  07d9c	5d		 pop	 ebp
  07d9d	c3		 ret	 0
_trouble ENDP
_TEXT	ENDS
PUBLIC	_atl_error
; Function compile flags: /Odtp
_TEXT	SEGMENT
_kind$ = 8						; size = 4
_atl_error PROC

; 3067 : {

  07da0	55		 push	 ebp
  07da1	8b ec		 mov	 ebp, esp

; 3068 :     trouble(kind);

  07da3	8b 45 08	 mov	 eax, DWORD PTR _kind$[ebp]
  07da6	50		 push	 eax
  07da7	e8 00 00 00 00	 call	 _trouble
  07dac	83 c4 04	 add	 esp, 4

; 3069 :     evalstat = ATL_APPLICATION;       /* Signify application-detected error */

  07daf	c7 05 00 00 00
	00 f2 ff ff ff	 mov	 DWORD PTR _evalstat, -14 ; fffffff2H

; 3070 : }

  07db9	5d		 pop	 ebp
  07dba	c3		 ret	 0
_atl_error ENDP
; Function compile flags: /Odtp
_atl__Eso PROC

; 3077 : {

  07dc0	55		 push	 ebp
  07dc1	8b ec		 mov	 ebp, esp

; 3078 :     trouble("Stack overflow");

  07dc3	68 00 00 00 00	 push	 OFFSET $SG85075
  07dc8	e8 00 00 00 00	 call	 _trouble
  07dcd	83 c4 04	 add	 esp, 4

; 3079 :     evalstat = ATL_STACKOVER;

  07dd0	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _evalstat, -1

; 3080 : }

  07dda	5d		 pop	 ebp
  07ddb	c3		 ret	 0
_atl__Eso ENDP
; Function compile flags: /Odtp
_atl__Esu PROC

; 3085 : {

  07de0	55		 push	 ebp
  07de1	8b ec		 mov	 ebp, esp

; 3086 :     trouble("Stack underflow");

  07de3	68 00 00 00 00	 push	 OFFSET $SG85077
  07de8	e8 00 00 00 00	 call	 _trouble
  07ded	83 c4 04	 add	 esp, 4

; 3087 :     evalstat = ATL_STACKUNDER;

  07df0	c7 05 00 00 00
	00 fe ff ff ff	 mov	 DWORD PTR _evalstat, -2	; fffffffeH

; 3088 : }

  07dfa	5d		 pop	 ebp
  07dfb	c3		 ret	 0
_atl__Esu ENDP
; Function compile flags: /Odtp
_atl__Erso PROC

; 3093 : {

  07e00	55		 push	 ebp
  07e01	8b ec		 mov	 ebp, esp

; 3094 :     trouble("Return stack overflow");

  07e03	68 00 00 00 00	 push	 OFFSET $SG85079
  07e08	e8 00 00 00 00	 call	 _trouble
  07e0d	83 c4 04	 add	 esp, 4

; 3095 :     evalstat = ATL_RSTACKOVER;

  07e10	c7 05 00 00 00
	00 fd ff ff ff	 mov	 DWORD PTR _evalstat, -3	; fffffffdH

; 3096 : }

  07e1a	5d		 pop	 ebp
  07e1b	c3		 ret	 0
_atl__Erso ENDP
; Function compile flags: /Odtp
_atl__Ersu PROC

; 3101 : {

  07e20	55		 push	 ebp
  07e21	8b ec		 mov	 ebp, esp

; 3102 :     trouble("Return stack underflow");

  07e23	68 00 00 00 00	 push	 OFFSET $SG85081
  07e28	e8 00 00 00 00	 call	 _trouble
  07e2d	83 c4 04	 add	 esp, 4

; 3103 :     evalstat = ATL_RSTACKUNDER;

  07e30	c7 05 00 00 00
	00 fc ff ff ff	 mov	 DWORD PTR _evalstat, -4	; fffffffcH

; 3104 : }

  07e3a	5d		 pop	 ebp
  07e3b	c3		 ret	 0
_atl__Ersu ENDP
; Function compile flags: /Odtp
_atl__Eho PROC

; 3112 : {

  07e40	55		 push	 ebp
  07e41	8b ec		 mov	 ebp, esp

; 3113 :     trouble("Heap overflow");

  07e43	68 00 00 00 00	 push	 OFFSET $SG85083
  07e48	e8 00 00 00 00	 call	 _trouble
  07e4d	83 c4 04	 add	 esp, 4

; 3114 :     evalstat = ATL_HEAPOVER;

  07e50	c7 05 00 00 00
	00 fb ff ff ff	 mov	 DWORD PTR _evalstat, -5	; fffffffbH

; 3115 : }

  07e5a	5d		 pop	 ebp
  07e5b	c3		 ret	 0
_atl__Eho ENDP
; Function compile flags: /Odtp
_atl__Ebp PROC

; 3120 : {

  07e60	55		 push	 ebp
  07e61	8b ec		 mov	 ebp, esp

; 3121 :     trouble("Bad pointer");

  07e63	68 00 00 00 00	 push	 OFFSET $SG85085
  07e68	e8 00 00 00 00	 call	 _trouble
  07e6d	83 c4 04	 add	 esp, 4

; 3122 :     evalstat = ATL_BADPOINTER;

  07e70	c7 05 00 00 00
	00 fa ff ff ff	 mov	 DWORD PTR _evalstat, -6	; fffffffaH

; 3123 : }

  07e7a	5d		 pop	 ebp
  07e7b	c3		 ret	 0
_atl__Ebp ENDP
; Function compile flags: /Odtp
_notcomp PROC

; 3128 : {

  07e80	55		 push	 ebp
  07e81	8b ec		 mov	 ebp, esp

; 3129 :     trouble("Compiler word outside definition");

  07e83	68 00 00 00 00	 push	 OFFSET $SG85087
  07e88	e8 00 00 00 00	 call	 _trouble
  07e8d	83 c4 04	 add	 esp, 4

; 3130 :     evalstat = ATL_NOTINDEF;

  07e90	c7 05 00 00 00
	00 f7 ff ff ff	 mov	 DWORD PTR _evalstat, -9	; fffffff7H

; 3131 : }

  07e9a	5d		 pop	 ebp
  07e9b	c3		 ret	 0
_notcomp ENDP
; Function compile flags: /Odtp
_divzero PROC

; 3136 : {

  07ea0	55		 push	 ebp
  07ea1	8b ec		 mov	 ebp, esp

; 3137 :     trouble("Divide by zero");

  07ea3	68 00 00 00 00	 push	 OFFSET $SG85089
  07ea8	e8 00 00 00 00	 call	 _trouble
  07ead	83 c4 04	 add	 esp, 4

; 3138 :     evalstat = ATL_DIVZERO;

  07eb0	c7 05 00 00 00
	00 f3 ff ff ff	 mov	 DWORD PTR _evalstat, -13 ; fffffff3H

; 3139 : }

  07eba	5d		 pop	 ebp
  07ebb	c3		 ret	 0
_divzero ENDP
; Function compile flags: /Odtp
_wp$ = 8						; size = 4
_exword	PROC

; 3147 : {

  07ec0	55		 push	 ebp
  07ec1	8b ec		 mov	 ebp, esp

; 3148 :     curword = wp;

  07ec3	8b 45 08	 mov	 eax, DWORD PTR _wp$[ebp]
  07ec6	a3 00 00 00 00	 mov	 DWORD PTR _atl__cw, eax

; 3149 : #ifdef TRACE
; 3150 :     if (atl_trace) {

  07ecb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _atl_trace, 0
  07ed2	74 1a		 je	 SHORT $LN5@exword

; 3151 :         V printf("\nTrace: %s ", curword->wname + 1);

  07ed4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__cw
  07eda	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  07edd	83 c2 01	 add	 edx, 1
  07ee0	52		 push	 edx
  07ee1	68 00 00 00 00	 push	 OFFSET $SG85095
  07ee6	e8 00 00 00 00	 call	 _printf
  07eeb	83 c4 08	 add	 esp, 8
$LN5@exword:

; 3152 :     }
; 3153 : #endif /* TRACE */
; 3154 :     (*curword->wcode)();	      /* Execute the first word */

  07eee	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__cw
  07ef3	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  07ef6	ff d1		 call	 ecx
$LN4@exword:

; 3155 :     while (ip != NULL) {

  07ef8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _atl__ip, 0
  07eff	74 6e		 je	 SHORT $LN3@exword

; 3156 : #ifdef BREAK
; 3157 : #ifdef Keybreak
; 3158 : 	Keybreak();		      /* Poll for asynchronous interrupt */
; 3159 : #endif
; 3160 : 	if (broken) {		      /* Did we receive a break signal */

  07f01	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _broken, 0
  07f08	74 19		 je	 SHORT $LN2@exword

; 3161 :             trouble("Break signal");

  07f0a	68 00 00 00 00	 push	 OFFSET $SG85101
  07f0f	e8 00 00 00 00	 call	 _trouble
  07f14	83 c4 04	 add	 esp, 4

; 3162 : 	    evalstat = ATL_BREAK;

  07f17	c7 05 00 00 00
	00 f4 ff ff ff	 mov	 DWORD PTR _evalstat, -12 ; fffffff4H

; 3163 : 	    break;

  07f21	eb 4c		 jmp	 SHORT $LN3@exword
$LN2@exword:

; 3164 : 	}
; 3165 : #endif /* BREAK */
; 3166 : 	curword = *ip++;

  07f23	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__ip
  07f29	8b 02		 mov	 eax, DWORD PTR [edx]
  07f2b	a3 00 00 00 00	 mov	 DWORD PTR _atl__cw, eax
  07f30	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__ip
  07f36	83 c1 04	 add	 ecx, 4
  07f39	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__ip, ecx

; 3167 : #ifdef TRACE
; 3168 : 	if (atl_trace) {

  07f3f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _atl_trace, 0
  07f46	74 1a		 je	 SHORT $LN1@exword

; 3169 :             V printf("\nTrace: %s ", curword->wname + 1);

  07f48	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__cw
  07f4e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  07f51	83 c0 01	 add	 eax, 1
  07f54	50		 push	 eax
  07f55	68 00 00 00 00	 push	 OFFSET $SG85104
  07f5a	e8 00 00 00 00	 call	 _printf
  07f5f	83 c4 08	 add	 esp, 8
$LN1@exword:

; 3170 : 	}
; 3171 : #endif /* TRACE */
; 3172 : 	(*curword->wcode)();	      /* Execute the next word */

  07f62	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__cw
  07f68	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  07f6b	ff d2		 call	 edx

; 3173 :     }

  07f6d	eb 89		 jmp	 SHORT $LN4@exword
$LN3@exword:

; 3174 :     curword = NULL;

  07f6f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _atl__cw, 0

; 3175 : }

  07f79	5d		 pop	 ebp
  07f7a	c3		 ret	 0
_exword	ENDP
_TEXT	ENDS
PUBLIC	_atl_body
PUBLIC	_atl_vardef
PUBLIC	_atl_init
_BSS	SEGMENT
_s_strlit DD	01H DUP (?)
_s_flit	DD	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
_si$85197 = -20						; size = 4
_dw$85190 = -16						; size = 4
_i$85189 = -12						; size = 4
_i$85162 = -8						; size = 4
_cp$85163 = -4						; size = 4
_atl_init PROC

; 3187 : {

  07f80	55		 push	 ebp
  07f81	8b ec		 mov	 ebp, esp
  07f83	83 ec 14	 sub	 esp, 20			; 00000014H

; 3188 :     if (dict == NULL) {

  07f86	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _atl__dh, 0
  07f8d	0f 85 f9 03 00
	00		 jne	 $LN25@atl_init

; 3189 : 	atl_primdef(primt);	      /* Define primitive words */

  07f93	68 00 00 00 00	 push	 OFFSET _primt
  07f98	e8 00 00 00 00	 call	 _atl_primdef
  07f9d	83 c4 04	 add	 esp, 4

; 3190 : 	dictprot = dict;	      /* Set protected mark in dictionary */

  07fa0	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__dh
  07fa5	a3 00 00 00 00	 mov	 DWORD PTR _atl__dp, eax

; 3191 : 
; 3192 : 	/* Look up compiler-referenced words in the new dictionary and
; 3193 : 	   save their compile addresses in static variables. */
; 3194 : 
; 3195 : #define Cconst(cell, name)  cell = (stackitem) lookup(name); if(cell==0)abort()
; 3196 :         Cconst(s_exit, "EXIT");

  07faa	68 00 00 00 00	 push	 OFFSET $SG85110
  07faf	e8 00 00 00 00	 call	 _lookup
  07fb4	83 c4 04	 add	 esp, 4
  07fb7	a3 00 00 00 00	 mov	 DWORD PTR _s_exit, eax
  07fbc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _s_exit, 0
  07fc3	75 05		 jne	 SHORT $LN23@atl_init
  07fc5	e8 00 00 00 00	 call	 _abort
$LN23@atl_init:

; 3197 :         Cconst(s_lit, "(LIT)");

  07fca	68 00 00 00 00	 push	 OFFSET $SG85113
  07fcf	e8 00 00 00 00	 call	 _lookup
  07fd4	83 c4 04	 add	 esp, 4
  07fd7	a3 00 00 00 00	 mov	 DWORD PTR _s_lit, eax
  07fdc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _s_lit, 0
  07fe3	75 05		 jne	 SHORT $LN22@atl_init
  07fe5	e8 00 00 00 00	 call	 _abort
$LN22@atl_init:

; 3198 :         Cconst(s_flit, "(FLIT)");

  07fea	68 00 00 00 00	 push	 OFFSET $SG85116
  07fef	e8 00 00 00 00	 call	 _lookup
  07ff4	83 c4 04	 add	 esp, 4
  07ff7	a3 00 00 00 00	 mov	 DWORD PTR _s_flit, eax
  07ffc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _s_flit, 0
  08003	75 05		 jne	 SHORT $LN21@atl_init
  08005	e8 00 00 00 00	 call	 _abort
$LN21@atl_init:

; 3199 :         Cconst(s_strlit, "(STRLIT)");

  0800a	68 00 00 00 00	 push	 OFFSET $SG85119
  0800f	e8 00 00 00 00	 call	 _lookup
  08014	83 c4 04	 add	 esp, 4
  08017	a3 00 00 00 00	 mov	 DWORD PTR _s_strlit, eax
  0801c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _s_strlit, 0
  08023	75 05		 jne	 SHORT $LN20@atl_init
  08025	e8 00 00 00 00	 call	 _abort
$LN20@atl_init:

; 3200 :         Cconst(s_dotparen, ".(");

  0802a	68 00 00 00 00	 push	 OFFSET $SG85122
  0802f	e8 00 00 00 00	 call	 _lookup
  08034	83 c4 04	 add	 esp, 4
  08037	a3 00 00 00 00	 mov	 DWORD PTR _s_dotparen, eax
  0803c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _s_dotparen, 0
  08043	75 05		 jne	 SHORT $LN19@atl_init
  08045	e8 00 00 00 00	 call	 _abort
$LN19@atl_init:

; 3201 :         Cconst(s_qbranch, "?BRANCH");

  0804a	68 00 00 00 00	 push	 OFFSET $SG85125
  0804f	e8 00 00 00 00	 call	 _lookup
  08054	83 c4 04	 add	 esp, 4
  08057	a3 00 00 00 00	 mov	 DWORD PTR _s_qbranch, eax
  0805c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _s_qbranch, 0
  08063	75 05		 jne	 SHORT $LN18@atl_init
  08065	e8 00 00 00 00	 call	 _abort
$LN18@atl_init:

; 3202 :         Cconst(s_branch, "BRANCH");

  0806a	68 00 00 00 00	 push	 OFFSET $SG85128
  0806f	e8 00 00 00 00	 call	 _lookup
  08074	83 c4 04	 add	 esp, 4
  08077	a3 00 00 00 00	 mov	 DWORD PTR _s_branch, eax
  0807c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _s_branch, 0
  08083	75 05		 jne	 SHORT $LN17@atl_init
  08085	e8 00 00 00 00	 call	 _abort
$LN17@atl_init:

; 3203 :         Cconst(s_xdo, "(XDO)");

  0808a	68 00 00 00 00	 push	 OFFSET $SG85131
  0808f	e8 00 00 00 00	 call	 _lookup
  08094	83 c4 04	 add	 esp, 4
  08097	a3 00 00 00 00	 mov	 DWORD PTR _s_xdo, eax
  0809c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _s_xdo, 0
  080a3	75 05		 jne	 SHORT $LN16@atl_init
  080a5	e8 00 00 00 00	 call	 _abort
$LN16@atl_init:

; 3204 :         Cconst(s_xqdo, "(X?DO)");

  080aa	68 00 00 00 00	 push	 OFFSET $SG85134
  080af	e8 00 00 00 00	 call	 _lookup
  080b4	83 c4 04	 add	 esp, 4
  080b7	a3 00 00 00 00	 mov	 DWORD PTR _s_xqdo, eax
  080bc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _s_xqdo, 0
  080c3	75 05		 jne	 SHORT $LN15@atl_init
  080c5	e8 00 00 00 00	 call	 _abort
$LN15@atl_init:

; 3205 :         Cconst(s_xloop, "(XLOOP)");

  080ca	68 00 00 00 00	 push	 OFFSET $SG85137
  080cf	e8 00 00 00 00	 call	 _lookup
  080d4	83 c4 04	 add	 esp, 4
  080d7	a3 00 00 00 00	 mov	 DWORD PTR _s_xloop, eax
  080dc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _s_xloop, 0
  080e3	75 05		 jne	 SHORT $LN14@atl_init
  080e5	e8 00 00 00 00	 call	 _abort
$LN14@atl_init:

; 3206 :         Cconst(s_pxloop, "(+XLOOP)");

  080ea	68 00 00 00 00	 push	 OFFSET $SG85140
  080ef	e8 00 00 00 00	 call	 _lookup
  080f4	83 c4 04	 add	 esp, 4
  080f7	a3 00 00 00 00	 mov	 DWORD PTR _s_pxloop, eax
  080fc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _s_pxloop, 0
  08103	75 05		 jne	 SHORT $LN13@atl_init
  08105	e8 00 00 00 00	 call	 _abort
$LN13@atl_init:

; 3207 :         Cconst(s_abortq, "ABORT\"");

  0810a	68 00 00 00 00	 push	 OFFSET $SG85143
  0810f	e8 00 00 00 00	 call	 _lookup
  08114	83 c4 04	 add	 esp, 4
  08117	a3 00 00 00 00	 mov	 DWORD PTR _s_abortq, eax
  0811c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _s_abortq, 0
  08123	75 05		 jne	 SHORT $LN12@atl_init
  08125	e8 00 00 00 00	 call	 _abort
$LN12@atl_init:

; 3208 : #undef Cconst
; 3209 : 
; 3210 : 	if (stack == NULL) {	      /* Allocate stack if needed */

  0812a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _atl__sk, 0
  08131	75 17		 jne	 SHORT $LN11@atl_init

; 3211 : 	    stack = (stackitem *)
; 3212 : 		alloc(((unsigned int) atl_stklen) * sizeof(stackitem));

  08133	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl_stklen
  08139	c1 e1 02	 shl	 ecx, 2
  0813c	51		 push	 ecx
  0813d	e8 00 00 00 00	 call	 _alloc
  08142	83 c4 04	 add	 esp, 4
  08145	a3 00 00 00 00	 mov	 DWORD PTR _atl__sk, eax
$LN11@atl_init:

; 3213 : 	}
; 3214 : 	stk = stackbot = stack;

  0814a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sk
  08150	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sb, edx
  08156	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sb
  0815b	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax

; 3215 : #ifdef MEMSTAT
; 3216 : 	stackmax = stack;

  08160	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sk
  08166	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sx, ecx

; 3217 : #endif
; 3218 : 	stacktop = stack + atl_stklen;

  0816c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl_stklen
  08172	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sk
  08177	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  0817a	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__st, ecx

; 3219 : 	if (rstack == NULL) {	      /* Allocate return stack if needed */

  08180	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _atl__rk, 0
  08187	75 17		 jne	 SHORT $LN10@atl_init

; 3220 : 	    rstack = (dictword ***)
; 3221 : 		alloc(((unsigned int) atl_rstklen) *
; 3222 : 		sizeof(dictword **));

  08189	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl_rstklen
  0818f	c1 e2 02	 shl	 edx, 2
  08192	52		 push	 edx
  08193	e8 00 00 00 00	 call	 _alloc
  08198	83 c4 04	 add	 esp, 4
  0819b	a3 00 00 00 00	 mov	 DWORD PTR _atl__rk, eax
$LN10@atl_init:

; 3223 : 	}
; 3224 : 	rstk = rstackbot = rstack;

  081a0	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__rk
  081a5	a3 00 00 00 00	 mov	 DWORD PTR _atl__rb, eax
  081aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__rb
  081b0	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__rp, ecx

; 3225 : #ifdef MEMSTAT
; 3226 : 	rstackmax = rstack;

  081b6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__rk
  081bc	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__rx, edx

; 3227 : #endif
; 3228 : 	rstacktop = rstack + atl_rstklen;

  081c2	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_rstklen
  081c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__rk
  081cd	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  081d0	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__rt, edx

; 3229 : #ifdef WALKBACK
; 3230 : 	if (wback == NULL) {

  081d6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _wback, 0
  081dd	75 16		 jne	 SHORT $LN9@atl_init

; 3231 : 	    wback = (dictword **) alloc(((unsigned int) atl_rstklen) *
; 3232 : 				    sizeof(dictword *));

  081df	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_rstklen
  081e4	c1 e0 02	 shl	 eax, 2
  081e7	50		 push	 eax
  081e8	e8 00 00 00 00	 call	 _alloc
  081ed	83 c4 04	 add	 esp, 4
  081f0	a3 00 00 00 00	 mov	 DWORD PTR _wback, eax
$LN9@atl_init:

; 3233 : 	}
; 3234 : 	wbptr = wback;

  081f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _wback
  081fb	89 0d 00 00 00
	00		 mov	 DWORD PTR _wbptr, ecx

; 3235 : #endif
; 3236 : 	if (heap == NULL) {

  08201	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _atl__hb, 0
  08208	0f 85 ad 00 00
	00		 jne	 $LN8@atl_init

; 3237 : 
; 3238 : 	    /* The temporary string buffers are placed at the start of the
; 3239 : 	       heap, which permits us to pointer-check pointers into them
; 3240 : 	       as within the heap extents.  Hence, the size of the buffer
; 3241 : 	       we acquire for the heap is the sum of the heap and temporary
; 3242 : 	       string requests. */
; 3243 : 
; 3244 : 	    int i;
; 3245 : 	    char *cp;
; 3246 : 
; 3247 : 	    /* Force length of temporary strings to even number of
; 3248 : 	       stackitems. */
; 3249 : 	    atl_ltempstr += sizeof(stackitem) -
; 3250 : 		(atl_ltempstr % sizeof(stackitem));

  0820e	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_ltempstr
  08213	33 d2		 xor	 edx, edx
  08215	b9 04 00 00 00	 mov	 ecx, 4
  0821a	f7 f1		 div	 ecx
  0821c	b8 04 00 00 00	 mov	 eax, 4
  08221	2b c2		 sub	 eax, edx
  08223	03 05 00 00 00
	00		 add	 eax, DWORD PTR _atl_ltempstr
  08229	a3 00 00 00 00	 mov	 DWORD PTR _atl_ltempstr, eax

; 3251 : 	    cp = alloc((((unsigned int) atl_heaplen) * sizeof(stackitem)) +
; 3252 : 			((unsigned int) (atl_ntempstr * atl_ltempstr)));

  0822e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl_ntempstr
  08234	0f af 0d 00 00
	00 00		 imul	 ecx, DWORD PTR _atl_ltempstr
  0823b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl_heaplen
  08241	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  08244	50		 push	 eax
  08245	e8 00 00 00 00	 call	 _alloc
  0824a	83 c4 04	 add	 esp, 4
  0824d	89 45 fc	 mov	 DWORD PTR _cp$85163[ebp], eax

; 3253 : 	    heapbot = (stackitem *) cp;

  08250	8b 4d fc	 mov	 ecx, DWORD PTR _cp$85163[ebp]
  08253	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hs, ecx

; 3254 : 	    strbuf = (char **) alloc(((unsigned int) atl_ntempstr) *
; 3255 : 				sizeof(char *));

  08259	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl_ntempstr
  0825f	c1 e2 02	 shl	 edx, 2
  08262	52		 push	 edx
  08263	e8 00 00 00 00	 call	 _alloc
  08268	83 c4 04	 add	 esp, 4
  0826b	a3 00 00 00 00	 mov	 DWORD PTR _atl__ts, eax

; 3256 : 	    for (i = 0; i < atl_ntempstr; i++) {

  08270	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$85162[ebp], 0
  08277	eb 09		 jmp	 SHORT $LN7@atl_init
$LN6@atl_init:
  08279	8b 45 f8	 mov	 eax, DWORD PTR _i$85162[ebp]
  0827c	83 c0 01	 add	 eax, 1
  0827f	89 45 f8	 mov	 DWORD PTR _i$85162[ebp], eax
$LN7@atl_init:
  08282	8b 4d f8	 mov	 ecx, DWORD PTR _i$85162[ebp]
  08285	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl_ntempstr
  0828b	7d 1c		 jge	 SHORT $LN5@atl_init

; 3257 : 		strbuf[i] = cp;

  0828d	8b 55 f8	 mov	 edx, DWORD PTR _i$85162[ebp]
  08290	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__ts
  08295	8b 4d fc	 mov	 ecx, DWORD PTR _cp$85163[ebp]
  08298	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 3258 : 		cp += ((unsigned int) atl_ltempstr);

  0829b	8b 55 fc	 mov	 edx, DWORD PTR _cp$85163[ebp]
  0829e	03 15 00 00 00
	00		 add	 edx, DWORD PTR _atl_ltempstr
  082a4	89 55 fc	 mov	 DWORD PTR _cp$85163[ebp], edx

; 3259 : 	    }

  082a7	eb d0		 jmp	 SHORT $LN6@atl_init
$LN5@atl_init:

; 3260 : 	    cstrbuf = 0;

  082a9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _atl__tn, 0

; 3261 : 	    heap = (stackitem *) cp;  /* Allocatable heap starts after

  082b3	8b 45 fc	 mov	 eax, DWORD PTR _cp$85163[ebp]
  082b6	a3 00 00 00 00	 mov	 DWORD PTR _atl__hb, eax
$LN8@atl_init:

; 3262 : 					 the temporary strings */
; 3263 : 	}
; 3264 : 	/* The system state word is kept in the first word of the heap
; 3265 :            so that pointer checking doesn't bounce references to it.
; 3266 : 	   When creating the heap, we preallocate this word and initialise
; 3267 : 	   the state to the interpretive state. */
; 3268 : 	hptr = heap + 1;

  082bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hb
  082c1	83 c1 04	 add	 ecx, 4
  082c4	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hp, ecx

; 3269 : 	state = Falsity;

  082ca	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hb
  082d0	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 3270 : #ifdef MEMSTAT
; 3271 : 	heapmax = hptr;

  082d6	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  082db	a3 00 00 00 00	 mov	 DWORD PTR _atl__hx, eax

; 3272 : #endif
; 3273 : 	heaptop = heap + atl_heaplen;

  082e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl_heaplen
  082e6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hb
  082ec	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  082ef	a3 00 00 00 00	 mov	 DWORD PTR _atl__ht, eax

; 3274 : 
; 3275 : 	/* Now that dynamic memory is up and running, allocate constants
; 3276 : 	   and variables built into the system.  */
; 3277 : 
; 3278 : #ifdef FILEIO
; 3279 : 	{   static struct {
; 3280 : 		char *sfn;
; 3281 : 		FILE *sfd;
; 3282 : 	    } stdfiles[] = {
; 3283 :                 {"STDIN", NULL},
; 3284 :                 {"STDOUT", NULL},
; 3285 :                 {"STDERR", NULL}
; 3286 : 	    };
; 3287 : 	    int i;
; 3288 : 	    dictword *dw;
; 3289 : 
; 3290 :     	    /* On some systems stdin, stdout, and stderr aren't
; 3291 : 	       constants which can appear in an initialisation.
; 3292 : 	       So, we initialise them at runtime here. */
; 3293 : 	       
; 3294 :     	    stdfiles[0].sfd = stdin;

  082f4	e8 00 00 00 00	 call	 ___iob_func
  082f9	a3 04 00 00 00	 mov	 DWORD PTR ?stdfiles@?8??atl_init@@9@9+4, eax

; 3295 : 	    stdfiles[1].sfd = stdout;

  082fe	e8 00 00 00 00	 call	 ___iob_func
  08303	83 c0 20	 add	 eax, 32			; 00000020H
  08306	a3 0c 00 00 00	 mov	 DWORD PTR ?stdfiles@?8??atl_init@@9@9+12, eax

; 3296 : 	    stdfiles[2].sfd = stderr;

  0830b	e8 00 00 00 00	 call	 ___iob_func
  08310	83 c0 40	 add	 eax, 64			; 00000040H
  08313	a3 14 00 00 00	 mov	 DWORD PTR ?stdfiles@?8??atl_init@@9@9+20, eax

; 3297 : 	    
; 3298 : 	    for (i = 0; i < ELEMENTS(stdfiles); i++) {

  08318	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$85189[ebp], 0
  0831f	eb 09		 jmp	 SHORT $LN4@atl_init
$LN3@atl_init:
  08321	8b 4d f4	 mov	 ecx, DWORD PTR _i$85189[ebp]
  08324	83 c1 01	 add	 ecx, 1
  08327	89 4d f4	 mov	 DWORD PTR _i$85189[ebp], ecx
$LN4@atl_init:
  0832a	83 7d f4 03	 cmp	 DWORD PTR _i$85189[ebp], 3
  0832e	73 50		 jae	 SHORT $LN2@atl_init

; 3299 : 		if ((dw = atl_vardef(stdfiles[i].sfn,
; 3300 : 			2 * sizeof(stackitem))) != NULL) {

  08330	6a 08		 push	 8
  08332	8b 55 f4	 mov	 edx, DWORD PTR _i$85189[ebp]
  08335	8b 04 d5 00 00
	00 00		 mov	 eax, DWORD PTR ?stdfiles@?8??atl_init@@9@9[edx*8]
  0833c	50		 push	 eax
  0833d	e8 00 00 00 00	 call	 _atl_vardef
  08342	83 c4 08	 add	 esp, 8
  08345	89 45 f0	 mov	 DWORD PTR _dw$85190[ebp], eax
  08348	83 7d f0 00	 cmp	 DWORD PTR _dw$85190[ebp], 0
  0834c	74 30		 je	 SHORT $LN1@atl_init

; 3301 : 		    stackitem *si = atl_body(dw);

  0834e	8b 4d f0	 mov	 ecx, DWORD PTR _dw$85190[ebp]
  08351	51		 push	 ecx
  08352	e8 00 00 00 00	 call	 _atl_body
  08357	83 c4 04	 add	 esp, 4
  0835a	89 45 ec	 mov	 DWORD PTR _si$85197[ebp], eax

; 3302 : 		    *si++ = FileSent;

  0835d	8b 55 ec	 mov	 edx, DWORD PTR _si$85197[ebp]
  08360	c7 02 9d df 1f
	83		 mov	 DWORD PTR [edx], -2095063139 ; 831fdf9dH
  08366	8b 45 ec	 mov	 eax, DWORD PTR _si$85197[ebp]
  08369	83 c0 04	 add	 eax, 4
  0836c	89 45 ec	 mov	 DWORD PTR _si$85197[ebp], eax

; 3303 : 		    *si = (stackitem) stdfiles[i].sfd;

  0836f	8b 4d ec	 mov	 ecx, DWORD PTR _si$85197[ebp]
  08372	8b 55 f4	 mov	 edx, DWORD PTR _i$85189[ebp]
  08375	8b 04 d5 04 00
	00 00		 mov	 eax, DWORD PTR ?stdfiles@?8??atl_init@@9@9[edx*8+4]
  0837c	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@atl_init:

; 3304 : 		}
; 3305 : 	    }

  0837e	eb a1		 jmp	 SHORT $LN3@atl_init
$LN2@atl_init:

; 3306 : 	}
; 3307 : #endif /* FILEIO */
; 3308 : 	dictprot = dict;	      /* Protect all standard words */

  08380	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__dh
  08386	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__dp, ecx
$LN25@atl_init:

; 3309 :     }
; 3310 : }

  0838c	8b e5		 mov	 esp, ebp
  0838e	5d		 pop	 ebp
  0838f	c3		 ret	 0
_atl_init ENDP
_TEXT	ENDS
PUBLIC	_atl_lookup
; Function compile flags: /Odtp
_TEXT	SEGMENT
_name$ = 8						; size = 4
_atl_lookup PROC

; 3318 : {

  08390	55		 push	 ebp
  08391	8b ec		 mov	 ebp, esp

; 3319 :     V strcpy(tokbuf, name);	      /* Use built-in token buffer... */

  08393	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  08396	50		 push	 eax
  08397	68 00 00 00 00	 push	 OFFSET _tokbuf
  0839c	e8 00 00 00 00	 call	 _strcpy
  083a1	83 c4 08	 add	 esp, 8

; 3320 :     ucase(tokbuf);                    /* so ucase() doesn't wreck arg string */

  083a4	68 00 00 00 00	 push	 OFFSET _tokbuf
  083a9	e8 00 00 00 00	 call	 _ucase
  083ae	83 c4 04	 add	 esp, 4

; 3321 :     return lookup(tokbuf);	      /* Now use normal lookup() on it */

  083b1	68 00 00 00 00	 push	 OFFSET _tokbuf
  083b6	e8 00 00 00 00	 call	 _lookup
  083bb	83 c4 04	 add	 esp, 4

; 3322 : }

  083be	5d		 pop	 ebp
  083bf	c3		 ret	 0
_atl_lookup ENDP
; Function compile flags: /Odtp
_dw$ = 8						; size = 4
_atl_body PROC

; 3329 : {

  083c0	55		 push	 ebp
  083c1	8b ec		 mov	 ebp, esp

; 3330 :     return ((stackitem *) dw) + Dictwordl;

  083c3	8b 45 08	 mov	 eax, DWORD PTR _dw$[ebp]
  083c6	83 c0 0c	 add	 eax, 12			; 0000000cH

; 3331 : }

  083c9	5d		 pop	 ebp
  083ca	c3		 ret	 0
_atl_body ENDP
_TEXT	ENDS
PUBLIC	_atl_exec
; Function compile flags: /Odtp
_TEXT	SEGMENT
_sestat$ = -8						; size = 4
_restat$ = -4						; size = 4
_dw$ = 8						; size = 4
_atl_exec PROC

; 3340 : {

  083d0	55		 push	 ebp
  083d1	8b ec		 mov	 ebp, esp
  083d3	83 ec 08	 sub	 esp, 8

; 3341 :     int sestat = evalstat, restat;

  083d6	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  083db	89 45 f8	 mov	 DWORD PTR _sestat$[ebp], eax

; 3342 : 
; 3343 :     evalstat = ATL_SNORM;

  083de	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _evalstat, 0

; 3344 : #ifdef BREAK
; 3345 :     broken = False;		      /* Reset break received */

  083e8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _broken, 0

; 3346 : #endif
; 3347 : #undef Memerrs
; 3348 : #define Memerrs evalstat
; 3349 :     Rso(1);

  083f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__rp
  083f8	83 c1 04	 add	 ecx, 4
  083fb	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__rx
  08401	76 0f		 jbe	 SHORT $LN4@atl_exec
  08403	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__rp
  08409	83 c2 04	 add	 edx, 4
  0840c	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__rx, edx
$LN4@atl_exec:
  08412	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__rp
  08417	83 c0 04	 add	 eax, 4
  0841a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__rt
  08420	76 0f		 jbe	 SHORT $LN3@atl_exec
  08422	e8 00 00 00 00	 call	 _atl__Erso
  08427	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  0842c	e9 8b 00 00 00	 jmp	 $LN5@atl_exec
$LN3@atl_exec:

; 3350 :     Rpush = ip; 		      /* Push instruction pointer */

  08431	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__rp
  08437	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__ip
  0843d	89 11		 mov	 DWORD PTR [ecx], edx
  0843f	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__rp
  08444	83 c0 04	 add	 eax, 4
  08447	a3 00 00 00 00	 mov	 DWORD PTR _atl__rp, eax

; 3351 :     ip = NULL;			      /* Keep exword from running away */

  0844c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _atl__ip, 0

; 3352 :     exword(dw);

  08456	8b 4d 08	 mov	 ecx, DWORD PTR _dw$[ebp]
  08459	51		 push	 ecx
  0845a	e8 00 00 00 00	 call	 _exword
  0845f	83 c4 04	 add	 esp, 4

; 3353 :     if (evalstat == ATL_SNORM) {      /* If word ran to completion */

  08462	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _evalstat, 0
  08469	75 3d		 jne	 SHORT $LN2@atl_exec

; 3354 : 	Rsl(1);

  0846b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__rp
  08471	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR _atl__rk
  08477	c1 fa 02	 sar	 edx, 2
  0847a	83 fa 01	 cmp	 edx, 1
  0847d	7d 0c		 jge	 SHORT $LN1@atl_exec
  0847f	e8 00 00 00 00	 call	 _atl__Ersu
  08484	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  08489	eb 31		 jmp	 SHORT $LN5@atl_exec
$LN1@atl_exec:

; 3355 : 	ip = R0;		      /* Pop the return stack */

  0848b	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__rp
  08490	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  08493	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__ip, ecx

; 3356 : 	Rpop;

  08499	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__rp
  0849f	83 ea 04	 sub	 edx, 4
  084a2	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__rp, edx
$LN2@atl_exec:

; 3357 :     }
; 3358 : #undef Memerrs
; 3359 : #define Memerrs
; 3360 :     restat = evalstat;

  084a8	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  084ad	89 45 fc	 mov	 DWORD PTR _restat$[ebp], eax

; 3361 :     evalstat = sestat;

  084b0	8b 4d f8	 mov	 ecx, DWORD PTR _sestat$[ebp]
  084b3	89 0d 00 00 00
	00		 mov	 DWORD PTR _evalstat, ecx

; 3362 :     return restat;

  084b9	8b 45 fc	 mov	 eax, DWORD PTR _restat$[ebp]
$LN5@atl_exec:

; 3363 : }

  084bc	8b e5		 mov	 esp, ebp
  084be	5d		 pop	 ebp
  084bf	c3		 ret	 0
_atl_exec ENDP
; Function compile flags: /Odtp
_isize$ = -8						; size = 4
_di$ = -4						; size = 4
_name$ = 8						; size = 4
_size$ = 12						; size = 4
_atl_vardef PROC

; 3376 : {

  084c0	55		 push	 ebp
  084c1	8b ec		 mov	 ebp, esp
  084c3	83 ec 08	 sub	 esp, 8

; 3377 :     dictword *di;
; 3378 :     int isize = (size + (sizeof(stackitem) - 1)) / sizeof(stackitem);

  084c6	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  084c9	83 c0 03	 add	 eax, 3
  084cc	c1 e8 02	 shr	 eax, 2
  084cf	89 45 f8	 mov	 DWORD PTR _isize$[ebp], eax

; 3379 : 
; 3380 : #undef Memerrs
; 3381 : #define Memerrs NULL
; 3382 :     evalstat = ATL_SNORM;

  084d2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _evalstat, 0

; 3383 :     Ho(Dictwordl + isize);

  084dc	8b 4d f8	 mov	 ecx, DWORD PTR _isize$[ebp]
  084df	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  084e5	8d 44 8a 0c	 lea	 eax, DWORD PTR [edx+ecx*4+12]
  084e9	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hx
  084ef	76 12		 jbe	 SHORT $LN5@atl_vardef
  084f1	8b 4d f8	 mov	 ecx, DWORD PTR _isize$[ebp]
  084f4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  084fa	8d 44 8a 0c	 lea	 eax, DWORD PTR [edx+ecx*4+12]
  084fe	a3 00 00 00 00	 mov	 DWORD PTR _atl__hx, eax
$LN5@atl_vardef:
  08503	8b 4d f8	 mov	 ecx, DWORD PTR _isize$[ebp]
  08506	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  0850c	8d 44 8a 0c	 lea	 eax, DWORD PTR [edx+ecx*4+12]
  08510	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__ht
  08516	76 0c		 jbe	 SHORT $LN4@atl_vardef
  08518	e8 00 00 00 00	 call	 _atl__Eho
  0851d	33 c0		 xor	 eax, eax
  0851f	e9 a3 00 00 00	 jmp	 $LN6@atl_vardef
$LN4@atl_vardef:

; 3384 : #undef Memerrs
; 3385 : #define Memerrs
; 3386 :     if (evalstat != ATL_SNORM)	      /* Did the heap overflow */

  08524	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _evalstat, 0
  0852b	74 07		 je	 SHORT $LN3@atl_vardef

; 3387 : 	return NULL;		      /* Yes.  Return NULL */

  0852d	33 c0		 xor	 eax, eax
  0852f	e9 93 00 00 00	 jmp	 $LN6@atl_vardef
$LN3@atl_vardef:

; 3388 :     createword = (dictword *) hptr;   /* Develop address of word */

  08534	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  0853a	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__wd, ecx

; 3389 :     createword->wcode = P_var;	      /* Store default code */

  08540	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__wd
  08546	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], OFFSET _P_var

; 3390 :     hptr += Dictwordl;		      /* Allocate heap space for word */

  0854d	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  08552	83 c0 0c	 add	 eax, 12			; 0000000cH
  08555	a3 00 00 00 00	 mov	 DWORD PTR _atl__hp, eax
$LN2@atl_vardef:

; 3391 :     while (isize > 0) {

  0855a	83 7d f8 00	 cmp	 DWORD PTR _isize$[ebp], 0
  0855e	7e 26		 jle	 SHORT $LN1@atl_vardef

; 3392 : 	Hstore = 0;		      /* Allocate heap area and clear it */

  08560	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  08566	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0856c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  08572	83 c2 04	 add	 edx, 4
  08575	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hp, edx

; 3393 : 	isize--;

  0857b	8b 45 f8	 mov	 eax, DWORD PTR _isize$[ebp]
  0857e	83 e8 01	 sub	 eax, 1
  08581	89 45 f8	 mov	 DWORD PTR _isize$[ebp], eax

; 3394 :     }

  08584	eb d4		 jmp	 SHORT $LN2@atl_vardef
$LN1@atl_vardef:

; 3395 :     V strcpy(tokbuf, name);	      /* Use built-in token buffer... */

  08586	8b 4d 08	 mov	 ecx, DWORD PTR _name$[ebp]
  08589	51		 push	 ecx
  0858a	68 00 00 00 00	 push	 OFFSET _tokbuf
  0858f	e8 00 00 00 00	 call	 _strcpy
  08594	83 c4 08	 add	 esp, 8

; 3396 :     ucase(tokbuf);                    /* so ucase() doesn't wreck arg string */

  08597	68 00 00 00 00	 push	 OFFSET _tokbuf
  0859c	e8 00 00 00 00	 call	 _ucase
  085a1	83 c4 04	 add	 esp, 4

; 3397 :     enter(tokbuf);		      /* Make dictionary entry for it */

  085a4	68 00 00 00 00	 push	 OFFSET _tokbuf
  085a9	e8 00 00 00 00	 call	 _enter
  085ae	83 c4 04	 add	 esp, 4

; 3398 :     di = createword;		      /* Save word address */

  085b1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__wd
  085b7	89 55 fc	 mov	 DWORD PTR _di$[ebp], edx

; 3399 :     createword = NULL;		      /* Mark no word underway */

  085ba	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _atl__wd, 0

; 3400 :     return di;			      /* Return new word */

  085c4	8b 45 fc	 mov	 eax, DWORD PTR _di$[ebp]
$LN6@atl_vardef:

; 3401 : }

  085c7	8b e5		 mov	 esp, ebp
  085c9	5d		 pop	 ebp
  085ca	c3		 ret	 0
_atl_vardef ENDP
; Function compile flags: /Odtp
_tkname$ = 8						; size = 4
_enter	PROC

; 567  : {

  085d0	55		 push	 ebp
  085d1	8b ec		 mov	 ebp, esp

; 568  :     /* Allocate name buffer */
; 569  :     createword->wname = alloc(((unsigned int) strlen(tkname) + 2));

  085d3	8b 45 08	 mov	 eax, DWORD PTR _tkname$[ebp]
  085d6	50		 push	 eax
  085d7	e8 00 00 00 00	 call	 _strlen
  085dc	83 c4 04	 add	 esp, 4
  085df	83 c0 02	 add	 eax, 2
  085e2	50		 push	 eax
  085e3	e8 00 00 00 00	 call	 _alloc
  085e8	83 c4 04	 add	 esp, 4
  085eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__wd
  085f1	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 570  :     createword->wname[0] = 0;	      /* Clear flags */

  085f4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__wd
  085fa	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  085fd	c6 00 00	 mov	 BYTE PTR [eax], 0

; 571  :     V strcpy(createword->wname + 1, tkname); /* Copy token to name buffer */

  08600	8b 4d 08	 mov	 ecx, DWORD PTR _tkname$[ebp]
  08603	51		 push	 ecx
  08604	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__wd
  0860a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0860d	83 c0 01	 add	 eax, 1
  08610	50		 push	 eax
  08611	e8 00 00 00 00	 call	 _strcpy
  08616	83 c4 08	 add	 esp, 8

; 572  :     createword->wnext = dict;	      /* Chain rest of dictionary to word */

  08619	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__wd
  0861f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__dh
  08625	89 11		 mov	 DWORD PTR [ecx], edx

; 573  :     dict = createword;		      /* Put word at head of dictionary */

  08627	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__wd
  0862c	a3 00 00 00 00	 mov	 DWORD PTR _atl__dh, eax

; 574  : }

  08631	5d		 pop	 ebp
  08632	c3		 ret	 0
_enter	ENDP
; Function compile flags: /Odtp
_mp$ = 8						; size = 4
_atl_mark PROC

; 3407 : {

  08640	55		 push	 ebp
  08641	8b ec		 mov	 ebp, esp

; 3408 :     mp->mstack = stk;		      /* Save stack position */

  08643	8b 45 08	 mov	 eax, DWORD PTR _mp$[ebp]
  08646	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  0864c	89 08		 mov	 DWORD PTR [eax], ecx

; 3409 :     mp->mheap = hptr;		      /* Save heap allocation marker */

  0864e	8b 55 08	 mov	 edx, DWORD PTR _mp$[ebp]
  08651	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  08656	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 3410 :     mp->mrstack = rstk; 	      /* Set return stack pointer */

  08659	8b 4d 08	 mov	 ecx, DWORD PTR _mp$[ebp]
  0865c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__rp
  08662	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 3411 :     mp->mdict = dict;		      /* Save last item in dictionary */

  08665	8b 45 08	 mov	 eax, DWORD PTR _mp$[ebp]
  08668	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__dh
  0866e	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 3412 : }

  08671	5d		 pop	 ebp
  08672	c3		 ret	 0
_atl_mark ENDP
; Function compile flags: /Odtp
_mp$ = 8						; size = 4
_atl_unwind PROC

; 3418 : {

  08680	55		 push	 ebp
  08681	8b ec		 mov	 ebp, esp

; 3419 : 
; 3420 :     /* If atl_mark() was called before the system was initialised, and
; 3421 :        we've initialised since, we cannot unwind.  Just ignore the
; 3422 :        unwind request.	The user must manually atl_init before an
; 3423 :        atl_mark() request is made. */
; 3424 : 
; 3425 :     if (mp->mdict == NULL)	      /* Was mark made before atl_init ? */

  08683	8b 45 08	 mov	 eax, DWORD PTR _mp$[ebp]
  08686	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0868a	75 02		 jne	 SHORT $LN3@atl_unwind

; 3426 : 	return; 		      /* Yes.  Cannot unwind past init */

  0868c	eb 67		 jmp	 SHORT $LN4@atl_unwind
$LN3@atl_unwind:

; 3427 : 
; 3428 :     stk = mp->mstack;		      /* Roll back stack allocation */

  0868e	8b 4d 08	 mov	 ecx, DWORD PTR _mp$[ebp]
  08691	8b 11		 mov	 edx, DWORD PTR [ecx]
  08693	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx

; 3429 :     hptr = mp->mheap;		      /* Reset heap state */

  08699	8b 45 08	 mov	 eax, DWORD PTR _mp$[ebp]
  0869c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0869f	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hp, ecx

; 3430 :     rstk = mp->mrstack; 	      /* Reset the return stack */

  086a5	8b 55 08	 mov	 edx, DWORD PTR _mp$[ebp]
  086a8	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  086ab	a3 00 00 00 00	 mov	 DWORD PTR _atl__rp, eax
$LN2@atl_unwind:

; 3431 : 
; 3432 :     /* To unwind the dictionary, we can't just reset the pointer,
; 3433 :        we must walk back through the chain and release all the name
; 3434 :        buffers attached to the items allocated after the mark was
; 3435 :        made. */
; 3436 : 
; 3437 :     while (dict != NULL && dict != dictprot && dict != mp->mdict) {

  086b0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _atl__dh, 0
  086b7	74 3c		 je	 SHORT $LN4@atl_unwind
  086b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__dh
  086bf	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__dp
  086c5	74 2e		 je	 SHORT $LN4@atl_unwind
  086c7	8b 55 08	 mov	 edx, DWORD PTR _mp$[ebp]
  086ca	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__dh
  086cf	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  086d2	74 21		 je	 SHORT $LN4@atl_unwind

; 3438 : 	free(dict->wname);	      /* Release name string for item */

  086d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__dh
  086da	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  086dd	52		 push	 edx
  086de	e8 00 00 00 00	 call	 _free
  086e3	83 c4 04	 add	 esp, 4

; 3439 : 	dict = dict->wnext;	      /* Link to previous item */

  086e6	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__dh
  086eb	8b 08		 mov	 ecx, DWORD PTR [eax]
  086ed	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__dh, ecx

; 3440 :     }

  086f3	eb bb		 jmp	 SHORT $LN2@atl_unwind
$LN4@atl_unwind:

; 3441 : }

  086f5	5d		 pop	 ebp
  086f6	c3		 ret	 0
_atl_unwind ENDP
_TEXT	ENDS
PUBLIC	_atl_break
; Function compile flags: /Odtp
_TEXT	SEGMENT
_atl_break PROC

; 3453 : {

  08700	55		 push	 ebp
  08701	8b ec		 mov	 ebp, esp

; 3454 :     broken = True;		      /* Set break request */

  08703	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _broken, 1

; 3455 : }

  0870d	5d		 pop	 ebp
  0870e	c3		 ret	 0
_atl_break ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp
_TEXT	SEGMENT
_scomm$ = -180						; size = 4
_es$ = -176						; size = 4
_sinstr$ = -172						; size = 4
_s$ = -168						; size = 134
__$ArrayPad$ = -28					; size = 4
_sip$ = -24						; size = 4
_mk$ = -20						; size = 16
_lineno$ = -4						; size = 4
_fp$ = 8						; size = 4
_atl_load PROC

; 3462 : {

  08710	55		 push	 ebp
  08711	8b ec		 mov	 ebp, esp
  08713	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  08719	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0871e	33 c5		 xor	 eax, ebp
  08720	89 45 e4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3463 :     int es = ATL_SNORM;

  08723	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _es$[ebp], 0

; 3464 :     char s[134];
; 3465 :     atl_statemark mk;
; 3466 :     atl_int scomm = atl_comment;      /* Stack comment pending state */

  0872d	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl_comment
  08732	89 85 4c ff ff
	ff		 mov	 DWORD PTR _scomm$[ebp], eax

; 3467 :     dictword **sip = ip;	      /* Stack instruction pointer */

  08738	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__ip
  0873e	89 4d e8	 mov	 DWORD PTR _sip$[ebp], ecx

; 3468 :     char *sinstr = instream;	      /* Stack input stream */

  08741	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _instream
  08747	89 95 54 ff ff
	ff		 mov	 DWORD PTR _sinstr$[ebp], edx

; 3469 :     int lineno = 0;		      /* Current line number */

  0874d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lineno$[ebp], 0

; 3470 : 
; 3471 :     atl_errline = 0;		      /* Reset line number of error */

  08754	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _atl_errline, 0

; 3472 :     atl_mark(&mk);

  0875e	8d 45 ec	 lea	 eax, DWORD PTR _mk$[ebp]
  08761	50		 push	 eax
  08762	e8 00 00 00 00	 call	 _atl_mark
  08767	83 c4 04	 add	 esp, 4

; 3473 :     ip = NULL;			      /* Fool atl_eval into interp state */

  0876a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _atl__ip, 0
$LN4@atl_load:

; 3474 :     while (atl_fgetsp(s, 132, fp) != NULL) {

  08774	8b 4d 08	 mov	 ecx, DWORD PTR _fp$[ebp]
  08777	51		 push	 ecx
  08778	68 84 00 00 00	 push	 132			; 00000084H
  0877d	8d 95 58 ff ff
	ff		 lea	 edx, DWORD PTR _s$[ebp]
  08783	52		 push	 edx
  08784	e8 00 00 00 00	 call	 _atl_fgetsp
  08789	83 c4 0c	 add	 esp, 12			; 0000000cH
  0878c	85 c0		 test	 eax, eax
  0878e	74 40		 je	 SHORT $LN3@atl_load

; 3475 : 	lineno++;

  08790	8b 45 fc	 mov	 eax, DWORD PTR _lineno$[ebp]
  08793	83 c0 01	 add	 eax, 1
  08796	89 45 fc	 mov	 DWORD PTR _lineno$[ebp], eax

; 3476 : 	if ((es = atl_eval(s)) != ATL_SNORM) {

  08799	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR _s$[ebp]
  0879f	51		 push	 ecx
  087a0	e8 00 00 00 00	 call	 _atl_eval
  087a5	83 c4 04	 add	 esp, 4
  087a8	89 85 50 ff ff
	ff		 mov	 DWORD PTR _es$[ebp], eax
  087ae	83 bd 50 ff ff
	ff 00		 cmp	 DWORD PTR _es$[ebp], 0
  087b5	74 17		 je	 SHORT $LN2@atl_load

; 3477 : 	    atl_errline = lineno;     /* Save line number of error */

  087b7	8b 55 fc	 mov	 edx, DWORD PTR _lineno$[ebp]
  087ba	89 15 00 00 00
	00		 mov	 DWORD PTR _atl_errline, edx

; 3478 : 	    atl_unwind(&mk);

  087c0	8d 45 ec	 lea	 eax, DWORD PTR _mk$[ebp]
  087c3	50		 push	 eax
  087c4	e8 00 00 00 00	 call	 _atl_unwind
  087c9	83 c4 04	 add	 esp, 4

; 3479 : 	    break;

  087cc	eb 02		 jmp	 SHORT $LN3@atl_load
$LN2@atl_load:

; 3480 : 	}
; 3481 :     }

  087ce	eb a4		 jmp	 SHORT $LN4@atl_load
$LN3@atl_load:

; 3482 :     /* If there were no other errors, check for a runaway comment.  If
; 3483 :        we ended the file in comment-ignore mode, set the runaway comment
; 3484 :        error status and unwind the file.  */
; 3485 :     if ((es == ATL_SNORM) && (atl_comment == Truth)) {

  087d0	83 bd 50 ff ff
	ff 00		 cmp	 DWORD PTR _es$[ebp], 0
  087d7	75 2c		 jne	 SHORT $LN1@atl_load
  087d9	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _atl_comment, -1
  087e0	75 23		 jne	 SHORT $LN1@atl_load

; 3486 : #ifdef MEMMESSAGE
; 3487 :         V printf("\nRunaway `(' comment.\n");

  087e2	68 00 00 00 00	 push	 OFFSET $SG85282
  087e7	e8 00 00 00 00	 call	 _printf
  087ec	83 c4 04	 add	 esp, 4

; 3488 : #endif
; 3489 : 	es = ATL_RUNCOMM;

  087ef	c7 85 50 ff ff
	ff f5 ff ff ff	 mov	 DWORD PTR _es$[ebp], -11 ; fffffff5H

; 3490 : 	atl_unwind(&mk);

  087f9	8d 4d ec	 lea	 ecx, DWORD PTR _mk$[ebp]
  087fc	51		 push	 ecx
  087fd	e8 00 00 00 00	 call	 _atl_unwind
  08802	83 c4 04	 add	 esp, 4
$LN1@atl_load:

; 3491 :     }
; 3492 :     atl_comment = scomm;	      /* Unstack comment pending status */

  08805	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _scomm$[ebp]
  0880b	89 15 00 00 00
	00		 mov	 DWORD PTR _atl_comment, edx

; 3493 :     ip = sip;			      /* Unstack instruction pointer */

  08811	8b 45 e8	 mov	 eax, DWORD PTR _sip$[ebp]
  08814	a3 00 00 00 00	 mov	 DWORD PTR _atl__ip, eax

; 3494 :     instream = sinstr;		      /* Unstack input stream */

  08819	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _sinstr$[ebp]
  0881f	89 0d 00 00 00
	00		 mov	 DWORD PTR _instream, ecx

; 3495 :     return es;

  08825	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _es$[ebp]

; 3496 : }

  0882b	8b 4d e4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0882e	33 cd		 xor	 ecx, ebp
  08830	e8 00 00 00 00	 call	 @__security_check_cookie@4
  08835	8b e5		 mov	 esp, ebp
  08837	5d		 pop	 ebp
  08838	c3		 ret	 0
_atl_load ENDP
_TEXT	ENDS
PUBLIC	_atl_prologue
; Function compile flags: /Odtp
_TEXT	SEGMENT
_ap$85301 = -12						; size = 4
_vp$85300 = -8						; size = 4
_i$85299 = -4						; size = 4
_sp$ = 8						; size = 4
_atl_prologue PROC

; 3504 : {

  08840	55		 push	 ebp
  08841	8b ec		 mov	 ebp, esp
  08843	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 3505 :     static struct {
; 3506 : 	char *pname;
; 3507 : 	atl_int *pparam;
; 3508 :     } proname[] = {
; 3509 :         {"STACK ", &atl_stklen},
; 3510 :         {"RSTACK ", &atl_rstklen},
; 3511 :         {"HEAP ", &atl_heaplen},
; 3512 :         {"TEMPSTRL ", &atl_ltempstr},
; 3513 :         {"TEMPSTRN ", &atl_ntempstr}
; 3514 :     };
; 3515 : 
; 3516 :     if (strncmp(sp, "\\ *", 3) == 0) {

  08846	6a 03		 push	 3
  08848	68 00 00 00 00	 push	 OFFSET $SG85298
  0884d	8b 45 08	 mov	 eax, DWORD PTR _sp$[ebp]
  08850	50		 push	 eax
  08851	e8 00 00 00 00	 call	 _strncmp
  08856	83 c4 0c	 add	 esp, 12			; 0000000cH
  08859	85 c0		 test	 eax, eax
  0885b	0f 85 a4 00 00
	00		 jne	 $LN6@atl_prolog

; 3517 : 	int i;
; 3518 : 	char *vp = sp + 3, *ap;

  08861	8b 4d 08	 mov	 ecx, DWORD PTR _sp$[ebp]
  08864	83 c1 03	 add	 ecx, 3
  08867	89 4d f8	 mov	 DWORD PTR _vp$85300[ebp], ecx

; 3519 : 
; 3520 : 	ucase(vp);

  0886a	8b 55 f8	 mov	 edx, DWORD PTR _vp$85300[ebp]
  0886d	52		 push	 edx
  0886e	e8 00 00 00 00	 call	 _ucase
  08873	83 c4 04	 add	 esp, 4

; 3521 : 	for (i = 0; i < ELEMENTS(proname); i++) {

  08876	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$85299[ebp], 0
  0887d	eb 09		 jmp	 SHORT $LN5@atl_prolog
$LN4@atl_prolog:
  0887f	8b 45 fc	 mov	 eax, DWORD PTR _i$85299[ebp]
  08882	83 c0 01	 add	 eax, 1
  08885	89 45 fc	 mov	 DWORD PTR _i$85299[ebp], eax
$LN5@atl_prolog:
  08888	83 7d fc 05	 cmp	 DWORD PTR _i$85299[ebp], 5
  0888c	73 77		 jae	 SHORT $LN6@atl_prolog

; 3522 : 	    if (strncmp(sp + 3, proname[i].pname,
; 3523 : 		    strlen(proname[i].pname)) == 0) {

  0888e	8b 4d fc	 mov	 ecx, DWORD PTR _i$85299[ebp]
  08891	8b 14 cd 00 00
	00 00		 mov	 edx, DWORD PTR ?proname@?1??atl_prologue@@9@9[ecx*8]
  08898	52		 push	 edx
  08899	e8 00 00 00 00	 call	 _strlen
  0889e	83 c4 04	 add	 esp, 4
  088a1	50		 push	 eax
  088a2	8b 45 fc	 mov	 eax, DWORD PTR _i$85299[ebp]
  088a5	8b 0c c5 00 00
	00 00		 mov	 ecx, DWORD PTR ?proname@?1??atl_prologue@@9@9[eax*8]
  088ac	51		 push	 ecx
  088ad	8b 55 08	 mov	 edx, DWORD PTR _sp$[ebp]
  088b0	83 c2 03	 add	 edx, 3
  088b3	52		 push	 edx
  088b4	e8 00 00 00 00	 call	 _strncmp
  088b9	83 c4 0c	 add	 esp, 12			; 0000000cH
  088bc	85 c0		 test	 eax, eax
  088be	75 40		 jne	 SHORT $LN2@atl_prolog

; 3524 :                 if ((ap = strchr(sp + 3, ' ')) != NULL) {

  088c0	6a 20		 push	 32			; 00000020H
  088c2	8b 45 08	 mov	 eax, DWORD PTR _sp$[ebp]
  088c5	83 c0 03	 add	 eax, 3
  088c8	50		 push	 eax
  088c9	e8 00 00 00 00	 call	 _strchr
  088ce	83 c4 08	 add	 esp, 8
  088d1	89 45 f4	 mov	 DWORD PTR _ap$85301[ebp], eax
  088d4	83 7d f4 00	 cmp	 DWORD PTR _ap$85301[ebp], 0
  088d8	74 26		 je	 SHORT $LN2@atl_prolog

; 3525 :                     V sscanf(ap + 1, "%li", proname[i].pparam);

  088da	8b 4d fc	 mov	 ecx, DWORD PTR _i$85299[ebp]
  088dd	8b 14 cd 04 00
	00 00		 mov	 edx, DWORD PTR ?proname@?1??atl_prologue@@9@9[ecx*8+4]
  088e4	52		 push	 edx
  088e5	68 00 00 00 00	 push	 OFFSET $SG85309
  088ea	8b 45 f4	 mov	 eax, DWORD PTR _ap$85301[ebp]
  088ed	83 c0 01	 add	 eax, 1
  088f0	50		 push	 eax
  088f1	e8 00 00 00 00	 call	 _sscanf
  088f6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3526 : #ifdef PROLOGUEDEBUG
; 3527 : V printf("Prologue set %sto %ld\n", proname[i].pname, *proname[i].pparam);
; 3528 : #endif
; 3529 : 		    return 1;

  088f9	b8 01 00 00 00	 mov	 eax, 1
  088fe	eb 07		 jmp	 SHORT $LN7@atl_prolog
$LN2@atl_prolog:

; 3530 : 	       }
; 3531 : 	    }
; 3532 : 	}

  08900	e9 7a ff ff ff	 jmp	 $LN4@atl_prolog
$LN6@atl_prolog:

; 3533 :     }
; 3534 :     return 0;

  08905	33 c0		 xor	 eax, eax
$LN7@atl_prolog:

; 3535 : }

  08907	8b e5		 mov	 esp, ebp
  08909	5d		 pop	 ebp
  0890a	c3		 ret	 0
_atl_prologue ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv72 = -56						; size = 4
_l$85449 = -52						; size = 4
_l$85436 = -48						; size = 4
_i$85413 = -44						; size = 4
_tru$85419 = -40					; size = 8
_i$85392 = -28						; size = 4
_tru$85398 = -24					; size = 8
__$ArrayPad$ = -16					; size = 4
_dw$85329 = -12						; size = 4
_di$85320 = -8						; size = 4
_i$ = -4						; size = 4
_sp$ = 8						; size = 4
_atl_eval PROC

; 3541 : {

  08910	55		 push	 ebp
  08911	8b ec		 mov	 ebp, esp
  08913	83 ec 38	 sub	 esp, 56			; 00000038H
  08916	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0891b	33 c5		 xor	 eax, ebp
  0891d	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3542 :     int i;
; 3543 : 
; 3544 : #undef Memerrs
; 3545 : #define Memerrs evalstat
; 3546 :     instream = sp;

  08920	8b 45 08	 mov	 eax, DWORD PTR _sp$[ebp]
  08923	a3 00 00 00 00	 mov	 DWORD PTR _instream, eax

; 3547 :     evalstat = ATL_SNORM;	      /* Set normal evaluation status */

  08928	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _evalstat, 0

; 3548 : #ifdef BREAK
; 3549 :     broken = False;		      /* Reset asynchronous break */

  08932	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _broken, 0

; 3550 : #endif
; 3551 : 
; 3552 : /* If automatic prologue processing is configured and we haven't yet
; 3553 :    initialised, check if this is a prologue statement.	If so, execute
; 3554 :    it.	Otherwise automatically initialise with the memory specifications
; 3555 :    currently operative. */
; 3556 : 
; 3557 : #ifdef PROLOGUE
; 3558 :     if (dict == NULL) {

  0893c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _atl__dh, 0
  08943	75 1f		 jne	 SHORT $LN74@atl_eval

; 3559 : 	if (atl_prologue(sp))

  08945	8b 4d 08	 mov	 ecx, DWORD PTR _sp$[ebp]
  08948	51		 push	 ecx
  08949	e8 00 00 00 00	 call	 _atl_prologue
  0894e	83 c4 04	 add	 esp, 4
  08951	85 c0		 test	 eax, eax
  08953	74 0a		 je	 SHORT $LN73@atl_eval

; 3560 : 	   return evalstat;

  08955	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  0895a	e9 25 08 00 00	 jmp	 $LN75@atl_eval
$LN73@atl_eval:

; 3561 : 	atl_init();

  0895f	e8 00 00 00 00	 call	 _atl_init
$LN74@atl_eval:

; 3562 :     }
; 3563 : #endif /* PROLOGUE */
; 3564 : 
; 3565 :     while ((evalstat == ATL_SNORM) && (i = token(&instream)) != TokNull) {

  08964	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _evalstat, 0
  0896b	0f 85 0e 08 00
	00		 jne	 $LN71@atl_eval
  08971	68 00 00 00 00	 push	 OFFSET _instream
  08976	e8 00 00 00 00	 call	 _token
  0897b	83 c4 04	 add	 esp, 4
  0897e	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  08981	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  08985	0f 84 f4 07 00
	00		 je	 $LN71@atl_eval

; 3566 : 	dictword *di;
; 3567 : 
; 3568 : 	switch (i) {

  0898b	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0898e	89 55 c8	 mov	 DWORD PTR tv72[ebp], edx
  08991	8b 45 c8	 mov	 eax, DWORD PTR tv72[ebp]
  08994	83 e8 01	 sub	 eax, 1
  08997	89 45 c8	 mov	 DWORD PTR tv72[ebp], eax
  0899a	83 7d c8 03	 cmp	 DWORD PTR tv72[ebp], 3
  0899e	0f 87 c5 07 00
	00		 ja	 $LN1@atl_eval
  089a4	8b 4d c8	 mov	 ecx, DWORD PTR tv72[ebp]
  089a7	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN77@atl_eval[ecx*4]
$LN68@atl_eval:

; 3569 : 	    case TokWord:
; 3570 : 		if (forgetpend) {

  089ae	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _forgetpend, 0
  089b5	0f 84 10 01 00
	00		 je	 $LN67@atl_eval

; 3571 : 		    forgetpend = False;

  089bb	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _forgetpend, 0

; 3572 : 		    ucase(tokbuf);

  089c5	68 00 00 00 00	 push	 OFFSET _tokbuf
  089ca	e8 00 00 00 00	 call	 _ucase
  089cf	83 c4 04	 add	 esp, 4

; 3573 : 		    if ((di = lookup(tokbuf)) != NULL) {

  089d2	68 00 00 00 00	 push	 OFFSET _tokbuf
  089d7	e8 00 00 00 00	 call	 _lookup
  089dc	83 c4 04	 add	 esp, 4
  089df	89 45 f8	 mov	 DWORD PTR _di$85320[ebp], eax
  089e2	83 7d f8 00	 cmp	 DWORD PTR _di$85320[ebp], 0
  089e6	0f 84 be 00 00
	00		 je	 $LN66@atl_eval

; 3574 : 			dictword *dw = dict;

  089ec	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__dh
  089f2	89 55 f4	 mov	 DWORD PTR _dw$85329[ebp], edx
$LN65@atl_eval:

; 3575 : 
; 3576 : 			/* Pass 1.  Rip through the dictionary to make sure
; 3577 : 				    this word is not past the marker that
; 3578 : 				    guards against forgetting too much. */
; 3579 : 
; 3580 : 			while (dw != NULL) {

  089f5	83 7d f4 00	 cmp	 DWORD PTR _dw$85329[ebp], 0
  089f9	74 50		 je	 SHORT $LN64@atl_eval

; 3581 : 			    if (dw == dictprot) {

  089fb	8b 45 f4	 mov	 eax, DWORD PTR _dw$85329[ebp]
  089fe	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__dp
  08a04	75 1e		 jne	 SHORT $LN63@atl_eval

; 3582 : #ifdef MEMMESSAGE
; 3583 :                                 V printf("\nForget protected.\n");

  08a06	68 00 00 00 00	 push	 OFFSET $SG85336
  08a0b	e8 00 00 00 00	 call	 _printf
  08a10	83 c4 04	 add	 esp, 4

; 3584 : #endif
; 3585 : 				evalstat = ATL_FORGETPROT;

  08a13	c7 05 00 00 00
	00 f8 ff ff ff	 mov	 DWORD PTR _evalstat, -8	; fffffff8H

; 3586 : 				di = NULL;

  08a1d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _di$85320[ebp], 0
$LN63@atl_eval:

; 3587 : 			    }
; 3588 : 			    if (strcmp(dw->wname + 1, tokbuf) == 0)

  08a24	68 00 00 00 00	 push	 OFFSET _tokbuf
  08a29	8b 4d f4	 mov	 ecx, DWORD PTR _dw$85329[ebp]
  08a2c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  08a2f	83 c2 01	 add	 edx, 1
  08a32	52		 push	 edx
  08a33	e8 00 00 00 00	 call	 _strcmp
  08a38	83 c4 08	 add	 esp, 8
  08a3b	85 c0		 test	 eax, eax
  08a3d	75 02		 jne	 SHORT $LN62@atl_eval

; 3589 : 				break;

  08a3f	eb 0a		 jmp	 SHORT $LN64@atl_eval
$LN62@atl_eval:

; 3590 : 			    dw = dw->wnext;

  08a41	8b 45 f4	 mov	 eax, DWORD PTR _dw$85329[ebp]
  08a44	8b 08		 mov	 ecx, DWORD PTR [eax]
  08a46	89 4d f4	 mov	 DWORD PTR _dw$85329[ebp], ecx

; 3591 : 			}

  08a49	eb aa		 jmp	 SHORT $LN65@atl_eval
$LN64@atl_eval:

; 3592 : 
; 3593 : 			/* Pass 2.  Walk back through the dictionary
; 3594 : 				    items until we encounter the target
; 3595 :                                     of the FORGET.  Release each item's
; 3596 : 				    name buffer and dechain it from the
; 3597 : 				    dictionary list. */
; 3598 : 
; 3599 : 			if (di != NULL) {

  08a4b	83 7d f8 00	 cmp	 DWORD PTR _di$85320[ebp], 0
  08a4f	74 57		 je	 SHORT $LN56@atl_eval
$LN60@atl_eval:

; 3600 : 			    do {
; 3601 : 				dw = dict;

  08a51	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__dh
  08a57	89 55 f4	 mov	 DWORD PTR _dw$85329[ebp], edx

; 3602 : 				if (dw->wname != NULL)

  08a5a	8b 45 f4	 mov	 eax, DWORD PTR _dw$85329[ebp]
  08a5d	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  08a61	74 0f		 je	 SHORT $LN57@atl_eval

; 3603 : 				    free(dw->wname);

  08a63	8b 4d f4	 mov	 ecx, DWORD PTR _dw$85329[ebp]
  08a66	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  08a69	52		 push	 edx
  08a6a	e8 00 00 00 00	 call	 _free
  08a6f	83 c4 04	 add	 esp, 4
$LN57@atl_eval:

; 3604 : 				dict = dw->wnext;

  08a72	8b 45 f4	 mov	 eax, DWORD PTR _dw$85329[ebp]
  08a75	8b 08		 mov	 ecx, DWORD PTR [eax]
  08a77	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__dh, ecx

; 3605 : 			    } while (dw != di);

  08a7d	8b 55 f4	 mov	 edx, DWORD PTR _dw$85329[ebp]
  08a80	3b 55 f8	 cmp	 edx, DWORD PTR _di$85320[ebp]
  08a83	75 cc		 jne	 SHORT $LN60@atl_eval

; 3606 : 			    /* Finally, back the heap allocation pointer
; 3607 : 			       up to the start of the last item forgotten. */
; 3608 : 			    hptr = (stackitem *) di;

  08a85	8b 45 f8	 mov	 eax, DWORD PTR _di$85320[ebp]
  08a88	a3 00 00 00 00	 mov	 DWORD PTR _atl__hp, eax

; 3609 : 			    /* Uhhhh, just one more thing.  If this word
; 3610 :                                was defined with DOES>, there's a link to
; 3611 : 			       the method address hidden before its
; 3612 :                                wnext field.  See if it's a DOES> by testing
; 3613 : 			       the wcode field for P_dodoes and, if so,
; 3614 : 			       back up the heap one more item. */
; 3615 : 			    if (di->wcode == (codeptr) P_dodoes) {

  08a8d	8b 4d f8	 mov	 ecx, DWORD PTR _di$85320[ebp]
  08a90	81 79 08 00 00
	00 00		 cmp	 DWORD PTR [ecx+8], OFFSET _atl__Pds
  08a97	75 0f		 jne	 SHORT $LN56@atl_eval

; 3616 : #ifdef FORGETDEBUG
; 3617 : V printf(" Forgetting DOES> word. ");
; 3618 : #endif
; 3619 : 				hptr--;

  08a99	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  08a9f	83 ea 04	 sub	 edx, 4
  08aa2	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hp, edx
$LN56@atl_eval:

; 3620 : 			    }
; 3621 : 			}
; 3622 : 		    } else {

  08aa8	eb 1c		 jmp	 SHORT $LN55@atl_eval
$LN66@atl_eval:

; 3623 : #ifdef MEMMESSAGE
; 3624 :                         V printf(" '%s' undefined ", tokbuf);

  08aaa	68 00 00 00 00	 push	 OFFSET _tokbuf
  08aaf	68 00 00 00 00	 push	 OFFSET $SG85351
  08ab4	e8 00 00 00 00	 call	 _printf
  08ab9	83 c4 08	 add	 esp, 8

; 3625 : #endif
; 3626 : 			evalstat = ATL_UNDEFINED;

  08abc	c7 05 00 00 00
	00 f9 ff ff ff	 mov	 DWORD PTR _evalstat, -7	; fffffff9H
$LN55@atl_eval:

; 3627 : 		    }

  08ac6	e9 65 02 00 00	 jmp	 $LN35@atl_eval
$LN67@atl_eval:

; 3628 : 		} else if (tickpend) {

  08acb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _tickpend, 0
  08ad2	0f 84 a8 00 00
	00		 je	 $LN53@atl_eval

; 3629 : 		    tickpend = False;

  08ad8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _tickpend, 0

; 3630 : 		    ucase(tokbuf);

  08ae2	68 00 00 00 00	 push	 OFFSET _tokbuf
  08ae7	e8 00 00 00 00	 call	 _ucase
  08aec	83 c4 04	 add	 esp, 4

; 3631 : 		    if ((di = lookup(tokbuf)) != NULL) {

  08aef	68 00 00 00 00	 push	 OFFSET _tokbuf
  08af4	e8 00 00 00 00	 call	 _lookup
  08af9	83 c4 04	 add	 esp, 4
  08afc	89 45 f8	 mov	 DWORD PTR _di$85320[ebp], eax
  08aff	83 7d f8 00	 cmp	 DWORD PTR _di$85320[ebp], 0
  08b03	74 5a		 je	 SHORT $LN52@atl_eval

; 3632 : 			So(1);

  08b05	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  08b0a	83 c0 04	 add	 eax, 4
  08b0d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__sx
  08b13	76 0f		 jbe	 SHORT $LN51@atl_eval
  08b15	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  08b1b	83 c1 04	 add	 ecx, 4
  08b1e	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sx, ecx
$LN51@atl_eval:
  08b24	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  08b2a	83 c2 04	 add	 edx, 4
  08b2d	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__st
  08b33	76 0f		 jbe	 SHORT $LN50@atl_eval
  08b35	e8 00 00 00 00	 call	 _atl__Eso
  08b3a	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  08b3f	e9 40 06 00 00	 jmp	 $LN75@atl_eval
$LN50@atl_eval:

; 3633 : 			Push = (stackitem) di; /* Push word compile address */

  08b44	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  08b49	8b 4d f8	 mov	 ecx, DWORD PTR _di$85320[ebp]
  08b4c	89 08		 mov	 DWORD PTR [eax], ecx
  08b4e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  08b54	83 c2 04	 add	 edx, 4
  08b57	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx

; 3634 : 		    } else {

  08b5d	eb 1c		 jmp	 SHORT $LN49@atl_eval
$LN52@atl_eval:

; 3635 : #ifdef MEMMESSAGE
; 3636 :                         V printf(" '%s' undefined ", tokbuf);

  08b5f	68 00 00 00 00	 push	 OFFSET _tokbuf
  08b64	68 00 00 00 00	 push	 OFFSET $SG85361
  08b69	e8 00 00 00 00	 call	 _printf
  08b6e	83 c4 08	 add	 esp, 8

; 3637 : #endif
; 3638 : 			evalstat = ATL_UNDEFINED;

  08b71	c7 05 00 00 00
	00 f9 ff ff ff	 mov	 DWORD PTR _evalstat, -7	; fffffff9H
$LN49@atl_eval:

; 3639 : 		    }

  08b7b	e9 b0 01 00 00	 jmp	 $LN35@atl_eval
$LN53@atl_eval:

; 3640 : 		} else if (defpend) {

  08b80	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _defpend, 0
  08b87	74 55		 je	 SHORT $LN47@atl_eval

; 3641 : 		    /* If a definition is pending, define the token and
; 3642 : 		       leave the address of the new word item created for
; 3643 : 		       it on the return stack. */
; 3644 : 		    defpend = False;

  08b89	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _defpend, 0

; 3645 : 		    ucase(tokbuf);

  08b93	68 00 00 00 00	 push	 OFFSET _tokbuf
  08b98	e8 00 00 00 00	 call	 _ucase
  08b9d	83 c4 04	 add	 esp, 4

; 3646 : 		    if (atl_redef && (lookup(tokbuf) != NULL))

  08ba0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _atl_redef, 0
  08ba7	74 23		 je	 SHORT $LN46@atl_eval
  08ba9	68 00 00 00 00	 push	 OFFSET _tokbuf
  08bae	e8 00 00 00 00	 call	 _lookup
  08bb3	83 c4 04	 add	 esp, 4
  08bb6	85 c0		 test	 eax, eax
  08bb8	74 12		 je	 SHORT $LN46@atl_eval

; 3647 :                         V printf("\n%s isn't unique.", tokbuf);

  08bba	68 00 00 00 00	 push	 OFFSET _tokbuf
  08bbf	68 00 00 00 00	 push	 OFFSET $SG85367
  08bc4	e8 00 00 00 00	 call	 _printf
  08bc9	83 c4 08	 add	 esp, 8
$LN46@atl_eval:

; 3648 : 		    enter(tokbuf);

  08bcc	68 00 00 00 00	 push	 OFFSET _tokbuf
  08bd1	e8 00 00 00 00	 call	 _enter
  08bd6	83 c4 04	 add	 esp, 4

; 3649 : 		} else {

  08bd9	e9 52 01 00 00	 jmp	 $LN35@atl_eval
$LN47@atl_eval:

; 3650 : 		    di = lookup(tokbuf);

  08bde	68 00 00 00 00	 push	 OFFSET _tokbuf
  08be3	e8 00 00 00 00	 call	 _lookup
  08be8	83 c4 04	 add	 esp, 4
  08beb	89 45 f8	 mov	 DWORD PTR _di$85320[ebp], eax

; 3651 : 		    if (di != NULL) {

  08bee	83 7d f8 00	 cmp	 DWORD PTR _di$85320[ebp], 0
  08bf2	0f 84 10 01 00
	00		 je	 $LN44@atl_eval

; 3652 :                         /* Test the state.  If we're interpreting, execute
; 3653 :                            the word in all cases.  If we're compiling,
; 3654 : 			   compile the word unless it is a compiler word
; 3655 : 			   flagged for immediate execution by the
; 3656 : 			   presence of a space as the first character of
; 3657 : 			   its name in the dictionary entry. */
; 3658 : 			if (state &&
; 3659 : 			    (cbrackpend || ctickpend ||
; 3660 : 			     !(di->wname[0] & IMMEDIATE))) {

  08bf8	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hb
  08bfd	83 38 00	 cmp	 DWORD PTR [eax], 0
  08c00	0f 84 f4 00 00
	00		 je	 $LN43@atl_eval
  08c06	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cbrackpend, 0
  08c0d	75 1b		 jne	 SHORT $LN42@atl_eval
  08c0f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ctickpend, 0
  08c16	75 12		 jne	 SHORT $LN42@atl_eval
  08c18	8b 4d f8	 mov	 ecx, DWORD PTR _di$85320[ebp]
  08c1b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  08c1e	0f be 02	 movsx	 eax, BYTE PTR [edx]
  08c21	83 e0 01	 and	 eax, 1
  08c24	0f 85 d0 00 00
	00		 jne	 $LN43@atl_eval
$LN42@atl_eval:

; 3661 : 			    if (ctickpend) {

  08c2a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _ctickpend, 0
  08c31	74 64		 je	 SHORT $LN41@atl_eval

; 3662 : 				/* If a compile-time tick preceded this
; 3663 : 				   word, compile a (lit) word to cause its
; 3664 : 				   address to be pushed at execution time. */
; 3665 : 				Ho(1);

  08c33	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  08c39	83 c1 04	 add	 ecx, 4
  08c3c	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__hx
  08c42	76 0f		 jbe	 SHORT $LN40@atl_eval
  08c44	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  08c4a	83 c2 04	 add	 edx, 4
  08c4d	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hx, edx
$LN40@atl_eval:
  08c53	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  08c58	83 c0 04	 add	 eax, 4
  08c5b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__ht
  08c61	76 0f		 jbe	 SHORT $LN39@atl_eval
  08c63	e8 00 00 00 00	 call	 _atl__Eho
  08c68	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  08c6d	e9 12 05 00 00	 jmp	 $LN75@atl_eval
$LN39@atl_eval:

; 3666 : 				Hstore = s_lit;

  08c72	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  08c78	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _s_lit
  08c7e	89 11		 mov	 DWORD PTR [ecx], edx
  08c80	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  08c85	83 c0 04	 add	 eax, 4
  08c88	a3 00 00 00 00	 mov	 DWORD PTR _atl__hp, eax

; 3667 : 				ctickpend = False;

  08c8d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ctickpend, 0
$LN41@atl_eval:

; 3668 : 			    }
; 3669 : 			    cbrackpend = False;

  08c97	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _cbrackpend, 0

; 3670 : 			    Ho(1);	  /* Reserve stack space */

  08ca1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  08ca7	83 c1 04	 add	 ecx, 4
  08caa	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__hx
  08cb0	76 0f		 jbe	 SHORT $LN38@atl_eval
  08cb2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  08cb8	83 c2 04	 add	 edx, 4
  08cbb	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hx, edx
$LN38@atl_eval:
  08cc1	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  08cc6	83 c0 04	 add	 eax, 4
  08cc9	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__ht
  08ccf	76 0f		 jbe	 SHORT $LN37@atl_eval
  08cd1	e8 00 00 00 00	 call	 _atl__Eho
  08cd6	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  08cdb	e9 a4 04 00 00	 jmp	 $LN75@atl_eval
$LN37@atl_eval:

; 3671 : 			    Hstore = (stackitem) di;/* Compile word address */

  08ce0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  08ce6	8b 55 f8	 mov	 edx, DWORD PTR _di$85320[ebp]
  08ce9	89 11		 mov	 DWORD PTR [ecx], edx
  08ceb	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  08cf0	83 c0 04	 add	 eax, 4
  08cf3	a3 00 00 00 00	 mov	 DWORD PTR _atl__hp, eax

; 3672 : 			} else {

  08cf8	eb 0c		 jmp	 SHORT $LN36@atl_eval
$LN43@atl_eval:

; 3673 : 			    exword(di);   /* Execute word */

  08cfa	8b 4d f8	 mov	 ecx, DWORD PTR _di$85320[ebp]
  08cfd	51		 push	 ecx
  08cfe	e8 00 00 00 00	 call	 _exword
  08d03	83 c4 04	 add	 esp, 4
$LN36@atl_eval:

; 3674 : 			}
; 3675 : 		    } else {

  08d06	eb 28		 jmp	 SHORT $LN35@atl_eval
$LN44@atl_eval:

; 3676 : #ifdef MEMMESSAGE
; 3677 :                         V printf(" '%s' undefined ", tokbuf);

  08d08	68 00 00 00 00	 push	 OFFSET _tokbuf
  08d0d	68 00 00 00 00	 push	 OFFSET $SG85382
  08d12	e8 00 00 00 00	 call	 _printf
  08d17	83 c4 08	 add	 esp, 8

; 3678 : #endif
; 3679 : 			evalstat = ATL_UNDEFINED;

  08d1a	c7 05 00 00 00
	00 f9 ff ff ff	 mov	 DWORD PTR _evalstat, -7	; fffffff9H

; 3680 : 			state = Falsity;

  08d24	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hb
  08d2a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$LN35@atl_eval:

; 3681 : 		    }
; 3682 : 		}
; 3683 : 		break;

  08d30	e9 45 04 00 00	 jmp	 $LN69@atl_eval
$LN34@atl_eval:

; 3684 : 
; 3685 : 	    case TokInt:
; 3686 : 		if (state) {

  08d35	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hb
  08d3a	83 38 00	 cmp	 DWORD PTR [eax], 0
  08d3d	74 77		 je	 SHORT $LN33@atl_eval

; 3687 : 		    Ho(2);

  08d3f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  08d45	83 c1 08	 add	 ecx, 8
  08d48	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__hx
  08d4e	76 0f		 jbe	 SHORT $LN32@atl_eval
  08d50	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  08d56	83 c2 08	 add	 edx, 8
  08d59	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__hx, edx
$LN32@atl_eval:
  08d5f	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  08d64	83 c0 08	 add	 eax, 8
  08d67	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__ht
  08d6d	76 0f		 jbe	 SHORT $LN31@atl_eval
  08d6f	e8 00 00 00 00	 call	 _atl__Eho
  08d74	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  08d79	e9 06 04 00 00	 jmp	 $LN75@atl_eval
$LN31@atl_eval:

; 3688 : 		    Hstore = s_lit;   /* Push (lit) */

  08d7e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  08d84	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _s_lit
  08d8a	89 11		 mov	 DWORD PTR [ecx], edx
  08d8c	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  08d91	83 c0 04	 add	 eax, 4
  08d94	a3 00 00 00 00	 mov	 DWORD PTR _atl__hp, eax

; 3689 : 		    Hstore = tokint;  /* Compile actual literal */

  08d99	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  08d9f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tokint
  08da5	89 11		 mov	 DWORD PTR [ecx], edx
  08da7	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  08dac	83 c0 04	 add	 eax, 4
  08daf	a3 00 00 00 00	 mov	 DWORD PTR _atl__hp, eax

; 3690 : 		} else {

  08db4	eb 5a		 jmp	 SHORT $LN30@atl_eval
$LN33@atl_eval:

; 3691 : 		    So(1);

  08db6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  08dbc	83 c1 04	 add	 ecx, 4
  08dbf	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__sx
  08dc5	76 0f		 jbe	 SHORT $LN29@atl_eval
  08dc7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  08dcd	83 c2 04	 add	 edx, 4
  08dd0	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sx, edx
$LN29@atl_eval:
  08dd6	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  08ddb	83 c0 04	 add	 eax, 4
  08dde	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__st
  08de4	76 0f		 jbe	 SHORT $LN28@atl_eval
  08de6	e8 00 00 00 00	 call	 _atl__Eso
  08deb	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  08df0	e9 8f 03 00 00	 jmp	 $LN75@atl_eval
$LN28@atl_eval:

; 3692 : 		    Push = tokint;

  08df5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  08dfb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tokint
  08e01	89 11		 mov	 DWORD PTR [ecx], edx
  08e03	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  08e08	83 c0 04	 add	 eax, 4
  08e0b	a3 00 00 00 00	 mov	 DWORD PTR _atl__sp, eax
$LN30@atl_eval:

; 3693 : 		}
; 3694 : 		break;

  08e10	e9 65 03 00 00	 jmp	 $LN69@atl_eval
$LN27@atl_eval:

; 3695 : 
; 3696 : #ifdef REAL
; 3697 : 	    case TokReal:
; 3698 : 		if (state) {

  08e15	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hb
  08e1b	83 39 00	 cmp	 DWORD PTR [ecx], 0
  08e1e	0f 84 9d 00 00
	00		 je	 $LN26@atl_eval

; 3699 : 		    int i;
; 3700 :     	    	    union {
; 3701 : 		    	atl_real r;
; 3702 : 			stackitem s[Realsize];
; 3703 : 		    } tru;
; 3704 : 
; 3705 : 		    Ho(Realsize + 1);

  08e24	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  08e2a	83 c2 0c	 add	 edx, 12			; 0000000cH
  08e2d	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__hx
  08e33	76 0d		 jbe	 SHORT $LN25@atl_eval
  08e35	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  08e3a	83 c0 0c	 add	 eax, 12			; 0000000cH
  08e3d	a3 00 00 00 00	 mov	 DWORD PTR _atl__hx, eax
$LN25@atl_eval:
  08e42	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  08e48	83 c1 0c	 add	 ecx, 12			; 0000000cH
  08e4b	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  08e51	76 0f		 jbe	 SHORT $LN24@atl_eval
  08e53	e8 00 00 00 00	 call	 _atl__Eho
  08e58	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  08e5d	e9 22 03 00 00	 jmp	 $LN75@atl_eval
$LN24@atl_eval:

; 3706 : 		    Hstore = s_flit;  /* Push (flit) */

  08e62	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  08e68	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_flit
  08e6d	89 02		 mov	 DWORD PTR [edx], eax
  08e6f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  08e75	83 c1 04	 add	 ecx, 4
  08e78	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hp, ecx

; 3707 :     	    	    tru.r = tokreal;

  08e7e	dd 05 00 00 00
	00		 fld	 QWORD PTR _tokreal
  08e84	dd 5d e8	 fstp	 QWORD PTR _tru$85398[ebp]

; 3708 : 		    for (i = 0; i < Realsize; i++) {

  08e87	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$85392[ebp], 0
  08e8e	eb 09		 jmp	 SHORT $LN23@atl_eval
$LN22@atl_eval:
  08e90	8b 55 e4	 mov	 edx, DWORD PTR _i$85392[ebp]
  08e93	83 c2 01	 add	 edx, 1
  08e96	89 55 e4	 mov	 DWORD PTR _i$85392[ebp], edx
$LN23@atl_eval:
  08e99	83 7d e4 02	 cmp	 DWORD PTR _i$85392[ebp], 2
  08e9d	73 1d		 jae	 SHORT $LN21@atl_eval

; 3709 : 			Hstore = tru.s[i];

  08e9f	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  08ea4	8b 4d e4	 mov	 ecx, DWORD PTR _i$85392[ebp]
  08ea7	8b 54 8d e8	 mov	 edx, DWORD PTR _tru$85398[ebp+ecx*4]
  08eab	89 10		 mov	 DWORD PTR [eax], edx
  08ead	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  08eb2	83 c0 04	 add	 eax, 4
  08eb5	a3 00 00 00 00	 mov	 DWORD PTR _atl__hp, eax

; 3710 : 		    }

  08eba	eb d4		 jmp	 SHORT $LN22@atl_eval
$LN21@atl_eval:

; 3711 : 		} else {

  08ebc	e9 80 00 00 00	 jmp	 $LN15@atl_eval
$LN26@atl_eval:

; 3712 : 		    int i;
; 3713 :     	    	    union {
; 3714 : 		    	atl_real r;
; 3715 : 			stackitem s[Realsize];
; 3716 : 		    } tru;
; 3717 : 
; 3718 : 		    So(Realsize);

  08ec1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  08ec7	83 c1 08	 add	 ecx, 8
  08eca	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__sx
  08ed0	76 0f		 jbe	 SHORT $LN19@atl_eval
  08ed2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  08ed8	83 c2 08	 add	 edx, 8
  08edb	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sx, edx
$LN19@atl_eval:
  08ee1	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  08ee6	83 c0 08	 add	 eax, 8
  08ee9	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__st
  08eef	76 0f		 jbe	 SHORT $LN18@atl_eval
  08ef1	e8 00 00 00 00	 call	 _atl__Eso
  08ef6	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  08efb	e9 84 02 00 00	 jmp	 $LN75@atl_eval
$LN18@atl_eval:

; 3719 :     	    	    tru.r = tokreal;

  08f00	dd 05 00 00 00
	00		 fld	 QWORD PTR _tokreal
  08f06	dd 5d d8	 fstp	 QWORD PTR _tru$85419[ebp]

; 3720 : 		    for (i = 0; i < Realsize; i++) {

  08f09	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$85413[ebp], 0
  08f10	eb 09		 jmp	 SHORT $LN17@atl_eval
$LN16@atl_eval:
  08f12	8b 4d d4	 mov	 ecx, DWORD PTR _i$85413[ebp]
  08f15	83 c1 01	 add	 ecx, 1
  08f18	89 4d d4	 mov	 DWORD PTR _i$85413[ebp], ecx
$LN17@atl_eval:
  08f1b	83 7d d4 02	 cmp	 DWORD PTR _i$85413[ebp], 2
  08f1f	73 20		 jae	 SHORT $LN15@atl_eval

; 3721 : 			Push = tru.s[i];

  08f21	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  08f27	8b 45 d4	 mov	 eax, DWORD PTR _i$85413[ebp]
  08f2a	8b 4c 85 d8	 mov	 ecx, DWORD PTR _tru$85419[ebp+eax*4]
  08f2e	89 0a		 mov	 DWORD PTR [edx], ecx
  08f30	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  08f36	83 c2 04	 add	 edx, 4
  08f39	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__sp, edx

; 3722 : 		    }

  08f3f	eb d1		 jmp	 SHORT $LN16@atl_eval
$LN15@atl_eval:

; 3723 : 		}
; 3724 : 		break;

  08f41	e9 34 02 00 00	 jmp	 $LN69@atl_eval
$LN14@atl_eval:

; 3725 : #endif /* REAL */
; 3726 : 
; 3727 : #ifdef STRING
; 3728 : 	    case TokString:
; 3729 : 		if (stringlit) {

  08f46	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _stringlit, 0
  08f4d	0f 84 c1 00 00
	00		 je	 $LN13@atl_eval

; 3730 : 		    stringlit = False;

  08f53	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _stringlit, 0

; 3731 : 		    if (state) {

  08f5d	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hb
  08f62	83 38 00	 cmp	 DWORD PTR [eax], 0
  08f65	0f 84 92 00 00
	00		 je	 $LN12@atl_eval

; 3732 : 			int l = (strlen(tokbuf) + 1 + sizeof(stackitem)) /
; 3733 : 				    sizeof(stackitem);

  08f6b	68 00 00 00 00	 push	 OFFSET _tokbuf
  08f70	e8 00 00 00 00	 call	 _strlen
  08f75	83 c4 04	 add	 esp, 4
  08f78	83 c0 05	 add	 eax, 5
  08f7b	c1 e8 02	 shr	 eax, 2
  08f7e	89 45 d0	 mov	 DWORD PTR _l$85436[ebp], eax

; 3734 : 			Ho(l);

  08f81	8b 4d d0	 mov	 ecx, DWORD PTR _l$85436[ebp]
  08f84	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  08f8a	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  08f8d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__hx
  08f93	76 11		 jbe	 SHORT $LN11@atl_eval
  08f95	8b 4d d0	 mov	 ecx, DWORD PTR _l$85436[ebp]
  08f98	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  08f9e	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  08fa1	a3 00 00 00 00	 mov	 DWORD PTR _atl__hx, eax
$LN11@atl_eval:
  08fa6	8b 4d d0	 mov	 ecx, DWORD PTR _l$85436[ebp]
  08fa9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  08faf	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  08fb2	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _atl__ht
  08fb8	76 0f		 jbe	 SHORT $LN10@atl_eval
  08fba	e8 00 00 00 00	 call	 _atl__Eho
  08fbf	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  08fc4	e9 bb 01 00 00	 jmp	 $LN75@atl_eval
$LN10@atl_eval:

; 3735 : 			*((char *) hptr) = l;  /* Store in-line skip length */

  08fc9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  08fcf	8a 55 d0	 mov	 dl, BYTE PTR _l$85436[ebp]
  08fd2	88 11		 mov	 BYTE PTR [ecx], dl

; 3736 : 			V strcpy(((char *) hptr) + 1, tokbuf);

  08fd4	68 00 00 00 00	 push	 OFFSET _tokbuf
  08fd9	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  08fde	83 c0 01	 add	 eax, 1
  08fe1	50		 push	 eax
  08fe2	e8 00 00 00 00	 call	 _strcpy
  08fe7	83 c4 08	 add	 esp, 8

; 3737 : 			hptr += l;

  08fea	8b 4d d0	 mov	 ecx, DWORD PTR _l$85436[ebp]
  08fed	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  08ff3	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  08ff6	a3 00 00 00 00	 mov	 DWORD PTR _atl__hp, eax

; 3738 : 		    } else {

  08ffb	eb 12		 jmp	 SHORT $LN9@atl_eval
$LN12@atl_eval:

; 3739 :                         V printf("%s", tokbuf);

  08ffd	68 00 00 00 00	 push	 OFFSET _tokbuf
  09002	68 00 00 00 00	 push	 OFFSET $SG85446
  09007	e8 00 00 00 00	 call	 _printf
  0900c	83 c4 08	 add	 esp, 8
$LN9@atl_eval:

; 3740 : 		    }
; 3741 : 		} else {

  0900f	e9 53 01 00 00	 jmp	 $LN4@atl_eval
$LN13@atl_eval:

; 3742 : 		    if (state) {

  09014	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hb
  0901a	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0901d	0f 84 b3 00 00
	00		 je	 $LN7@atl_eval

; 3743 : 			int l = (strlen(tokbuf) + 1 + sizeof(stackitem)) /
; 3744 : 				    sizeof(stackitem);

  09023	68 00 00 00 00	 push	 OFFSET _tokbuf
  09028	e8 00 00 00 00	 call	 _strlen
  0902d	83 c4 04	 add	 esp, 4
  09030	83 c0 05	 add	 eax, 5
  09033	c1 e8 02	 shr	 eax, 2
  09036	89 45 cc	 mov	 DWORD PTR _l$85449[ebp], eax

; 3745 : 			Ho(l + 1);

  09039	8b 55 cc	 mov	 edx, DWORD PTR _l$85449[ebp]
  0903c	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  09041	8d 4c 90 04	 lea	 ecx, DWORD PTR [eax+edx*4+4]
  09045	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__hx
  0904b	76 12		 jbe	 SHORT $LN6@atl_eval
  0904d	8b 55 cc	 mov	 edx, DWORD PTR _l$85449[ebp]
  09050	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  09055	8d 4c 90 04	 lea	 ecx, DWORD PTR [eax+edx*4+4]
  09059	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hx, ecx
$LN6@atl_eval:
  0905f	8b 55 cc	 mov	 edx, DWORD PTR _l$85449[ebp]
  09062	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  09067	8d 4c 90 04	 lea	 ecx, DWORD PTR [eax+edx*4+4]
  0906b	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__ht
  09071	76 0f		 jbe	 SHORT $LN5@atl_eval
  09073	e8 00 00 00 00	 call	 _atl__Eho
  09078	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  0907d	e9 02 01 00 00	 jmp	 $LN75@atl_eval
$LN5@atl_eval:

; 3746 : 			/* Compile string literal instruction, followed by
; 3747 : 			   in-line skip length and the string literal */
; 3748 : 			Hstore = s_strlit;

  09082	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  09088	a1 00 00 00 00	 mov	 eax, DWORD PTR _s_strlit
  0908d	89 02		 mov	 DWORD PTR [edx], eax
  0908f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  09095	83 c1 04	 add	 ecx, 4
  09098	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hp, ecx

; 3749 : 			*((char *) hptr) = l;  /* Store in-line skip length */

  0909e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__hp
  090a4	8a 45 cc	 mov	 al, BYTE PTR _l$85449[ebp]
  090a7	88 02		 mov	 BYTE PTR [edx], al

; 3750 : 			V strcpy(((char *) hptr) + 1, tokbuf);

  090a9	68 00 00 00 00	 push	 OFFSET _tokbuf
  090ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__hp
  090b4	83 c1 01	 add	 ecx, 1
  090b7	51		 push	 ecx
  090b8	e8 00 00 00 00	 call	 _strcpy
  090bd	83 c4 08	 add	 esp, 8

; 3751 : 			hptr += l;

  090c0	8b 55 cc	 mov	 edx, DWORD PTR _l$85449[ebp]
  090c3	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__hp
  090c8	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  090cb	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__hp, ecx

; 3752 : 		    } else {

  090d1	e9 91 00 00 00	 jmp	 $LN4@atl_eval
$LN7@atl_eval:

; 3753 : 			So(1);

  090d6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  090dc	83 c2 04	 add	 edx, 4
  090df	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR _atl__sx
  090e5	76 0d		 jbe	 SHORT $LN3@atl_eval
  090e7	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__sp
  090ec	83 c0 04	 add	 eax, 4
  090ef	a3 00 00 00 00	 mov	 DWORD PTR _atl__sx, eax
$LN3@atl_eval:
  090f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  090fa	83 c1 04	 add	 ecx, 4
  090fd	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _atl__st
  09103	76 0c		 jbe	 SHORT $LN2@atl_eval
  09105	e8 00 00 00 00	 call	 _atl__Eso
  0910a	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
  0910f	eb 73		 jmp	 SHORT $LN75@atl_eval
$LN2@atl_eval:

; 3754 : 			V strcpy(strbuf[cstrbuf], tokbuf);

  09111	68 00 00 00 00	 push	 OFFSET _tokbuf
  09116	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__tn
  0911c	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__ts
  09121	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  09124	51		 push	 ecx
  09125	e8 00 00 00 00	 call	 _strcpy
  0912a	83 c4 08	 add	 esp, 8

; 3755 : 			Push = (stackitem) strbuf[cstrbuf];

  0912d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _atl__sp
  09133	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__tn
  09138	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__ts
  0913e	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  09141	89 02		 mov	 DWORD PTR [edx], eax
  09143	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _atl__sp
  09149	83 c1 04	 add	 ecx, 4
  0914c	89 0d 00 00 00
	00		 mov	 DWORD PTR _atl__sp, ecx

; 3756 : 			cstrbuf = (cstrbuf + 1) % ((int) atl_ntempstr);

  09152	a1 00 00 00 00	 mov	 eax, DWORD PTR _atl__tn
  09157	83 c0 01	 add	 eax, 1
  0915a	99		 cdq
  0915b	f7 3d 00 00 00
	00		 idiv	 DWORD PTR _atl_ntempstr
  09161	89 15 00 00 00
	00		 mov	 DWORD PTR _atl__tn, edx
$LN4@atl_eval:

; 3757 : 		    }
; 3758 : 		}
; 3759 : 		break;

  09167	eb 11		 jmp	 SHORT $LN69@atl_eval
$LN1@atl_eval:

; 3760 : #endif /* STRING */
; 3761 : 	    default:
; 3762 :                 V printf("\nUnknown token type %d\n", i);

  09169	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0916c	52		 push	 edx
  0916d	68 00 00 00 00	 push	 OFFSET $SG85465
  09172	e8 00 00 00 00	 call	 _printf
  09177	83 c4 08	 add	 esp, 8
$LN69@atl_eval:

; 3763 : 		break;
; 3764 : 	}
; 3765 :     }

  0917a	e9 e5 f7 ff ff	 jmp	 $LN74@atl_eval
$LN71@atl_eval:

; 3766 :     return evalstat;

  0917f	a1 00 00 00 00	 mov	 eax, DWORD PTR _evalstat
$LN75@atl_eval:

; 3767 : }

  09184	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  09187	33 cd		 xor	 ecx, ebp
  09189	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0918e	8b e5		 mov	 esp, ebp
  09190	5d		 pop	 ebp
  09191	c3		 ret	 0
  09192	8b ff		 npad	 2
$LN77@atl_eval:
  09194	00 00 00 00	 DD	 $LN68@atl_eval
  09198	00 00 00 00	 DD	 $LN34@atl_eval
  0919c	00 00 00 00	 DD	 $LN27@atl_eval
  091a0	00 00 00 00	 DD	 $LN14@atl_eval
_atl_eval ENDP
_TEXT	ENDS
END
